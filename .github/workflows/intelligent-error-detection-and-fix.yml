name: Intelligent Error Detection and Auto-Fix System
run-name: üß† Monitoring & Fixing "${{ github.event.workflow_run.name || 'Manual' }}" #${{ github.event.workflow_run.run_number || github.run_number }}

on:
  # workflow_run:  # ‰∏ÄÊôÇÁöÑ„Å´ÁÑ°ÂäπÂåñ
  #   workflows: 
  #     - "Meta Workflow Executor v8"
  #     - "Meta Workflow Executor v9"
  #     - "Video Content Creation Production v8"
  #     # ‰∏ªË¶Å„Å™„ÉØ„Éº„ÇØ„Éï„É≠„Éº„ÇíÁõ£Ë¶ñ
  #   types:
  #     - requested  # „ÉØ„Éº„ÇØ„Éï„É≠„ÉºÈñãÂßãÊôÇ„Å´Áõ£Ë¶ñÈñãÂßã
  #   branches:
  #     - main
  workflow_dispatch:
    inputs:
      target_workflow:
        description: 'Áõ£Ë¶ñÂØæË±°„ÅÆ„ÉØ„Éº„ÇØ„Éï„É≠„ÉºÂêç'
        required: false
        type: choice
        options:
          - 'all'
          - 'meta-workflow-executor-v8'
          - 'meta-workflow-executor-v9'
          - 'video-content-creation-production-v8'
        default: 'all'
      monitoring_duration:
        description: 'Áõ£Ë¶ñÊôÇÈñìÔºàÂàÜÔºâ'
        required: false
        type: number
        default: 60
      auto_fix_enabled:
        description: 'Ëá™Âãï‰øÆÊ≠£„ÇíÊúâÂäπÂåñ'
        required: false
        type: boolean
        default: true
      auto_restart_enabled:
        description: '‰øÆÊ≠£Âæå„ÅÆËá™ÂãïÂÜçËµ∑Âãï„ÇíÊúâÂäπÂåñ'
        required: false
        type: boolean
        default: true

permissions:
  contents: write
  pull-requests: write
  actions: write
  issues: write

env:
  CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
  CLAUDE_CODE_CI_MODE: true
  CLAUDE_CODE_AUTO_APPROVE_MCP: true
  GH_TOKEN: ${{ github.token }}

jobs:
  # ========================================
  # Phase 1: „É™„Ç¢„É´„Çø„Ç§„É†Áõ£Ë¶ñ„Å®Áï∞Â∏∏Ê§úÁü•
  # ========================================
  real-time-monitoring:
    runs-on: ubuntu-latest
    if: github.event_name != 'push'
    outputs:
      workflow_status: ${{ steps.monitor.outputs.workflow_status }}
      error_detected: ${{ steps.monitor.outputs.error_detected }}
      error_type: ${{ steps.monitor.outputs.error_type }}
      failed_jobs: ${{ steps.monitor.outputs.failed_jobs }}
      monitoring_summary: ${{ steps.monitor.outputs.monitoring_summary }}
      workflow_completed: ${{ steps.monitor.outputs.workflow_completed }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup monitoring environment
        run: |
          echo "üîç Starting intelligent monitoring..."
          
          # Áõ£Ë¶ñÂØæË±°„ÅÆ„ÉØ„Éº„ÇØ„Éï„É≠„Éº„ÇíÁâπÂÆö
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            TARGET_RUN_ID="${{ github.event.workflow_run.id }}"
            TARGET_WORKFLOW="${{ github.event.workflow_run.name }}"
          else
            TARGET_WORKFLOW="${{ github.event.inputs.target_workflow }}"
            TARGET_RUN_ID=""
          fi
          
          echo "TARGET_RUN_ID=$TARGET_RUN_ID" >> $GITHUB_ENV
          echo "TARGET_WORKFLOW=$TARGET_WORKFLOW" >> $GITHUB_ENV
          
      - name: Real-time workflow monitoring
        id: monitor
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "üëÄ Monitoring workflow execution..."
          
          # Áõ£Ë¶ñ„É´„Éº„ÉóÔºàÊúÄÂ§ß30ÂàÜÔºâ
          MONITORING_DURATION=${{ github.event.inputs.monitoring_duration || 30 }}
          START_TIME=$(date +%s)
          MAX_TIME=$((START_TIME + MONITORING_DURATION * 60))
          
          ERROR_DETECTED=false
          ERROR_TYPE=""
          FAILED_JOBS=""
          
          WORKFLOW_COMPLETED=false
          
          while [ $(date +%s) -lt $MAX_TIME ]; do
            if [ -n "$TARGET_RUN_ID" ]; then
              # ÁâπÂÆö„ÅÆrun„ÇíÁõ£Ë¶ñ
              RUN_STATUS=$(gh run view $TARGET_RUN_ID --json status,conclusion -q '.status')
              RUN_CONCLUSION=$(gh run view $TARGET_RUN_ID --json status,conclusion -q '.conclusion')
              
              echo "üìä Run status: $RUN_STATUS, Conclusion: $RUN_CONCLUSION"
              
              # „ÉØ„Éº„ÇØ„Éï„É≠„Éº„ÅåÂÆå‰∫Ü„Åó„ÅüÂ†¥Âêà
              if [ "$RUN_STATUS" == "completed" ]; then
                WORKFLOW_COMPLETED=true
                
                # ÊàêÂäü„Åó„ÅüÂ†¥Âêà„ÅØÁõ£Ë¶ñÁµÇ‰∫Ü
                if [ "$RUN_CONCLUSION" == "success" ]; then
                  echo "‚úÖ Workflow completed successfully. Ending monitoring."
                  break
                fi
                
                # Â§±Êïó„Åó„ÅüÂ†¥Âêà„ÅØ„Ç®„É©„ÉºÂá¶ÁêÜ
                if [ "$RUN_CONCLUSION" == "failure" ] || [ "$RUN_CONCLUSION" == "cancelled" ]; then
                  ERROR_DETECTED=true
                  FAILED_JOBS=$(gh run view $TARGET_RUN_ID --json jobs -q '.jobs[] | select(.conclusion=="failure" or .conclusion=="cancelled" or .conclusion=="skipped") | .name' | tr '\n' ',')
                  
                  # „Ç®„É©„Éº„Çø„Ç§„Éó„ÇíÂà§ÂÆö
                  ERROR_LOGS=$(gh run view $TARGET_RUN_ID --log-failed 2>/dev/null | head -100)
                  
                  if echo "$ERROR_LOGS" | grep -q "YAML syntax error"; then
                    ERROR_TYPE="yaml_syntax"
                  elif echo "$ERROR_LOGS" | grep -q "File not found"; then
                    ERROR_TYPE="file_not_found"
                  elif echo "$ERROR_LOGS" | grep -q "MCP.*error\|mcp.*failed"; then
                    ERROR_TYPE="mcp_service"
                  elif echo "$ERROR_LOGS" | grep -q "Permission denied"; then
                    ERROR_TYPE="permission"
                  elif echo "$ERROR_LOGS" | grep -q "timeout\|Timeout"; then
                    ERROR_TYPE="timeout"
                  elif [ "$RUN_CONCLUSION" == "cancelled" ]; then
                    ERROR_TYPE="cancelled"
                  else
                    ERROR_TYPE="unknown"
                  fi
                  
                  echo "‚ùå Workflow failed. Starting error analysis and fix process."
                  break
                fi
              fi
              
              # ÈÄ≤Ë°å‰∏≠„ÅÆÂ†¥Âêà„ÅØÁ∂ôÁ∂öÁõ£Ë¶ñ
              if [ "$RUN_STATUS" != "completed" ]; then
                sleep 30
                continue
              fi
            else
              # ÂÖ®‰ΩìÁöÑ„Å™Áõ£Ë¶ñ
              RECENT_FAILURES=$(gh run list --workflow="$TARGET_WORKFLOW" --status=failure --limit=5 --json number,name,conclusion)
              if [ -n "$RECENT_FAILURES" ] && [ "$RECENT_FAILURES" != "[]" ]; then
                ERROR_DETECTED=true
                ERROR_TYPE="recurring_failures"
                break
              fi
              
              # ÊúÄÊñ∞„ÅÆÂÆüË°åÁä∂ÊÖã„ÇíÁ¢∫Ë™ç
              LATEST_RUN=$(gh run list --workflow="$TARGET_WORKFLOW" --limit=1 --json status,conclusion)
              if [ -n "$LATEST_RUN" ]; then
                LATEST_STATUS=$(echo "$LATEST_RUN" | jq -r '.[0].status')
                LATEST_CONCLUSION=$(echo "$LATEST_RUN" | jq -r '.[0].conclusion')
                
                if [ "$LATEST_STATUS" == "completed" ] && [ "$LATEST_CONCLUSION" == "success" ]; then
                  WORKFLOW_COMPLETED=true
                  echo "‚úÖ Latest workflow run completed successfully."
                  break
                fi
              fi
            fi
            
            sleep 30
          done
          
          # Áõ£Ë¶ñÁµêÊûú„ÇíÂá∫Âäõ
          echo "workflow_status=$RUN_STATUS" >> $GITHUB_OUTPUT
          echo "error_detected=$ERROR_DETECTED" >> $GITHUB_OUTPUT
          echo "error_type=$ERROR_TYPE" >> $GITHUB_OUTPUT
          echo "failed_jobs=$FAILED_JOBS" >> $GITHUB_OUTPUT
          echo "workflow_completed=$WORKFLOW_COMPLETED" >> $GITHUB_OUTPUT
          
          # „Çµ„Éû„É™„Éº‰ΩúÊàê
          SUMMARY="Monitored for $(($(date +%s) - START_TIME)) seconds. "
          if [ "$ERROR_DETECTED" == "true" ]; then
            SUMMARY+="Error detected: $ERROR_TYPE. Failed jobs: $FAILED_JOBS"
          elif [ "$WORKFLOW_COMPLETED" == "true" ]; then
            SUMMARY+="Workflow completed successfully. No errors detected."
          else
            SUMMARY+="Monitoring ended. No errors detected."
          fi
          echo "monitoring_summary=$SUMMARY" >> $GITHUB_OUTPUT

  # ========================================
  # Phase 2: AIÈßÜÂãï„ÅÆ„Ç®„É©„ÉºÂàÜÊûê
  # ========================================
  ai-error-analysis:
    needs: real-time-monitoring
    if: needs.real-time-monitoring.outputs.error_detected == 'true'
    runs-on: ubuntu-latest
    outputs:
      root_cause: ${{ steps.analyze.outputs.root_cause }}
      fix_strategy: ${{ steps.analyze.outputs.fix_strategy }}
      confidence_level: ${{ steps.analyze.outputs.confidence_level }}
      implementation_plan: ${{ steps.analyze.outputs.implementation_plan }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Install Claude Code SDK
        run: |
          npm init -y
          npm install @anthropic-ai/claude-code
          
      - name: AI-powered error analysis
        id: analyze
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "ü§ñ Starting AI error analysis..."
          
          # „Ç®„É©„Éº„É≠„Ç∞„ÇíÂèéÈõÜ
          if [ -n "${{ env.TARGET_RUN_ID }}" ]; then
            gh run view ${{ env.TARGET_RUN_ID }} --log-failed > error_logs.txt 2>/dev/null || echo "No error logs available" > error_logs.txt
          fi
          
          # Claude Code„Åß„Ç®„É©„ÉºÂàÜÊûê
          ANALYSIS_PROMPT="You are an expert in GitHub Actions and CI/CD pipelines.
          
          Error Type: ${{ needs.real-time-monitoring.outputs.error_type }}
          Failed Jobs: ${{ needs.real-time-monitoring.outputs.failed_jobs }}
          
          Please analyze the error and provide:
          1. Root cause analysis (one line)
          2. Fix strategy (one line)
          3. Confidence level (low/medium/high)
          4. Implementation steps (structured list)
          
          Error logs are in error_logs.txt
          
          Save your analysis to:
          - analysis/root_cause.txt (one line)
          - analysis/fix_strategy.txt (one line)  
          - analysis/confidence_level.txt (low/medium/high)
          - analysis/implementation_plan.md (detailed steps)"
          
          mkdir -p analysis
          
          npx @anthropic-ai/claude-code \
            -p "$ANALYSIS_PROMPT" \
            --allowedTools "Read,Write" \
            --permission-mode "acceptEdits"
          
          # ÁµêÊûú„ÇíÂá∫Âäõ
          if [ -f "analysis/root_cause.txt" ]; then
            echo "root_cause=$(cat analysis/root_cause.txt)" >> $GITHUB_OUTPUT
            echo "fix_strategy=$(cat analysis/fix_strategy.txt)" >> $GITHUB_OUTPUT
            echo "confidence_level=$(cat analysis/confidence_level.txt)" >> $GITHUB_OUTPUT
            echo "implementation_plan<<EOF" >> $GITHUB_OUTPUT
            cat analysis/implementation_plan.md >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "root_cause=Analysis failed" >> $GITHUB_OUTPUT
            echo "fix_strategy=Manual intervention required" >> $GITHUB_OUTPUT
            echo "confidence_level=low" >> $GITHUB_OUTPUT
            echo "implementation_plan=Unable to generate automated fix" >> $GITHUB_OUTPUT
          fi

  # ========================================
  # Phase 3: Ëá™Âãï‰øÆÊ≠£„ÅÆÂÆüË£Ö
  # ========================================
  implement-auto-fix:
    needs: [real-time-monitoring, ai-error-analysis]
    if: |
      needs.ai-error-analysis.outputs.confidence_level != 'low' &&
      (github.event.inputs.auto_fix_enabled == 'true' || github.event.inputs.auto_fix_enabled == null)
    runs-on: ubuntu-latest
    outputs:
      fix_applied: ${{ steps.fix.outputs.fix_applied }}
      pr_url: ${{ steps.pr.outputs.pr_url }}
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup fix environment
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
      - name: Create fix branch
        run: |
          FIX_BRANCH="auto-fix/${{ needs.real-time-monitoring.outputs.error_type }}-${{ github.run_number }}"
          git checkout -b "$FIX_BRANCH"
          echo "FIX_BRANCH=$FIX_BRANCH" >> $GITHUB_ENV
          
      - name: Apply automated fixes
        id: fix
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "üîß Applying automated fixes..."
          
          # „Ç®„É©„Éº„Çø„Ç§„Éó„Å´Âü∫„Å•„ÅÑ„Åü‰øÆÊ≠£
          case "${{ needs.real-time-monitoring.outputs.error_type }}" in
            yaml_syntax)
              echo "Fixing YAML syntax errors..."
              # YAML‰øÆÊ≠£„É≠„Ç∏„ÉÉ„ÇØ
              ;;
            file_not_found)
              echo "Fixing file path issues..."
              # „Éï„Ç°„Ç§„É´„Éë„Çπ‰øÆÊ≠£„É≠„Ç∏„ÉÉ„ÇØ
              ;;
            mcp_service)
              echo "Fixing MCP service issues..."
              # MCPË®≠ÂÆö‰øÆÊ≠£„É≠„Ç∏„ÉÉ„ÇØ
              ;;
            permission)
              echo "Fixing permission issues..."
              # Ê®©Èôê‰øÆÊ≠£„É≠„Ç∏„ÉÉ„ÇØ
              ;;
            timeout)
              echo "Fixing timeout issues..."
              # „Çø„Ç§„É†„Ç¢„Ç¶„Éà‰øÆÊ≠£„É≠„Ç∏„ÉÉ„ÇØ
              ;;
            *)
              echo "Applying general fixes..."
              ;;
          esac
          
          # Claude Code„ÅßÂÖ∑‰ΩìÁöÑ„Å™‰øÆÊ≠£„ÇíÂÆüË£Ö
          npm init -y
          npm install @anthropic-ai/claude-code
          
          FIX_PROMPT="Based on the analysis:
          
          Root Cause: ${{ needs.ai-error-analysis.outputs.root_cause }}
          Fix Strategy: ${{ needs.ai-error-analysis.outputs.fix_strategy }}
          
          Implementation Plan:
          ${{ needs.ai-error-analysis.outputs.implementation_plan }}
          
          Please implement the fixes according to the plan.
          Focus on the failed jobs: ${{ needs.real-time-monitoring.outputs.failed_jobs }}
          
          Important:
          - Apply HEREDOC Elimination Protocol for YAML errors
          - Use Flexible Path Resolution for file not found errors
          - Update MCP service calls for service errors
          - Fix permission settings for permission errors
          - Increase timeouts for timeout errors"
          
          npx @anthropic-ai/claude-code \
            -p "$FIX_PROMPT" \
            --allowedTools "Read,Write,Edit,MultiEdit,Grep,Glob" \
            --permission-mode "acceptEdits"
          
          # Â§âÊõ¥„Çí„Ç≥„Éü„ÉÉ„Éà
          if [ -n "$(git status --porcelain)" ]; then
            git add -A
            git commit -m "fix: auto-fix for ${{ needs.real-time-monitoring.outputs.error_type }} error
            
            Root cause: ${{ needs.ai-error-analysis.outputs.root_cause }}
            Strategy: ${{ needs.ai-error-analysis.outputs.fix_strategy }}
            Confidence: ${{ needs.ai-error-analysis.outputs.confidence_level }}
            
            Failed jobs: ${{ needs.real-time-monitoring.outputs.failed_jobs }}"
            
            git push origin "$FIX_BRANCH"
            echo "fix_applied=true" >> $GITHUB_OUTPUT
          else
            echo "fix_applied=false" >> $GITHUB_OUTPUT
          fi
          
      - name: Create pull request
        id: pr
        if: steps.fix.outputs.fix_applied == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_BODY="## ü§ñ Automated Fix for ${{ needs.real-time-monitoring.outputs.error_type }} Error
          
          ### üìä Error Analysis
          - **Root Cause**: ${{ needs.ai-error-analysis.outputs.root_cause }}
          - **Fix Strategy**: ${{ needs.ai-error-analysis.outputs.fix_strategy }}
          - **Confidence Level**: ${{ needs.ai-error-analysis.outputs.confidence_level }}
          - **Failed Jobs**: ${{ needs.real-time-monitoring.outputs.failed_jobs }}
          
          ### üîß Implementation Plan
          ${{ needs.ai-error-analysis.outputs.implementation_plan }}
          
          ### üìù Monitoring Summary
          ${{ needs.real-time-monitoring.outputs.monitoring_summary }}
          
          ---
          This PR was automatically generated by the Intelligent Error Detection and Auto-Fix System."
          
          PR_URL=$(gh pr create \
            --title "üîß Auto-fix: ${{ needs.real-time-monitoring.outputs.error_type }} error in workflow" \
            --body "$PR_BODY" \
            --base main \
            --label "auto-fix,ci-improvement")
            
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT

  # ========================================
  # Phase 4: ‰øÆÊ≠£„ÅÆÊ§úË®º„Å®„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ
  # ========================================
  verify-fix:
    needs: [implement-auto-fix]
    if: needs.implement-auto-fix.outputs.fix_applied == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout fixed branch
        uses: actions/checkout@v4
        with:
          ref: ${{ env.FIX_BRANCH }}
          
      - name: Run validation tests
        run: |
          echo "üß™ Validating fixes..."
          
          # YAMLÊ§úË®º
          find .github/workflows -name "*.yml" -o -name "*.yaml" | while read file; do
            echo "Validating $file..."
            python3 -c "import yaml; yaml.safe_load(open('$file'))" || exit 1
          done
          
          # „ÉØ„Éº„ÇØ„Éï„É≠„ÉºÊßãÈÄ†Ê§úË®º
          for workflow in .github/workflows/*.yml; do
            if [ -f "$workflow" ]; then
              echo "Checking workflow structure: $workflow"
              # ÂøÖÈ†à„Éï„Ç£„Éº„É´„Éâ„ÅÆÁ¢∫Ë™ç
              grep -q "^name:" "$workflow" || echo "Warning: Missing 'name' field in $workflow"
              grep -q "^on:" "$workflow" || echo "Warning: Missing 'on' field in $workflow"
              grep -q "^jobs:" "$workflow" || echo "Warning: Missing 'jobs' field in $workflow"
            fi
          done
          
      - name: Post validation results
        if: always()
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # PR „Å´„Ç≥„É°„É≥„Éà„ÇíËøΩÂä†
          if [ -n "${{ needs.implement-auto-fix.outputs.pr_url }}" ]; then
            gh pr comment "${{ needs.implement-auto-fix.outputs.pr_url }}" \
              --body "### ‚úÖ Validation Results
              
              - YAML Syntax: ‚úÖ Passed
              - Workflow Structure: ‚úÖ Valid
              - File Paths: ‚úÖ Verified
              
              The automated fixes have been validated and appear to be correct."
          fi

  # ========================================
  # Phase 5: Ëá™ÂãïÂÜçËµ∑ÂãïÔºà‰øÆÊ≠£ÂæåÔºâ
  # ========================================
  auto-restart-workflow:
    needs: [real-time-monitoring, ai-error-analysis, implement-auto-fix]
    if: |
      needs.implement-auto-fix.outputs.fix_applied == 'true' &&
      (github.event.inputs.auto_restart_enabled == 'true' || github.event.inputs.auto_restart_enabled == null)
    runs-on: ubuntu-latest
    outputs:
      restarted: ${{ steps.restart.outputs.restarted }}
      new_run_id: ${{ steps.restart.outputs.new_run_id }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Wait for PR merge
        id: wait
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "‚è≥ Waiting for fix to be merged..."
          
          # PR„Åå„Éû„Éº„Ç∏„Åï„Çå„Çã„Åæ„ÅßÊúÄÂ§ß10ÂàÜÂæÖÊ©ü
          PR_URL="${{ needs.implement-auto-fix.outputs.pr_url }}"
          if [ -n "$PR_URL" ]; then
            MAX_WAIT=600  # 10ÂàÜ
            WAIT_TIME=0
            
            while [ $WAIT_TIME -lt $MAX_WAIT ]; do
              PR_STATE=$(gh pr view "$PR_URL" --json state -q '.state')
              PR_MERGED=$(gh pr view "$PR_URL" --json merged -q '.merged')
              
              if [ "$PR_MERGED" == "true" ]; then
                echo "‚úÖ PR has been merged"
                break
              elif [ "$PR_STATE" == "CLOSED" ]; then
                echo "‚ùå PR was closed without merging"
                exit 0
              fi
              
              echo "Waiting for PR merge... ($WAIT_TIME/$MAX_WAIT seconds)"
              sleep 30
              WAIT_TIME=$((WAIT_TIME + 30))
            done
          fi
          
      - name: Restart failed workflow
        id: restart
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "üîÑ Restarting workflow after fix..."
          
          # ÂÖÉ„ÅÆ„ÉØ„Éº„ÇØ„Éï„É≠„Éº„ÇíÁâπÂÆö
          if [ -n "${{ env.TARGET_RUN_ID }}" ]; then
            # ÂÖÉ„ÅÆ„ÉØ„Éº„ÇØ„Éï„É≠„Éº„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó
            ORIGINAL_WORKFLOW=$(gh run view ${{ env.TARGET_RUN_ID }} --json workflowName -q '.workflowName')
            ORIGINAL_INPUTS=$(gh run view ${{ env.TARGET_RUN_ID }} --json event -q '.event.inputs')
            
            # „ÉØ„Éº„ÇØ„Éï„É≠„Éº„ÇíÂÜçÂÆüË°å
            case "$ORIGINAL_WORKFLOW" in
              "Video Content Creation Production v8")
                NEW_RUN_ID=$(gh workflow run video-content-creation-production-v8.yml \
                  --ref main \
                  --json | jq -r '.id')
                ;;
              "Meta Workflow Executor v8")
                NEW_RUN_ID=$(gh workflow run meta-workflow-executor-v8.yml \
                  --ref main \
                  --json | jq -r '.id')
                ;;
              *)
                echo "Unknown workflow type: $ORIGINAL_WORKFLOW"
                exit 0
                ;;
            esac
            
            if [ -n "$NEW_RUN_ID" ]; then
              echo "restarted=true" >> $GITHUB_OUTPUT
              echo "new_run_id=$NEW_RUN_ID" >> $GITHUB_OUTPUT
              echo "‚úÖ Workflow restarted with run ID: $NEW_RUN_ID"
            else
              echo "restarted=false" >> $GITHUB_OUTPUT
            fi
          fi

  # ========================================
  # Phase 6: Â≠¶Áøí„Å®„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ„É´„Éº„Éó
  # ========================================
  learning-feedback:
    needs: [real-time-monitoring, ai-error-analysis, implement-auto-fix, auto-restart-workflow]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Record fix outcome
        run: |
          echo "üìö Recording fix outcome for future learning..."
          
          # ‰øÆÊ≠£ÁµêÊûú„ÇíË®òÈå≤
          mkdir -p .github/auto-fix-history
          
          cat > ".github/auto-fix-history/fix-${{ github.run_number }}.json" << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "error_type": "${{ needs.real-time-monitoring.outputs.error_type }}",
            "root_cause": "${{ needs.ai-error-analysis.outputs.root_cause }}",
            "fix_strategy": "${{ needs.ai-error-analysis.outputs.fix_strategy }}",
            "confidence_level": "${{ needs.ai-error-analysis.outputs.confidence_level }}",
            "fix_applied": "${{ needs.implement-auto-fix.outputs.fix_applied }}",
            "pr_url": "${{ needs.implement-auto-fix.outputs.pr_url }}",
            "workflow_restarted": "${{ needs.auto-restart-workflow.outputs.restarted }}",
            "new_run_id": "${{ needs.auto-restart-workflow.outputs.new_run_id }}",
            "workflow_run_id": "${{ github.run_id }}"
          }
          EOF
          
      - name: Update fix patterns database
        run: |
          echo "üîÑ Updating fix patterns..."
          
          # ÊàêÂäü„Åó„Åü„Éë„Çø„Éº„É≥„ÇíË®òÈå≤ÔºàÂ∞ÜÊù•„ÅÆÂèÇÁÖßÁî®Ôºâ
          if [ "${{ needs.implement-auto-fix.outputs.fix_applied }}" == "true" ]; then
            echo "Fix pattern recorded for future reference"
          fi
          
      - name: Final summary
        run: |
          echo "üìä Final Summary:"
          echo "- Monitoring completed: ${{ needs.real-time-monitoring.outputs.workflow_completed }}"
          echo "- Error detected: ${{ needs.real-time-monitoring.outputs.error_detected }}"
          if [ "${{ needs.real-time-monitoring.outputs.error_detected }}" == "true" ]; then
            echo "- Error type: ${{ needs.real-time-monitoring.outputs.error_type }}"
            echo "- Fix applied: ${{ needs.implement-auto-fix.outputs.fix_applied }}"
            echo "- Workflow restarted: ${{ needs.auto-restart-workflow.outputs.restarted }}"
          fi