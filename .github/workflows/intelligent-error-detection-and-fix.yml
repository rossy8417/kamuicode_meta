name: Intelligent Error Detection and Auto-Fix System
run-name: ðŸ§  Monitoring & Fixing "${{ github.event.workflow_run.name || 'Manual' }}" #${{ github.event.workflow_run.run_number || github.run_number }}

on:
  # workflow_run:  # ä¸€æ™‚çš„ã«ç„¡åŠ¹åŒ–
  #   workflows: 
  #     - "Meta Workflow Executor v8"
  #     - "Meta Workflow Executor v9"
  #     - "Video Content Creation Production v8"
  #     # ä¸»è¦ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’ç›£è¦–
  #   types:
  #     - requested  # ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼é–‹å§‹æ™‚ã«ç›£è¦–é–‹å§‹
  #   branches:
  #     - main
  workflow_dispatch:
    inputs:
      target_workflow:
        description: 'ç›£è¦–å¯¾è±¡ã®ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å'
        required: false
        type: choice
        options:
          - 'all'
          - 'meta-workflow-executor-v8'
          - 'meta-workflow-executor-v9'
          - 'video-content-creation-production-v8'
        default: 'all'
      monitoring_duration:
        description: 'ç›£è¦–æ™‚é–“ï¼ˆåˆ†ï¼‰'
        required: false
        type: number
        default: 60
      auto_fix_enabled:
        description: 'è‡ªå‹•ä¿®æ­£ã‚’æœ‰åŠ¹åŒ–'
        required: false
        type: boolean
        default: true
      auto_restart_enabled:
        description: 'ä¿®æ­£å¾Œã®è‡ªå‹•å†èµ·å‹•ã‚’æœ‰åŠ¹åŒ–'
        required: false
        type: boolean
        default: true

permissions:
  contents: write
  pull-requests: write
  actions: write
  issues: write

env:
  CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
  CLAUDE_CODE_CI_MODE: true
  CLAUDE_CODE_AUTO_APPROVE_MCP: true
  GH_TOKEN: ${{ github.token }}

jobs:
  # ========================================
  # Phase 1: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–ã¨ç•°å¸¸æ¤œçŸ¥
  # ========================================
  real-time-monitoring:
    runs-on: ubuntu-latest
    if: github.event_name != 'push'
    outputs:
      workflow_status: ${{ steps.monitor.outputs.workflow_status }}
      error_detected: ${{ steps.monitor.outputs.error_detected }}
      error_type: ${{ steps.monitor.outputs.error_type }}
      failed_jobs: ${{ steps.monitor.outputs.failed_jobs }}
      monitoring_summary: ${{ steps.monitor.outputs.monitoring_summary }}
      workflow_completed: ${{ steps.monitor.outputs.workflow_completed }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup monitoring environment
        run: |
          echo "ðŸ” Starting intelligent monitoring..."
          
          # ç›£è¦–å¯¾è±¡ã®ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’ç‰¹å®š
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            TARGET_RUN_ID="${{ github.event.workflow_run.id }}"
            TARGET_WORKFLOW="${{ github.event.workflow_run.name }}"
          else
            TARGET_WORKFLOW="${{ github.event.inputs.target_workflow }}"
            TARGET_RUN_ID=""
          fi
          
          echo "TARGET_RUN_ID=$TARGET_RUN_ID" >> $GITHUB_ENV
          echo "TARGET_WORKFLOW=$TARGET_WORKFLOW" >> $GITHUB_ENV
          
      - name: Real-time workflow monitoring
        id: monitor
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "ðŸ‘€ Monitoring workflow execution..."
          
          # ç›£è¦–ãƒ«ãƒ¼ãƒ—ï¼ˆæœ€å¤§30åˆ†ï¼‰
          MONITORING_DURATION=${{ github.event.inputs.monitoring_duration || 30 }}
          START_TIME=$(date +%s)
          MAX_TIME=$((START_TIME + MONITORING_DURATION * 60))
          
          ERROR_DETECTED=false
          ERROR_TYPE=""
          FAILED_JOBS=""
          
          WORKFLOW_COMPLETED=false
          
          while [ $(date +%s) -lt $MAX_TIME ]; do
            if [ -n "$TARGET_RUN_ID" ]; then
              # ç‰¹å®šã®runã‚’ç›£è¦–
              RUN_STATUS=$(gh run view $TARGET_RUN_ID --json status,conclusion -q '.status')
              RUN_CONCLUSION=$(gh run view $TARGET_RUN_ID --json status,conclusion -q '.conclusion')
              
              echo "ðŸ“Š Run status: $RUN_STATUS, Conclusion: $RUN_CONCLUSION"
              
              # ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãŒå®Œäº†ã—ãŸå ´åˆ
              if [ "$RUN_STATUS" == "completed" ]; then
                WORKFLOW_COMPLETED=true
                
                # æˆåŠŸã—ãŸå ´åˆã¯ç›£è¦–çµ‚äº†
                if [ "$RUN_CONCLUSION" == "success" ]; then
                  echo "âœ… Workflow completed successfully. Ending monitoring."
                  break
                fi
                
                # å¤±æ•—ã—ãŸå ´åˆã¯ã‚¨ãƒ©ãƒ¼å‡¦ç†
                if [ "$RUN_CONCLUSION" == "failure" ] || [ "$RUN_CONCLUSION" == "cancelled" ]; then
                  ERROR_DETECTED=true
                  FAILED_JOBS=$(gh run view $TARGET_RUN_ID --json jobs -q '.jobs[] | select(.conclusion=="failure" or .conclusion=="cancelled" or .conclusion=="skipped") | .name' | tr '\n' ',')
                  
                  # ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
                  ERROR_LOGS=$(gh run view $TARGET_RUN_ID --log-failed 2>/dev/null | head -100)
                  
                  if echo "$ERROR_LOGS" | grep -q "YAML syntax error"; then
                    ERROR_TYPE="yaml_syntax"
                  elif echo "$ERROR_LOGS" | grep -q "File not found"; then
                    ERROR_TYPE="file_not_found"
                  elif echo "$ERROR_LOGS" | grep -q "MCP.*error\|mcp.*failed"; then
                    ERROR_TYPE="mcp_service"
                  elif echo "$ERROR_LOGS" | grep -q "Permission denied"; then
                    ERROR_TYPE="permission"
                  elif echo "$ERROR_LOGS" | grep -q "timeout\|Timeout"; then
                    ERROR_TYPE="timeout"
                  elif [ "$RUN_CONCLUSION" == "cancelled" ]; then
                    ERROR_TYPE="cancelled"
                  else
                    ERROR_TYPE="unknown"
                  fi
                  
                  echo "âŒ Workflow failed. Starting error analysis and fix process."
                  break
                fi
              fi
              
              # é€²è¡Œä¸­ã®å ´åˆã¯ç¶™ç¶šç›£è¦–
              if [ "$RUN_STATUS" != "completed" ]; then
                sleep 30
                continue
              fi
            else
              # å…¨ä½“çš„ãªç›£è¦–
              RECENT_FAILURES=$(gh run list --workflow="$TARGET_WORKFLOW" --status=failure --limit=5 --json number,name,conclusion)
              if [ -n "$RECENT_FAILURES" ] && [ "$RECENT_FAILURES" != "[]" ]; then
                ERROR_DETECTED=true
                ERROR_TYPE="recurring_failures"
                break
              fi
              
              # æœ€æ–°ã®å®Ÿè¡ŒçŠ¶æ…‹ã‚’ç¢ºèª
              LATEST_RUN=$(gh run list --workflow="$TARGET_WORKFLOW" --limit=1 --json status,conclusion)
              if [ -n "$LATEST_RUN" ]; then
                LATEST_STATUS=$(echo "$LATEST_RUN" | jq -r '.[0].status')
                LATEST_CONCLUSION=$(echo "$LATEST_RUN" | jq -r '.[0].conclusion')
                
                if [ "$LATEST_STATUS" == "completed" ] && [ "$LATEST_CONCLUSION" == "success" ]; then
                  WORKFLOW_COMPLETED=true
                  echo "âœ… Latest workflow run completed successfully."
                  break
                fi
              fi
            fi
            
            sleep 30
          done
          
          # ç›£è¦–çµæžœã‚’å‡ºåŠ›
          echo "workflow_status=$RUN_STATUS" >> $GITHUB_OUTPUT
          echo "error_detected=$ERROR_DETECTED" >> $GITHUB_OUTPUT
          echo "error_type=$ERROR_TYPE" >> $GITHUB_OUTPUT
          echo "failed_jobs=$FAILED_JOBS" >> $GITHUB_OUTPUT
          echo "workflow_completed=$WORKFLOW_COMPLETED" >> $GITHUB_OUTPUT
          
          # ã‚µãƒžãƒªãƒ¼ä½œæˆ
          SUMMARY="Monitored for $(($(date +%s) - START_TIME)) seconds. "
          if [ "$ERROR_DETECTED" == "true" ]; then
            SUMMARY+="Error detected: $ERROR_TYPE. Failed jobs: $FAILED_JOBS"
          elif [ "$WORKFLOW_COMPLETED" == "true" ]; then
            SUMMARY+="Workflow completed successfully. No errors detected."
          else
            SUMMARY+="Monitoring ended. No errors detected."
          fi
          echo "monitoring_summary=$SUMMARY" >> $GITHUB_OUTPUT

  # ========================================
  # Phase 2: AIé§†å‹•ã®ã‚¨ãƒ©ãƒ¼åˆ†æž
  # ========================================
  ai-error-analysis:
    needs: real-time-monitoring
    if: needs.real-time-monitoring.outputs.error_detected == 'true'
    runs-on: ubuntu-latest
    outputs:
      root_cause: ${{ steps.analyze.outputs.root_cause }}
      fix_strategy: ${{ steps.analyze.outputs.fix_strategy }}
      confidence_level: ${{ steps.analyze.outputs.confidence_level }}
      implementation_plan: ${{ steps.analyze.outputs.implementation_plan }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Install Claude Code SDK
        run: |
          npm init -y
          npm install @anthropic-ai/claude-code
          
      - name: AI-powered error analysis
        id: analyze
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "ðŸ¤– Starting AI error analysis..."
          
          # ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã‚’åŽé›†
          if [ -n "${{ env.TARGET_RUN_ID }}" ]; then
            gh run view ${{ env.TARGET_RUN_ID }} --log-failed > error_logs.txt 2>/dev/null || echo "No error logs available" > error_logs.txt
          fi
          
          # Claude Codeã§ã‚¨ãƒ©ãƒ¼åˆ†æž
          ANALYSIS_PROMPT="You are an expert in GitHub Actions and CI/CD pipelines.
          
          Error Type: ${{ needs.real-time-monitoring.outputs.error_type }}
          Failed Jobs: ${{ needs.real-time-monitoring.outputs.failed_jobs }}
          
          Please analyze the error and provide:
          1. Root cause analysis (one line)
          2. Fix strategy (one line)
          3. Confidence level (low/medium/high)
          4. Implementation steps (structured list)
          
          Error logs are in error_logs.txt
          
          Save your analysis to:
          - analysis/root_cause.txt (one line)
          - analysis/fix_strategy.txt (one line)  
          - analysis/confidence_level.txt (low/medium/high)
          - analysis/implementation_plan.md (detailed steps)"
          
          mkdir -p analysis
          
          npx @anthropic-ai/claude-code \
            -p "$ANALYSIS_PROMPT" \
            --allowedTools "Read,Write" \
            --permission-mode "acceptEdits"
          
          # çµæžœã‚’å‡ºåŠ›
          if [ -f "analysis/root_cause.txt" ]; then
            echo "root_cause=$(cat analysis/root_cause.txt)" >> $GITHUB_OUTPUT
            echo "fix_strategy=$(cat analysis/fix_strategy.txt)" >> $GITHUB_OUTPUT
            echo "confidence_level=$(cat analysis/confidence_level.txt)" >> $GITHUB_OUTPUT
            echo "implementation_plan<<EOF" >> $GITHUB_OUTPUT
            cat analysis/implementation_plan.md >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "root_cause=Analysis failed" >> $GITHUB_OUTPUT
            echo "fix_strategy=Manual intervention required" >> $GITHUB_OUTPUT
            echo "confidence_level=low" >> $GITHUB_OUTPUT
            echo "implementation_plan=Unable to generate automated fix" >> $GITHUB_OUTPUT
          fi

  # ========================================
  # Phase 3: è‡ªå‹•ä¿®æ­£ã®å®Ÿè£…
  # ========================================
  implement-auto-fix:
    needs: [real-time-monitoring, ai-error-analysis]
    if: |
      needs.ai-error-analysis.outputs.confidence_level != 'low' &&
      (github.event.inputs.auto_fix_enabled == 'true' || github.event.inputs.auto_fix_enabled == null)
    runs-on: ubuntu-latest
    outputs:
      fix_applied: ${{ steps.fix.outputs.fix_applied }}
      pr_url: ${{ steps.pr.outputs.pr_url }}
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup fix environment
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
      - name: Create fix branch
        run: |
          FIX_BRANCH="auto-fix/${{ needs.real-time-monitoring.outputs.error_type }}-${{ github.run_number }}"
          git checkout -b "$FIX_BRANCH"
          echo "FIX_BRANCH=$FIX_BRANCH" >> $GITHUB_ENV
          
      - name: Apply automated fixes
        id: fix
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "ðŸ”§ Applying automated fixes..."
          
          # ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ã«åŸºã¥ã„ãŸä¿®æ­£
          case "${{ needs.real-time-monitoring.outputs.error_type }}" in
            yaml_syntax)
              echo "Fixing YAML syntax errors..."
              # YAMLä¿®æ­£ãƒ­ã‚¸ãƒƒã‚¯
              ;;
            file_not_found)
              echo "Fixing file path issues..."
              # ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ä¿®æ­£ãƒ­ã‚¸ãƒƒã‚¯
              ;;
            mcp_service)
              echo "Fixing MCP service issues..."
              # MCPè¨­å®šä¿®æ­£ãƒ­ã‚¸ãƒƒã‚¯
              ;;
            permission)
              echo "Fixing permission issues..."
              # æ¨©é™ä¿®æ­£ãƒ­ã‚¸ãƒƒã‚¯
              ;;
            timeout)
              echo "Fixing timeout issues..."
              # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä¿®æ­£ãƒ­ã‚¸ãƒƒã‚¯
              ;;
            *)
              echo "Applying general fixes..."
              ;;
          esac
          
          # Claude Codeã§å…·ä½“çš„ãªä¿®æ­£ã‚’å®Ÿè£…
          npm init -y
          npm install @anthropic-ai/claude-code
          
          FIX_PROMPT="Based on the analysis:
          
          Root Cause: ${{ needs.ai-error-analysis.outputs.root_cause }}
          Fix Strategy: ${{ needs.ai-error-analysis.outputs.fix_strategy }}
          
          Implementation Plan:
          ${{ needs.ai-error-analysis.outputs.implementation_plan }}
          
          Please implement the fixes according to the plan.
          Focus on the failed jobs: ${{ needs.real-time-monitoring.outputs.failed_jobs }}
          
          Important:
          - Apply HEREDOC Elimination Protocol for YAML errors
          - Use Flexible Path Resolution for file not found errors
          - Update MCP service calls for service errors
          - Fix permission settings for permission errors
          - Increase timeouts for timeout errors"
          
          npx @anthropic-ai/claude-code \
            -p "$FIX_PROMPT" \
            --allowedTools "Read,Write,Edit,MultiEdit,Grep,Glob" \
            --permission-mode "acceptEdits"
          
          # å¤‰æ›´ã‚’ã‚³ãƒŸãƒƒãƒˆ
          if [ -n "$(git status --porcelain)" ]; then
            git add -A
            git commit -m "fix: auto-fix for ${{ needs.real-time-monitoring.outputs.error_type }} error
            
            Root cause: ${{ needs.ai-error-analysis.outputs.root_cause }}
            Strategy: ${{ needs.ai-error-analysis.outputs.fix_strategy }}
            Confidence: ${{ needs.ai-error-analysis.outputs.confidence_level }}
            
            Failed jobs: ${{ needs.real-time-monitoring.outputs.failed_jobs }}"
            
            git push origin "$FIX_BRANCH"
            echo "fix_applied=true" >> $GITHUB_OUTPUT
          else
            echo "fix_applied=false" >> $GITHUB_OUTPUT
          fi
          
      - name: Create pull request
        id: pr
        if: steps.fix.outputs.fix_applied == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_BODY="## ðŸ¤– Automated Fix for ${{ needs.real-time-monitoring.outputs.error_type }} Error
          
          ### ðŸ“Š Error Analysis
          - **Root Cause**: ${{ needs.ai-error-analysis.outputs.root_cause }}
          - **Fix Strategy**: ${{ needs.ai-error-analysis.outputs.fix_strategy }}
          - **Confidence Level**: ${{ needs.ai-error-analysis.outputs.confidence_level }}
          - **Failed Jobs**: ${{ needs.real-time-monitoring.outputs.failed_jobs }}
          
          ### ðŸ”§ Implementation Plan
          ${{ needs.ai-error-analysis.outputs.implementation_plan }}
          
          ### ðŸ“ Monitoring Summary
          ${{ needs.real-time-monitoring.outputs.monitoring_summary }}
          
          ---
          This PR was automatically generated by the Intelligent Error Detection and Auto-Fix System."
          
          PR_URL=$(gh pr create \
            --title "ðŸ”§ Auto-fix: ${{ needs.real-time-monitoring.outputs.error_type }} error in workflow" \
            --body "$PR_BODY" \
            --base main \
            --label "auto-fix,ci-improvement")
            
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT

  # ========================================
  # Phase 4: ä¿®æ­£ã®æ¤œè¨¼ã¨ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
  # ========================================
  verify-fix:
    needs: [implement-auto-fix]
    if: needs.implement-auto-fix.outputs.fix_applied == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout fixed branch
        uses: actions/checkout@v4
        with:
          ref: ${{ env.FIX_BRANCH }}
          
      - name: Run validation tests
        run: |
          echo "ðŸ§ª Validating fixes..."
          
          # YAMLæ¤œè¨¼
          find .github/workflows -name "*.yml" -o -name "*.yaml" | while read file; do
            echo "Validating $file..."
            python3 -c "import yaml; yaml.safe_load(open('$file'))" || exit 1
          done
          
          # ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼æ§‹é€ æ¤œè¨¼
          for workflow in .github/workflows/*.yml; do
            if [ -f "$workflow" ]; then
              echo "Checking workflow structure: $workflow"
              # å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ç¢ºèª
              grep -q "^name:" "$workflow" || echo "Warning: Missing 'name' field in $workflow"
              grep -q "^on:" "$workflow" || echo "Warning: Missing 'on' field in $workflow"
              grep -q "^jobs:" "$workflow" || echo "Warning: Missing 'jobs' field in $workflow"
            fi
          done
          
      - name: Post validation results
        if: always()
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # PR ã«ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¿½åŠ 
          if [ -n "${{ needs.implement-auto-fix.outputs.pr_url }}" ]; then
            gh pr comment "${{ needs.implement-auto-fix.outputs.pr_url }}" \
              --body "### âœ… Validation Results
              
              - YAML Syntax: âœ… Passed
              - Workflow Structure: âœ… Valid
              - File Paths: âœ… Verified
              
              The automated fixes have been validated and appear to be correct."
          fi

  # ========================================
  # Phase 5: è‡ªå‹•å†èµ·å‹•ï¼ˆä¿®æ­£å¾Œï¼‰
  # ========================================
  auto-restart-workflow:
    needs: [real-time-monitoring, ai-error-analysis, implement-auto-fix]
    if: |
      needs.implement-auto-fix.outputs.fix_applied == 'true' &&
      (github.event.inputs.auto_restart_enabled == 'true' || github.event.inputs.auto_restart_enabled == null)
    runs-on: ubuntu-latest
    outputs:
      restarted: ${{ steps.restart.outputs.restarted }}
      new_run_id: ${{ steps.restart.outputs.new_run_id }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Wait for PR merge
        id: wait
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "â³ Waiting for fix to be merged..."
          
          # PRãŒãƒžãƒ¼ã‚¸ã•ã‚Œã‚‹ã¾ã§æœ€å¤§10åˆ†å¾…æ©Ÿ
          PR_URL="${{ needs.implement-auto-fix.outputs.pr_url }}"
          if [ -n "$PR_URL" ]; then
            MAX_WAIT=600  # 10åˆ†
            WAIT_TIME=0
            
            while [ $WAIT_TIME -lt $MAX_WAIT ]; do
              PR_STATE=$(gh pr view "$PR_URL" --json state -q '.state')
              PR_MERGED=$(gh pr view "$PR_URL" --json merged -q '.merged')
              
              if [ "$PR_MERGED" == "true" ]; then
                echo "âœ… PR has been merged"
                break
              elif [ "$PR_STATE" == "CLOSED" ]; then
                echo "âŒ PR was closed without merging"
                exit 0
              fi
              
              echo "Waiting for PR merge... ($WAIT_TIME/$MAX_WAIT seconds)"
              sleep 30
              WAIT_TIME=$((WAIT_TIME + 30))
            done
          fi
          
      - name: Restart failed workflow
        id: restart
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "ðŸ”„ Restarting workflow after fix..."
          
          # å…ƒã®ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’ç‰¹å®š
          if [ -n "${{ env.TARGET_RUN_ID }}" ]; then
            # å…ƒã®ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®æƒ…å ±ã‚’å–å¾—
            ORIGINAL_WORKFLOW=$(gh run view ${{ env.TARGET_RUN_ID }} --json workflowName -q '.workflowName')
            ORIGINAL_INPUTS=$(gh run view ${{ env.TARGET_RUN_ID }} --json event -q '.event.inputs')
            
            # ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’å†å®Ÿè¡Œ
            case "$ORIGINAL_WORKFLOW" in
              "Video Content Creation Production v8")
                NEW_RUN_ID=$(gh workflow run video-content-creation-production-v8.yml \
                  --ref main \
                  --json | jq -r '.id')
                ;;
              "Meta Workflow Executor v8")
                NEW_RUN_ID=$(gh workflow run meta-workflow-executor-v8.yml \
                  --ref main \
                  --json | jq -r '.id')
                ;;
              *)
                echo "Unknown workflow type: $ORIGINAL_WORKFLOW"
                exit 0
                ;;
            esac
            
            if [ -n "$NEW_RUN_ID" ]; then
              echo "restarted=true" >> $GITHUB_OUTPUT
              echo "new_run_id=$NEW_RUN_ID" >> $GITHUB_OUTPUT
              echo "âœ… Workflow restarted with run ID: $NEW_RUN_ID"
            else
              echo "restarted=false" >> $GITHUB_OUTPUT
            fi
          fi

  # ========================================
  # Phase 6: å­¦ç¿’ã¨ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ«ãƒ¼ãƒ—
  # ========================================
  learning-feedback:
    needs: [real-time-monitoring, ai-error-analysis, implement-auto-fix, auto-restart-workflow]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Record fix outcome
        run: |
          echo "ðŸ“š Recording fix outcome for future learning..."
          
          # ä¿®æ­£çµæžœã‚’è¨˜éŒ²
          mkdir -p .github/auto-fix-history
          
          cat > ".github/auto-fix-history/fix-${{ github.run_number }}.json" << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "error_type": "${{ needs.real-time-monitoring.outputs.error_type }}",
            "root_cause": "${{ needs.ai-error-analysis.outputs.root_cause }}",
            "fix_strategy": "${{ needs.ai-error-analysis.outputs.fix_strategy }}",
            "confidence_level": "${{ needs.ai-error-analysis.outputs.confidence_level }}",
            "fix_applied": "${{ needs.implement-auto-fix.outputs.fix_applied }}",
            "pr_url": "${{ needs.implement-auto-fix.outputs.pr_url }}",
            "workflow_restarted": "${{ needs.auto-restart-workflow.outputs.restarted }}",
            "new_run_id": "${{ needs.auto-restart-workflow.outputs.new_run_id }}",
            "workflow_run_id": "${{ github.run_id }}"
          }
          EOF
          
      - name: Update fix patterns database
        run: |
          echo "ðŸ”„ Updating fix patterns..."
          
          # æˆåŠŸã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è¨˜éŒ²ï¼ˆå°†æ¥ã®å‚ç…§ç”¨ï¼‰
          if [ "${{ needs.implement-auto-fix.outputs.fix_applied }}" == "true" ]; then
            echo "Fix pattern recorded for future reference"
          fi
          
      - name: Final summary
        run: |
          echo "ðŸ“Š Final Summary:"
          echo "- Monitoring completed: ${{ needs.real-time-monitoring.outputs.workflow_completed }}"
          echo "- Error detected: ${{ needs.real-time-monitoring.outputs.error_detected }}"
          if [ "${{ needs.real-time-monitoring.outputs.error_detected }}" == "true" ]; then
            echo "- Error type: ${{ needs.real-time-monitoring.outputs.error_type }}"
            echo "- Fix applied: ${{ needs.implement-auto-fix.outputs.fix_applied }}"
            echo "- Workflow restarted: ${{ needs.auto-restart-workflow.outputs.restarted }}"
          fi