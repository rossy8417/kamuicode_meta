name: "Enhanced Earthquake News Video Generation - Hybrid Approach"
run-name: "ğŸš€ åœ°éœ‡ãƒ‹ãƒ¥ãƒ¼ã‚¹å‹•ç”»ç”Ÿæˆ (å¼·åŒ–ç‰ˆ) | ${{ github.actor }} | Run #${{ github.run_number }}"

on:
  workflow_dispatch:
    inputs:
      concept:
        description: 'åœ°éœ‡ãƒ‹ãƒ¥ãƒ¼ã‚¹å‹•ç”»ã®ã‚³ãƒ³ã‚»ãƒ—ãƒˆ'
        type: string
        default: 'æœ€æ–°åœ°éœ‡æƒ…å ±ã®æ—¥æœ¬èªãƒ‹ãƒ¥ãƒ¼ã‚¹å‹•ç”»ï¼ˆ1åˆ†ã€å­—å¹•ä»˜ãï¼‰'
      earthquake_region:
        description: 'åœ°éœ‡ç™ºç”Ÿåœ°åŸŸï¼ˆæ¤œç´¢å¯¾è±¡åœ°åŸŸï¼‰'
        type: string
        default: 'æ—¥æœ¬å…¨å›½'
      quality_mode:
        description: 'Quality vs Speed preference'
        type: choice
        options: ['quality-first', 'balanced', 'speed-first']
        default: 'balanced'
      parallel_scale:
        description: 'Parallel execution scale'
        type: choice
        options: ['conservative', 'moderate', 'aggressive']
        default: 'moderate'
      search_time_range:
        description: 'Earthquake information search time range'
        type: choice
        options: ['past 24 hours', 'past 12 hours', 'past 6 hours', 'past 3 hours']
        default: 'past 24 hours'
      video_duration:
        description: 'Target video duration (seconds)'
        type: string
        default: '60'
      image_model:
        description: 'ç”»åƒç”Ÿæˆãƒ¢ãƒ‡ãƒ«'
        type: choice
        options: ['t2i-google-imagen3', 't2i-fal-imagen4-ultra', 't2i-fal-imagen4-fast', 't2i-fal-flux-schnell']
        default: 't2i-google-imagen3'
      audio_model:
        description: 'éŸ³å£°ç”Ÿæˆãƒ¢ãƒ‡ãƒ«'
        type: choice
        options: ['t2s-fal-minimax-speech-02-turbo', 't2s-google']
        default: 't2s-fal-minimax-speech-02-turbo'

env:
  CLAUDE_CODE_CI_MODE: true
  CLAUDE_CODE_AUTO_APPROVE_MCP: true

jobs:
  # Phase 1: Setup & Strategic Planning (4-way parallel - ENHANCED)
  prepare-search-strategy:
    runs-on: ubuntu-latest
    outputs:
      search_keywords: ${{ steps.strategy.outputs.search_keywords }}
      reliable_sources: ${{ steps.strategy.outputs.reliable_sources }}
      search_plan: ${{ steps.strategy.outputs.search_plan }}
    steps:
      - name: Setup Python environment
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Develop comprehensive earthquake search strategy
        id: strategy
        run: |
          mkdir -p projects/current-session/metadata/search
          
          # Enhanced search strategy with regional specificity
          KEYWORDS="åœ°éœ‡,éœ‡åº¦,éœ‡æºåœ°,è¢«å®³çŠ¶æ³,æ°—è±¡åº,NHK,ç·Šæ€¥åœ°éœ‡é€Ÿå ±,æ´¥æ³¢,${{ inputs.earthquake_region }}"
          SOURCES="æ°—è±¡åº,NHK,æœæ—¥æ–°è,èª­å£²æ–°è,æ¯æ—¥æ–°è,å…±åŒé€šä¿¡,æ™‚äº‹é€šä¿¡,é˜²ç½ç§‘ç ”"
          
          echo "Search Keywords: $KEYWORDS" > projects/current-session/metadata/search/keywords.txt
          echo "Reliable Sources: $SOURCES" > projects/current-session/metadata/search/sources.txt
          
          # Advanced search plan with quality mode consideration
          cat > projects/current-session/metadata/search/plan.json << 'EOF'
          {
            "strategy": "multi_source_comprehensive_enhanced",
            "time_range": "${{ inputs.search_time_range }}",
            "target_region": "${{ inputs.earthquake_region }}",
            "quality_mode": "${{ inputs.quality_mode }}",
            "priority_order": ["official_government", "major_news_agencies", "verified_sources", "scientific_institutions"],
            "verification_method": "cross_reference_multiple_sources_with_confidence_scoring",
            "fallback_strategy": "expand_time_range_if_insufficient_data"
          }
          EOF
          
          echo "search_keywords=$KEYWORDS" >> $GITHUB_OUTPUT
          echo "reliable_sources=$SOURCES" >> $GITHUB_OUTPUT
          echo "search_plan=multi_source_comprehensive_enhanced" >> $GITHUB_OUTPUT

  research-visual-concepts:
    runs-on: ubuntu-latest
    outputs:
      visual_style: ${{ steps.concepts.outputs.visual_style }}
      image_themes: ${{ steps.concepts.outputs.image_themes }}
      animation_plan: ${{ steps.concepts.outputs.animation_plan }}
    steps:
      - name: Research earthquake visualization concepts
        id: concepts
        run: |
          mkdir -p projects/current-session/metadata/visual
          
          # Enhanced visual concept research with animation planning
          cat > projects/current-session/metadata/visual/concepts.json << 'EOF'
          {
            "news_broadcast_style": {
              "color_scheme": "professional blue and red with emergency orange accents",
              "layout": "clean, informative graphics with dynamic elements",
              "typography": "clear, readable fonts with appropriate sizing",
              "accessibility": "high contrast for visibility, subtitle ready"
            },
            "earthquake_visualization": {
              "epicenter_maps": "topographic maps with animated impact zones",
              "seismic_waves": "technical diagram style with motion indicators",
              "damage_assessment": "infographic style, factual and professional",
              "real_time_elements": "live data integration visual elements"
            },
            "animation_concepts": {
              "zoom_effects": "subtle zoom on epicenter location",
              "fade_transitions": "professional fade between visual elements",
              "highlight_animations": "gentle highlight of key information areas"
            },
            "themes": [
              "professional news graphics",
              "earthquake epicenter mapping",
              "seismic impact visualization", 
              "emergency information display",
              "scientific accuracy emphasis"
            ]
          }
          EOF
          
          echo "visual_style=professional_news_broadcast_enhanced" >> $GITHUB_OUTPUT
          echo "image_themes=epicenter_map,seismic_waves,impact_zones,real_time_data" >> $GITHUB_OUTPUT
          echo "animation_plan=zoom_fade_highlight" >> $GITHUB_OUTPUT

  plan-script-structure:
    runs-on: ubuntu-latest
    outputs:
      script_structure: ${{ steps.structure.outputs.script_structure }}
      target_length: ${{ steps.structure.outputs.target_length }}
      pacing_info: ${{ steps.structure.outputs.pacing_info }}
      timing_segments: ${{ steps.structure.outputs.timing_segments }}
    steps:
      - name: Plan optimized Japanese news script structure
        id: structure
        run: |
          mkdir -p projects/current-session/metadata/script
          
          # Enhanced script structure with flexible timing
          DURATION=${{ inputs.video_duration }}
          cat > projects/current-session/metadata/script/structure.json << EOF
          {
            "total_duration": "$DURATION",
            "quality_mode": "${{ inputs.quality_mode }}",
            "structure": {
              "introduction": {
                "duration": "$(( DURATION * 25 / 100 )) seconds",
                "content": "åœ°éœ‡ç™ºç”Ÿã®åŸºæœ¬æƒ…å ±ï¼ˆæ™‚åˆ»ã€å ´æ‰€ã€éœ‡åº¦ï¼‰",
                "character_count": "ç´„$(( DURATION * 4 ))æ–‡å­—",
                "priority": "critical"
              },
              "main_content": {
                "duration": "$(( DURATION * 60 / 100 )) seconds", 
                "content": "è©³ç´°æƒ…å ±ã€å½±éŸ¿ç¯„å›²ã€ç¾åœ¨ã®çŠ¶æ³ã€å¯¾å¿œçŠ¶æ³",
                "character_count": "ç´„$(( DURATION * 9 ))æ–‡å­—",
                "priority": "essential"
              },
              "conclusion": {
                "duration": "$(( DURATION * 15 / 100 )) seconds",
                "content": "æ³¨æ„å–šèµ·ã€ä»Šå¾Œã®æƒ…å ±æ¡ˆå†…ã€å®‰å…¨å¯¾ç­–",
                "character_count": "ç´„$(( DURATION * 2 ))æ–‡å­—",
                "priority": "important"
              }
            },
            "target_characters": $(( DURATION * 5 )),
            "speaking_rate": "ç´„5æ–‡å­—/ç§’ï¼ˆæ¨™æº–ï¼‰",
            "style": "news_announcer_formal_enhanced",
            "accessibility_features": ["clear_pronunciation", "appropriate_pacing", "emergency_tone"]
          }
          EOF
          
          echo "script_structure=intro_main_conclusion_enhanced" >> $GITHUB_OUTPUT
          echo "target_length=$(( DURATION * 5 ))" >> $GITHUB_OUTPUT
          echo "pacing_info=5_chars_per_second_adaptive" >> $GITHUB_OUTPUT
          echo "timing_segments=25_60_15_percent" >> $GITHUB_OUTPUT

  setup-quality-framework:
    runs-on: ubuntu-latest
    outputs:
      quality_thresholds: ${{ steps.framework.outputs.quality_thresholds }}
      validation_criteria: ${{ steps.framework.outputs.validation_criteria }}
    steps:
      - name: Setup enhanced quality assurance framework  
        id: framework
        run: |
          mkdir -p projects/current-session/metadata/quality
          
          # Enhanced quality framework based on quality mode
          cat > projects/current-session/metadata/quality/framework.json << 'EOF'
          {
            "thresholds": {
              "quality-first": {
                "overall_score": 90,
                "duration_tolerance": "Â±5 seconds",
                "resolution_requirement": "1920x1080 mandatory",
                "audio_quality": "high",
                "subtitle_accuracy": "99%"
              },
              "balanced": {
                "overall_score": 80,
                "duration_tolerance": "Â±10 seconds", 
                "resolution_requirement": "1920x1080 preferred",
                "audio_quality": "medium-high",
                "subtitle_accuracy": "95%"
              },
              "speed-first": {
                "overall_score": 70,
                "duration_tolerance": "Â±15 seconds",
                "resolution_requirement": "1920x1080 minimum",
                "audio_quality": "medium",
                "subtitle_accuracy": "90%"
              }
            },
            "validation_criteria": [
              "earthquake_data_accuracy",
              "video_duration_compliance",
              "resolution_compliance", 
              "audio_clarity",
              "subtitle_synchronization",
              "visual_consistency",
              "content_appropriateness",
              "accessibility_compliance"
            ],
            "error_recovery": {
              "retry_attempts": 3,
              "fallback_strategies": ["alternative_sources", "simplified_content", "extended_timeframe"],
              "quality_degradation_acceptable": true
            }
          }
          EOF
          
          CURRENT_MODE="${{ inputs.quality_mode }}"
          THRESHOLDS=$(jq -r ".thresholds.\"$CURRENT_MODE\"" projects/current-session/metadata/quality/framework.json)
          CRITERIA=$(jq -r '.validation_criteria | join(",")' projects/current-session/metadata/quality/framework.json)
          
          echo "quality_thresholds=$THRESHOLDS" >> $GITHUB_OUTPUT
          echo "validation_criteria=$CRITERIA" >> $GITHUB_OUTPUT

  # Phase 2: Information Gathering (2-way parallel with enhanced validation)
  collect-earthquake-information:
    runs-on: ubuntu-latest
    needs: [prepare-search-strategy]
    outputs:
      search_results: ${{ steps.search.outputs.search_results }}
      sources_found: ${{ steps.search.outputs.sources_found }}
      confidence_score: ${{ steps.search.outputs.confidence_score }}
    steps:
      - name: Enhanced earthquake information collection
        id: search
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          mkdir -p projects/current-session/temp/search
          
          # Enhanced search with regional focus and confidence scoring
          SEARCH_QUERY="æœ€æ–°ã®åœ°éœ‡æƒ…å ± éœ‡åº¦ éœ‡æºåœ° è¢«å®³çŠ¶æ³ ${{ inputs.search_time_range }} ${{ inputs.earthquake_region }}"
          
          # Primary search with Gemini + Search Grounding
          RESPONSE=$(curl -s -X POST \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent" \
            -H "x-goog-api-key: ${GEMINI_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "{
              \"contents\": [{
                \"parts\": [{
                  \"text\": \"${{ inputs.earthquake_region }}ã§ã®æœ€æ–°ã®åœ°éœ‡æƒ…å ±ã‚’æ¤œç´¢ã—ã¦ãã ã•ã„ã€‚${{ inputs.search_time_range }}ä»¥å†…ã«ç™ºç”Ÿã—ãŸåœ°éœ‡ã«ã¤ã„ã¦ã€éœ‡åº¦ã€éœ‡æºåœ°ã€è¢«å®³çŠ¶æ³ã€æ°—è±¡åºã®ç™ºè¡¨å†…å®¹ã‚’èª¿ã¹ã¦ãã ã•ã„ã€‚ä¿¡é ¼ã§ãã‚‹æƒ…å ±æºï¼ˆæ°—è±¡åºã€NHKã€å ±é“æ©Ÿé–¢ã€é˜²ç½ç§‘ç ”ï¼‰ã‹ã‚‰ã®æƒ…å ±ã‚’å„ªå…ˆã—ã€æƒ…å ±ã®ä¿¡é ¼åº¦ã‚‚è©•ä¾¡ã—ã¦ãã ã•ã„ã€‚\"
                }]
              }],
              \"tools\": [{\"google_search\": {}}]
            }")
          
          echo "$RESPONSE" > projects/current-session/temp/search/gemini-response.json
          
          # Enhanced content extraction with confidence scoring
          CONTENT=$(echo "$RESPONSE" | jq -r '.candidates[0].content.parts[0].text // "æ¤œç´¢çµæœãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ"')
          URLS=$(echo "$RESPONSE" | jq -r '.candidates[0].groundingMetadata.groundingChunks[]?.web.uri // empty' | head -8 | tr '\n' ', ')
          
          # Confidence scoring based on content analysis (safe one-liner approach)
          CONFIDENCE=$(python3 -c "import re; content='$CONTENT'; confidence=0; confidence+=30 if any(source in content for source in ['æ°—è±¡åº', 'NHK', 'é˜²ç½ç§‘ç ”']) else 0; confidence+=25 if re.search(r'éœ‡åº¦[1-7]', content) else 0; confidence+=20 if re.search(r'ãƒã‚°ãƒ‹ãƒãƒ¥ãƒ¼ãƒ‰', content) else 0; confidence+=15 if re.search(r'åˆå‰|åˆå¾Œ', content) else 0; confidence+=10 if re.search(r'éœ‡æºåœ°', content) else 0; print(min(confidence, 100))" 2>/dev/null || echo "50")
          
          echo "$CONTENT" > projects/current-session/temp/search/earthquake-info.txt
          echo "$URLS" > projects/current-session/temp/search/sources.txt
          echo "$CONFIDENCE" > projects/current-session/temp/search/confidence.txt
          
          echo "search_results=$CONTENT" >> $GITHUB_OUTPUT
          echo "sources_found=$URLS" >> $GITHUB_OUTPUT
          echo "confidence_score=$CONFIDENCE" >> $GITHUB_OUTPUT

  verify-information-reliability:
    runs-on: ubuntu-latest
    needs: [prepare-search-strategy, collect-earthquake-information, setup-quality-framework]
    outputs:
      verified_info: ${{ steps.verify.outputs.verified_info }}
      reliability_score: ${{ steps.verify.outputs.reliability_score }}
      verification_status: ${{ steps.verify.outputs.verification_status }}
    steps:
      - name: Enhanced multi-layer information verification
        id: verify
        run: |
          mkdir -p projects/current-session/temp/analysis
          
          # Enhanced verification with multiple validation layers
          python3 -c "
import json
import re
from datetime import datetime

search_results = '''${{ needs.collect-earthquake-information.outputs.search_results }}'''
sources = '''${{ needs.collect-earthquake-information.outputs.sources_found }}'''
confidence = int('${{ needs.collect-earthquake-information.outputs.confidence_score }}' or '0')
quality_mode = '${{ inputs.quality_mode }}'

# Multi-layer verification system
verification_layers = {
    'source_credibility': 0,
    'data_completeness': 0, 
    'temporal_relevance': 0,
    'geographic_accuracy': 0,
    'technical_precision': 0
}

# Layer 1: Source credibility analysis
official_sources = ['æ°—è±¡åº', 'NHK', 'å…±åŒé€šä¿¡', 'æ™‚äº‹é€šä¿¡', 'æœæ—¥æ–°è', 'èª­å£²æ–°è', 'é˜²ç½ç§‘ç ”']
credible_count = sum(1 for source in official_sources if source in search_results)
verification_layers['source_credibility'] = min(credible_count * 15, 100)

# Layer 2: Data completeness
required_elements = [
    (r'éœ‡åº¦[1-7]', 'seismic_intensity'),
    (r'ãƒã‚°ãƒ‹ãƒãƒ¥ãƒ¼ãƒ‰\d+\.?\d*', 'magnitude'),
    (r'åˆå‰|åˆå¾Œ|\d{1,2}æ™‚\d{1,2}åˆ†', 'time_info'),
    (r'éœ‡æºåœ°.*[éƒ½é“åºœçœŒ]', 'epicenter_location'),
    (r'æ·±ã•.*km', 'depth_info')
]
completeness_score = sum(20 for pattern, _ in required_elements if re.search(pattern, search_results))
verification_layers['data_completeness'] = min(completeness_score, 100)

# Layer 3: Temporal relevance
timeframe_mapping = {
    'past 3 hours': 100,
    'past 6 hours': 90, 
    'past 12 hours': 80,
    'past 24 hours': 70
}
verification_layers['temporal_relevance'] = timeframe_mapping.get('${{ inputs.search_time_range }}', 60)

# Layer 4: Geographic accuracy
target_region = '${{ inputs.earthquake_region }}'
if target_region != 'æ—¥æœ¬å…¨å›½' and target_region in search_results:
    verification_layers['geographic_accuracy'] = 100
elif 'æ—¥æœ¬' in search_results:
    verification_layers['geographic_accuracy'] = 80
else:
    verification_layers['geographic_accuracy'] = 40

# Layer 5: Technical precision
precision_indicators = ['éœ‡æºã®æ·±ã•', 'æœ€å¤§éœ‡åº¦', 'å„åœ°ã®éœ‡åº¦', 'æ´¥æ³¢ã®å¿ƒé…', 'ä»Šå¾Œã®ä½™éœ‡']
precision_score = sum(20 for indicator in precision_indicators if indicator in search_results)
verification_layers['technical_precision'] = min(precision_score, 100)

# Calculate overall reliability score
weights = {
    'source_credibility': 0.25,
    'data_completeness': 0.25,
    'temporal_relevance': 0.15,
    'geographic_accuracy': 0.20,
    'technical_precision': 0.15
}

reliability_score = sum(verification_layers[layer] * weights[layer] for layer in verification_layers)
reliability_score = int(reliability_score)

# Quality mode adjustment
quality_thresholds = {
    'quality-first': 85,
    'balanced': 75,
    'speed-first': 65
}
threshold = quality_thresholds[quality_mode]

verification_result = {
    'reliability_score': reliability_score,
    'confidence_score': confidence, 
    'verification_layers': verification_layers,
    'quality_threshold': threshold,
    'verification_status': 'verified' if reliability_score >= threshold else 'needs_confirmation',
    'recommendations': [],
    'fallback_required': reliability_score < (threshold - 10)
}

# Generate recommendations
if verification_layers['source_credibility'] < 60:
    verification_result['recommendations'].append('Seek additional official sources')
if verification_layers['data_completeness'] < 60:
    verification_result['recommendations'].append('Request more detailed earthquake data')
if verification_layers['geographic_accuracy'] < 60:
    verification_result['recommendations'].append('Verify regional specificity')

with open('projects/current-session/temp/analysis/enhanced-verification.json', 'w', encoding='utf-8') as f:
    json.dump(verification_result, f, ensure_ascii=False, indent=2)

print(f'Enhanced Reliability Score: {reliability_score}')
print(f'Verification Status: {verification_result[\"verification_status\"]}')
"
          
          VERIFIED_INFO=$(cat projects/current-session/temp/analysis/enhanced-verification.json)
          SCORE=$(echo "$VERIFIED_INFO" | jq -r '.reliability_score')
          STATUS=$(echo "$VERIFIED_INFO" | jq -r '.verification_status')
          
          echo "verified_info=$VERIFIED_INFO" >> $GITHUB_OUTPUT
          echo "reliability_score=$SCORE" >> $GITHUB_OUTPUT
          echo "verification_status=$STATUS" >> $GITHUB_OUTPUT

  # Phase 3: Information Analysis (2-way parallel with enhanced processing)
  prioritize-information:
    runs-on: ubuntu-latest
    needs: [collect-earthquake-information, verify-information-reliability]
    outputs:
      priority_info: ${{ steps.prioritize.outputs.priority_info }}
      key_points: ${{ steps.prioritize.outputs.key_points }}
      urgency_level: ${{ steps.prioritize.outputs.urgency_level }}
    steps:
      - name: Enhanced information prioritization with urgency assessment
        id: prioritize
        run: |
          mkdir -p projects/current-session/temp/processing
          
          # Enhanced prioritization with urgency levels
          python3 -c "
import json
import re

search_results = '''${{ needs.collect-earthquake-information.outputs.search_results }}'''
reliability_score = int('${{ needs.verify-information-reliability.outputs.reliability_score }}')

# Enhanced priority classification system
priority_structure = {
    'critical': {'items': [], 'urgency_weight': 1.0},
    'important': {'items': [], 'urgency_weight': 0.7},
    'supplementary': {'items': [], 'urgency_weight': 0.4},
    'background': {'items': [], 'urgency_weight': 0.2}
}

# Urgency assessment keywords
urgency_indicators = {
    'immediate': ['å¤§åœ°éœ‡', 'ç·Šæ€¥åœ°éœ‡é€Ÿå ±', 'æ´¥æ³¢è­¦å ±', 'é¿é›£'],
    'high': ['éœ‡åº¦5', 'éœ‡åº¦6', 'éœ‡åº¦7', 'è¢«å®³', 'åœé›»', 'äº¤é€š'],  
    'medium': ['éœ‡åº¦3', 'éœ‡åº¦4', 'æ³¨æ„', 'è­¦æˆ’'],
    'low': ['éœ‡åº¦1', 'éœ‡åº¦2', 'å½±éŸ¿ãªã—']
}

# Process information by lines
lines = search_results.split('\n')
urgency_scores = []

for line in lines:
    line = line.strip()
    if not line:
        continue
        
    # Calculate urgency score for this line
    urgency_score = 0
    for level, keywords in urgency_indicators.items():
        if any(keyword in line for keyword in keywords):
            level_scores = {'immediate': 4, 'high': 3, 'medium': 2, 'low': 1}
            urgency_score = max(urgency_score, level_scores[level])
    
    # Classify based on content and urgency
    if any(word in line for word in ['éœ‡åº¦', 'ãƒã‚°ãƒ‹ãƒãƒ¥ãƒ¼ãƒ‰', 'éœ‡æºåœ°', 'ç™ºç”Ÿæ™‚åˆ»']):
        if urgency_score >= 3:
            priority_structure['critical']['items'].append(line)
        else:
            priority_structure['important']['items'].append(line)
    elif any(word in line for word in ['è¢«å®³', 'æ´¥æ³¢', 'æ³¨æ„', 'è­¦å ±', 'é¿é›£']):
        if urgency_score >= 2:
            priority_structure['important']['items'].append(line)
        else:
            priority_structure['supplementary']['items'].append(line)  
    elif any(word in line for word in ['å½±éŸ¿', 'äº¤é€š', 'åœé›»', 'ä»Šå¾Œ', 'ä½™éœ‡']):
        priority_structure['supplementary']['items'].append(line)
    else:
        priority_structure['background']['items'].append(line)
    
    if urgency_score > 0:
        urgency_scores.append(urgency_score)

# Calculate overall urgency level
avg_urgency = sum(urgency_scores) / len(urgency_scores) if urgency_scores else 1
urgency_levels = {4: 'immediate', 3: 'high', 2: 'medium', 1: 'low'}
overall_urgency = urgency_levels.get(round(avg_urgency), 'low')

# Generate key points with priority ranking
key_points = []
for category in ['critical', 'important', 'supplementary']:
    items = priority_structure[category]['items']
    if items:
        key_points.extend(items[:3])  # Top 3 from each category

# Limit key points based on reliability
max_points = min(len(key_points), 8 if reliability_score >= 80 else 5)
key_points = key_points[:max_points]

with open('projects/current-session/temp/processing/enhanced-priority-info.json', 'w', encoding='utf-8') as f:
    json.dump(priority_structure, f, ensure_ascii=False, indent=2)

with open('projects/current-session/temp/processing/key-points.json', 'w', encoding='utf-8') as f:
    json.dump({
        'points': key_points,
        'urgency_level': overall_urgency,
        'reliability_score': reliability_score,
        'total_points': len(key_points)
    }, f, ensure_ascii=False, indent=2)

print(f'Enhanced prioritization completed - Urgency: {overall_urgency}')
"
          
          PRIORITY_INFO=$(cat projects/current-session/temp/processing/enhanced-priority-info.json)
          KEY_POINTS_DATA=$(cat projects/current-session/temp/processing/key-points.json)
          KEY_POINTS=$(echo "$KEY_POINTS_DATA" | jq -r '.points')
          URGENCY=$(echo "$KEY_POINTS_DATA" | jq -r '.urgency_level')
          
          echo "priority_info=$PRIORITY_INFO" >> $GITHUB_OUTPUT
          echo "key_points=$KEY_POINTS" >> $GITHUB_OUTPUT
          echo "urgency_level=$URGENCY" >> $GITHUB_OUTPUT

  structure-news-data:
    runs-on: ubuntu-latest
    needs: [prioritize-information, plan-script-structure]
    outputs:
      structured_data: ${{ steps.structure.outputs.structured_data }}
      content_plan: ${{ steps.structure.outputs.content_plan }}
    steps:
      - name: Enhanced news data structuring with adaptive content planning
        id: structure
        run: |
          mkdir -p projects/current-session/temp/structured
          
          # Enhanced structuring with adaptive content planning
          python3 -c "
import json

priority_info = json.loads('''${{ needs.prioritize-information.outputs.priority_info }}''')
target_length = '${{ needs.plan-script-structure.outputs.target_length }}'
timing_segments = '${{ needs.plan-script-structure.outputs.timing_segments }}'
urgency_level = '${{ needs.prioritize-information.outputs.urgency_level }}'

# Parse timing segments (25_60_15_percent)
intro_pct, main_pct, conclusion_pct = map(int, timing_segments.split('_')[:3])
total_chars = int(target_length)

# Adaptive content allocation based on urgency
urgency_adjustments = {
    'immediate': {'intro': 1.2, 'main': 1.1, 'conclusion': 1.3},  # More emphasis on all parts
    'high': {'intro': 1.1, 'main': 1.0, 'conclusion': 1.2},     # Emphasis on intro and conclusion
    'medium': {'intro': 1.0, 'main': 1.0, 'conclusion': 1.0},   # Standard allocation
    'low': {'intro': 0.9, 'main': 1.1, 'conclusion': 0.8}      # More detail in main content
}

adjustments = urgency_adjustments.get(urgency_level, urgency_adjustments['medium'])

# Calculate adaptive character allocations
intro_chars = int((total_chars * intro_pct / 100) * adjustments['intro'])
main_chars = int((total_chars * main_pct / 100) * adjustments['main'])  
conclusion_chars = int((total_chars * conclusion_pct / 100) * adjustments['conclusion'])

# Enhanced news structure with content planning
news_structure = {
    'metadata': {
        'urgency_level': urgency_level,
        'total_target_chars': total_chars,
        'allocation_strategy': 'adaptive_urgency_based'
    },
    'introduction': {
        'target_chars': intro_chars,
        'content_type': 'critical_facts_with_urgency',
        'data': priority_info.get('critical', {}).get('items', [])[:2],
        'tone': 'immediate' if urgency_level in ['immediate', 'high'] else 'professional',
        'required_elements': ['time', 'location', 'magnitude', 'intensity']
    },
    'main_content': {
        'target_chars': main_chars,
        'content_type': 'detailed_analysis_and_impact',
        'data': (priority_info.get('critical', {}).get('items', [])[2:] + 
                priority_info.get('important', {}).get('items', [])[:4]),
        'tone': 'informative_detailed',
        'required_elements': ['impact_assessment', 'current_situation', 'response_actions']
    },
    'conclusion': {
        'target_chars': conclusion_chars,
        'content_type': 'safety_guidance_and_updates',
        'data': (priority_info.get('supplementary', {}).get('items', [])[:2] +
                priority_info.get('background', {}).get('items', [])[:1]),
        'tone': 'advisory_reassuring',
        'required_elements': ['safety_advice', 'information_updates', 'contact_info']
    }
}

# Content planning strategy
content_plan = {
    'narrative_flow': 'crisis_informed_professional',
    'key_transitions': ['immediate_facts', 'detailed_analysis', 'future_guidance'],
    'emphasis_points': ['safety_first', 'accurate_information', 'calm_response'],
    'accessibility_features': ['clear_language', 'important_repetition', 'structured_delivery']
}

with open('projects/current-session/temp/structured/enhanced-news-data.json', 'w', encoding='utf-8') as f:
    json.dump(news_structure, f, ensure_ascii=False, indent=2)

with open('projects/current-session/temp/structured/content-plan.json', 'w', encoding='utf-8') as f:
    json.dump(content_plan, f, ensure_ascii=False, indent=2)

print('Enhanced news data structuring completed')
"
          
          STRUCTURED_DATA=$(cat projects/current-session/temp/structured/enhanced-news-data.json)
          CONTENT_PLAN=$(cat projects/current-session/temp/structured/content-plan.json)
          
          echo "structured_data=$STRUCTURED_DATA" >> $GITHUB_OUTPUT
          echo "content_plan=$CONTENT_PLAN" >> $GITHUB_OUTPUT

  # Phase 4: Content Generation (4-way parallel - ENHANCED)
  generate-news-script:
    runs-on: ubuntu-latest
    needs: [structure-news-data, plan-script-structure]
    outputs:
      news_script: ${{ steps.generate.outputs.news_script }}
      script_path: ${{ steps.generate.outputs.script_path }}
      script_metadata: ${{ steps.generate.outputs.script_metadata }}
    steps:
      - name: Generate enhanced Japanese earthquake news script
        id: generate
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          mkdir -p projects/current-session/final
          
          # Enhanced script generation with metadata
          STRUCTURED_DATA='${{ needs.structure-news-data.outputs.structured_data }}'
          CONTENT_PLAN='${{ needs.structure-news-data.outputs.content_plan }}'
          
          RESPONSE=$(curl -s -X POST \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent" \
            -H "x-goog-api-key: ${GEMINI_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "{
              \"contents\": [{
                \"parts\": [{
                  \"text\": \"ä»¥ä¸‹ã®åœ°éœ‡æƒ…å ±ã¨æ§‹æˆè¨ˆç”»ã‚’åŸºã«ã€${{ inputs.video_duration }}ç§’ã®é«˜å“è³ªãƒ‹ãƒ¥ãƒ¼ã‚¹åŸç¨¿ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚å“è³ªãƒ¢ãƒ¼ãƒ‰: ${{ inputs.quality_mode }}ã€‚ãƒ‹ãƒ¥ãƒ¼ã‚¹ã‚¢ãƒŠã‚¦ãƒ³ã‚µãƒ¼ãŒèª­ã¿ä¸Šã’ã‚‹å½¢å¼ã§ã€ç·Šæ€¥åº¦ã¨æ­£ç¢ºæ€§ã‚’é‡è¦–ã—ã¦ãã ã•ã„ã€‚\\n\\næ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿: ${STRUCTURED_DATA}\\n\\nã‚³ãƒ³ãƒ†ãƒ³ãƒ„è¨ˆç”»: ${CONTENT_PLAN}\"
                }]
              }]
            }")
          
          SCRIPT_CONTENT=$(echo "$RESPONSE" | jq -r '.candidates[0].content.parts[0].text // "åŸç¨¿ç”Ÿæˆã‚¨ãƒ©ãƒ¼"')
          
          # Generate script metadata
          python3 -c "
import json
from datetime import datetime

script_content = '''$SCRIPT_CONTENT'''
char_count = len(script_content)
estimated_duration = char_count / 5  # 5 chars per second

metadata = {
    'generation_timestamp': datetime.now().isoformat(),
    'character_count': char_count,
    'estimated_duration_seconds': round(estimated_duration, 1),
    'target_duration': ${{ inputs.video_duration }},
    'quality_mode': '${{ inputs.quality_mode }}',
    'urgency_level': '${{ needs.prioritize-information.outputs.urgency_level }}',
    'duration_accuracy': abs(estimated_duration - ${{ inputs.video_duration }}) <= 10,
    'content_structure': {
        'has_introduction': 'åœ°éœ‡' in script_content[:100],
        'has_details': len(script_content) > 200,
        'has_conclusion': any(word in script_content[-100:] for word in ['æ³¨æ„', 'ä»Šå¾Œ', 'æƒ…å ±'])
    }
}

with open('projects/current-session/final/script-metadata.json', 'w', encoding='utf-8') as f:
    json.dump(metadata, f, ensure_ascii=False, indent=2)

print('Script metadata generated')
"
          
          echo "$SCRIPT_CONTENT" > projects/current-session/final/enhanced-news-script.txt
          METADATA=$(cat projects/current-session/final/script-metadata.json)
          
          echo "news_script=$SCRIPT_CONTENT" >> $GITHUB_OUTPUT
          echo "script_path=projects/current-session/final/enhanced-news-script.txt" >> $GITHUB_OUTPUT
          echo "script_metadata=$METADATA" >> $GITHUB_OUTPUT

  generate-epicenter-map:
    runs-on: ubuntu-latest
    needs: [structure-news-data, research-visual-concepts]
    outputs:
      map_image_path: ${{ steps.generate.outputs.map_image_path }}
      image_metadata: ${{ steps.generate.outputs.image_metadata }}
    steps:
      - name: Generate enhanced earthquake epicenter map
        id: generate
        run: |
          mkdir -p projects/current-session/temp/images
          
          # Enhanced epicenter map with animation-ready elements
          STRUCTURED_DATA='${{ needs.structure-news-data.outputs.structured_data }}'
          URGENCY_LEVEL='${{ needs.prioritize-information.outputs.urgency_level }}'
          
          # Enhanced image generation with urgency-based styling
          python3 -c "
from PIL import Image, ImageDraw, ImageFont
import json
import math

# Enhanced epicenter map generation
width, height = 1920, 1080
urgency = '$URGENCY_LEVEL'

# Urgency-based color schemes
color_schemes = {
    'immediate': {'bg': '#1a0f0f', 'primary': '#ff0000', 'secondary': '#ff4444', 'text': '#ffffff'},  
    'high': {'bg': '#1e1a0f', 'primary': '#ff6600', 'secondary': '#ff8833', 'text': '#ffffff'},
    'medium': {'bg': '#1e3a5f', 'primary': '#ff9900', 'secondary': '#ffaa33', 'text': '#ffffff'},
    'low': {'bg': '#1e3a5f', 'primary': '#3366cc', 'secondary': '#4477dd', 'text': '#ffffff'}
}

colors = color_schemes.get(urgency, color_schemes['medium'])
img = Image.new('RGB', (width, height), color=colors['bg'])
draw = ImageDraw.Draw(img)

# Enhanced Japan map representation with topographic elements
draw.rectangle([300, 150, 1620, 850], fill=colors['bg'], outline=colors['secondary'], width=4)

# Multi-layer epicenter visualization
center_x, center_y = 960, 500

# Impact zones (multiple concentric circles for better visualization)
impact_radii = [40, 80, 120, 160]
impact_colors = [colors['primary'], colors['secondary'], colors['secondary'], colors['secondary']]
impact_alphas = [255, 180, 120, 80]

for i, (radius, color) in enumerate(zip(impact_radii, impact_colors)):
    # Create gradient effect for impact zones
    for r in range(0, radius, 5):
        alpha = max(impact_alphas[i] - (r * 2), 20)
        draw.ellipse([center_x-r, center_y-r, center_x+r, center_y+r], 
                    outline=color, width=2)

# Central epicenter marker
draw.ellipse([center_x-25, center_y-25, center_x+25, center_y+25], 
            fill=colors['primary'], outline='darkred', width=4)

# Enhanced typography with better fonts
try:
    font_title = ImageFont.truetype('/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf', 56)
    font_subtitle = ImageFont.truetype('/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf', 36)
    font_info = ImageFont.truetype('/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf', 28)
except:
    font_title = ImageFont.load_default()
    font_subtitle = ImageFont.load_default()
    font_info = ImageFont.load_default()

# Enhanced title with urgency indication
urgency_indicators = {
    'immediate': 'ğŸš¨ ç·Šæ€¥åœ°éœ‡æƒ…å ±',
    'high': 'âš ï¸ åœ°éœ‡æƒ…å ±', 
    'medium': 'ğŸ“ åœ°éœ‡æƒ…å ±',
    'low': 'ğŸ“Š åœ°éœ‡æƒ…å ±'
}
title = urgency_indicators.get(urgency, 'ğŸ“ åœ°éœ‡æƒ…å ±')

draw.text((50, 40), title, fill=colors['text'], font=font_title)
draw.text((50, 110), 'Earthquake Information - Epicenter Map', fill='#cccccc', font=font_subtitle)

# Enhanced legend with more information
legend_x, legend_y = 50, height-300
draw.rectangle([legend_x-10, legend_y-10, legend_x+400, legend_y+250], 
              fill='#2a2a2a', outline=colors['text'], width=2)

draw.text((legend_x+10, legend_y+10), 'éœ‡æºåœ°ãƒ»å½±éŸ¿ç¯„å›²', fill=colors['text'], font=font_subtitle)
draw.text((legend_x+10, legend_y+60), 'éœ‡æºåœ° / Epicenter', fill=colors['primary'], font=font_info)
draw.ellipse([legend_x+200, legend_y+60, legend_x+220, legend_y+80], fill=colors['primary'])

draw.text((legend_x+10, legend_y+100), 'å¼·éœ‡å‹•ç¯„å›² / Strong Motion Zone', fill=colors['secondary'], font=font_info)
draw.ellipse([legend_x+200, legend_y+100, legend_x+240, legend_y+120], 
            outline=colors['secondary'], width=3)

draw.text((legend_x+10, legend_y+140), 'å½±éŸ¿ç¯„å›² / Impact Zone', fill=colors['secondary'], font=font_info)
draw.ellipse([legend_x+200, legend_y+140, legend_x+260, legend_y+160], 
            outline=colors['secondary'], width=2)

# Compass and scale indicators
draw.text((width-200, 100), 'N â†‘', fill=colors['text'], font=font_subtitle)
draw.text((width-200, height-100), '200km', fill=colors['text'], font=font_info)

img.save('projects/current-session/temp/images/enhanced-epicenter-map.png')

# Generate image metadata
metadata = {
    'type': 'epicenter_map',
    'urgency_level': urgency,
    'color_scheme': colors,
    'resolution': f'{width}x{height}',
    'features': ['impact_zones', 'legend', 'compass', 'scale'],
    'animation_ready': True
}

with open('projects/current-session/temp/images/epicenter-metadata.json', 'w') as f:
    json.dump(metadata, f, indent=2)

print('Enhanced epicenter map generated')
"
          
          METADATA=$(cat projects/current-session/temp/images/epicenter-metadata.json)
          
          echo "map_image_path=projects/current-session/temp/images/enhanced-epicenter-map.png" >> $GITHUB_OUTPUT
          echo "image_metadata=$METADATA" >> $GITHUB_OUTPUT

  generate-impact-visualization:
    runs-on: ubuntu-latest
    needs: [research-visual-concepts, prioritize-information]
    outputs:
      impact_image_path: ${{ steps.generate.outputs.impact_image_path }}
      visualization_metadata: ${{ steps.generate.outputs.visualization_metadata }}
    steps:
      - name: Generate enhanced earthquake impact visualization
        id: generate
        run: |
          mkdir -p projects/current-session/temp/images
          
          # Enhanced impact visualization with dynamic elements
          python3 -c "
from PIL import Image, ImageDraw, ImageFont
import math
import json

width, height = 1920, 1080
urgency = '${{ needs.prioritize-information.outputs.urgency_level }}'

# Enhanced color schemes based on urgency
color_schemes = {
    'immediate': {'bg': '#0f0505', 'wave': '#ff3333', 'center': '#ff0000', 'text': '#ffffff'},
    'high': {'bg': '#1a0a05', 'wave': '#ff6635', 'center': '#ff4400', 'text': '#ffffff'},  
    'medium': {'bg': '#0f1419', 'wave': '#ff6b35', 'center': '#ff5522', 'text': '#ffffff'},
    'low': {'bg': '#0f1419', 'wave': '#3388cc', 'center': '#2266aa', 'text': '#ffffff'}
}

colors = color_schemes.get(urgency, color_schemes['medium'])
img = Image.new('RGB', (width, height), color=colors['bg'])
draw = ImageDraw.Draw(img)

center_x, center_y = 960, 540

# Enhanced seismic wave visualization with multiple patterns
wave_patterns = [
    {'radius_mult': 1.0, 'density': 2, 'opacity': 255},
    {'radius_mult': 0.7, 'density': 3, 'opacity': 180}, 
    {'radius_mult': 0.4, 'density': 4, 'opacity': 120}
]

for pattern in wave_patterns:
    for i in range(1, 12):
        radius = int(i * 70 * pattern['radius_mult'])
        alpha = max(pattern['opacity'] - i * 15, 30)
        
        # Create wave rings with varying density
        for angle in range(0, 360, pattern['density']):
            x1 = center_x + radius * math.cos(math.radians(angle))
            y1 = center_y + radius * math.sin(math.radians(angle))
            x2 = center_x + (radius+12) * math.cos(math.radians(angle))
            y2 = center_y + (radius+12) * math.sin(math.radians(angle))
            
            if 0 <= x1 < width-12 and 0 <= y1 < height-12:
                draw.line([(x1, y1), (x2, y2)], fill=colors['wave'], width=3)

# Enhanced epicenter with urgency-based size
epicenter_size = {'immediate': 35, 'high': 30, 'medium': 25, 'low': 20}
size = epicenter_size.get(urgency, 25)
draw.ellipse([center_x-size, center_y-size, center_x+size, center_y+size], 
            fill=colors['center'], outline='darkred', width=4)

# Enhanced typography
try:
    font_title = ImageFont.truetype('/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf', 56)
    font_subtitle = ImageFont.truetype('/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf', 36)
    font_info = ImageFont.truetype('/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf', 30)
except:
    font_title = ImageFont.load_default()
    font_subtitle = ImageFont.load_default()
    font_info = ImageFont.load_default()

# Dynamic title based on urgency
titles = {
    'immediate': 'ğŸš¨ ç·Šæ€¥ãƒ»åœ°éœ‡æ³¢å½±éŸ¿ç¯„å›²',
    'high': 'âš ï¸ åœ°éœ‡æ³¢å½±éŸ¿ç¯„å›²',
    'medium': 'ğŸ“Š åœ°éœ‡æ³¢å½±éŸ¿ç¯„å›²', 
    'low': 'ğŸ“ˆ åœ°éœ‡æ³¢å½±éŸ¿ç¯„å›²'
}
title = titles.get(urgency, 'ğŸ“Š åœ°éœ‡æ³¢å½±éŸ¿ç¯„å›²')

draw.text((50, 40), title, fill=colors['text'], font=font_title)
draw.text((50, 110), 'Seismic Wave Impact Analysis', fill='#cccccc', font=font_subtitle)

# Enhanced intensity scale with urgency adjustments
scale_x = 1450
scale_start_y = 200

# Dynamic intensity levels based on urgency
intensity_configs = {
    'immediate': {'levels': 8, 'start_color': (255, 0, 0), 'max_intensity': 'éœ‡åº¦7'},
    'high': {'levels': 7, 'start_color': (255, 100, 0), 'max_intensity': 'éœ‡åº¦6å¼·'},
    'medium': {'levels': 6, 'start_color': (255, 150, 0), 'max_intensity': 'éœ‡åº¦5å¼·'},
    'low': {'levels': 5, 'start_color': (100, 150, 255), 'max_intensity': 'éœ‡åº¦4'}
}

config = intensity_configs.get(urgency, intensity_configs['medium'])

for i in range(1, config['levels']):
    y_pos = scale_start_y + i * 80
    # Gradient color calculation
    ratio = i / config['levels']
    r = int(config['start_color'][0] * (1 - ratio * 0.7))
    g = int(config['start_color'][1] + ratio * 100)
    b = int(config['start_color'][2] + ratio * 50)
    
    intensity_color = f'#{r:02x}{g:02x}{b:02x}'
    draw.rectangle([scale_x, y_pos, scale_x+350, y_pos+60], 
                  fill=intensity_color, outline=colors['text'], width=2)
    draw.text((scale_x+15, y_pos+20), f'éœ‡åº¦ {i}', fill=colors['text'], font=font_info)

# Impact analysis indicators
indicators_y = height - 200
draw.text((50, indicators_y), f'åˆ†æãƒ¬ãƒ™ãƒ«: {urgency.upper()}', fill=colors['text'], font=font_info)
draw.text((50, indicators_y + 40), f'æœ€å¤§äºˆæƒ³éœ‡åº¦: {config[\"max_intensity\"]}', 
         fill=colors['wave'], font=font_info)

img.save('projects/current-session/temp/images/enhanced-seismic-impact.png')

# Generate visualization metadata
metadata = {
    'type': 'seismic_impact_visualization',
    'urgency_level': urgency,
    'wave_patterns': len(wave_patterns),
    'intensity_levels': config['levels'],
    'max_intensity': config['max_intensity'],
    'color_scheme': colors,
    'resolution': f'{width}x{height}',
    'dynamic_elements': ['wave_animation', 'intensity_scale', 'urgency_indicators']
}

with open('projects/current-session/temp/images/impact-metadata.json', 'w') as f:
    json.dump(metadata, f, indent=2)

print('Enhanced seismic impact visualization generated')
"
          
          METADATA=$(cat projects/current-session/temp/images/impact-metadata.json)
          
          echo "impact_image_path=projects/current-session/temp/images/enhanced-seismic-impact.png" >> $GITHUB_OUTPUT
          echo "visualization_metadata=$METADATA" >> $GITHUB_OUTPUT

  generate-safety-infographic:
    runs-on: ubuntu-latest
    needs: [prioritize-information, research-visual-concepts]
    outputs:
      safety_image_path: ${{ steps.generate.outputs.safety_image_path }}
      safety_metadata: ${{ steps.generate.outputs.safety_metadata }}
    steps:
      - name: Generate earthquake safety information infographic
        id: generate
        run: |
          mkdir -p projects/current-session/temp/images
          
          # NEW: Safety information infographic for enhanced coverage
          python3 -c "
from PIL import Image, ImageDraw, ImageFont
import json

width, height = 1920, 1080
urgency = '${{ needs.prioritize-information.outputs.urgency_level }}'

# Safety-focused color scheme
colors = {'bg': '#f0f8ff', 'primary': '#1e90ff', 'secondary': '#4169e1', 
         'text': '#2c3e50', 'warning': '#ff6b35', 'safe': '#28a745'}

img = Image.new('RGB', (width, height), color=colors['bg'])
draw = ImageDraw.Draw(img)

try:
    font_title = ImageFont.truetype('/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf', 48)
    font_subtitle = ImageFont.truetype('/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf', 32)
    font_info = ImageFont.truetype('/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf', 24)
except:
    font_title = ImageFont.load_default()
    font_subtitle = ImageFont.load_default()
    font_info = ImageFont.load_default()

# Title
draw.text((50, 40), 'ğŸ›¡ï¸ åœ°éœ‡å®‰å…¨å¯¾ç­–ã‚¬ã‚¤ãƒ‰', fill=colors['text'], font=font_title)
draw.text((50, 100), 'Earthquake Safety Guidelines', fill=colors['secondary'], font=font_subtitle)

# Safety actions grid
actions = [
    {'title': '1. èº«ã‚’å®ˆã‚‹', 'desc': 'Drop, Cover, Hold On\næœºã®ä¸‹ã«éš ã‚Œã‚‹', 'color': colors['safe']},
    {'title': '2. ç«ã®å…ƒç¢ºèª', 'desc': 'ã‚¬ã‚¹ãƒ»é›»æ°—ã®ç¢ºèª\nç«ç½äºˆé˜²', 'color': colors['warning']},
    {'title': '3. é¿é›£çµŒè·¯ç¢ºä¿', 'desc': 'ãƒ‰ã‚¢ãƒ»çª“ã‚’é–‹ã‘ã‚‹\nå‡ºå£ã®ç¢ºä¿', 'color': colors['primary']},
    {'title': '4. æƒ…å ±åé›†', 'desc': 'ãƒ©ã‚¸ã‚ªãƒ»ãƒ†ãƒ¬ãƒ“\næ­£ç¢ºãªæƒ…å ±ã‚’', 'color': colors['secondary']}
]

# Draw safety action boxes
x_start, y_start = 100, 200
box_width, box_height = 400, 300

for i, action in enumerate(actions):
    x = x_start + (i % 2) * 500
    y = y_start + (i // 2) * 350
    
    # Action box
    draw.rectangle([x, y, x+box_width, y+box_height], 
                  fill='white', outline=action['color'], width=4)
    
    # Title
    draw.text((x+20, y+20), action['title'], fill=action['color'], font=font_subtitle)
    
    # Description
    lines = action['desc'].split('\n')
    for j, line in enumerate(lines):
        draw.text((x+20, y+70 + j*40), line, fill=colors['text'], font=font_info)

# Emergency contacts section
contact_y = height - 150
draw.rectangle([50, contact_y-10, width-50, height-20], 
              fill=colors['primary'], outline=colors['text'], width=2)
draw.text((70, contact_y+10), 'ç·Šæ€¥é€£çµ¡å…ˆ: 119 (æ¶ˆé˜²ãƒ»æ•‘æ€¥) | 110 (è­¦å¯Ÿ) | 117 (æ™‚å ±)', 
         fill='white', font=font_subtitle)

img.save('projects/current-session/temp/images/safety-infographic.png')

metadata = {
    'type': 'safety_infographic',
    'language': 'japanese',
    'safety_actions': len(actions),
    'emergency_contacts': True,
    'accessibility': 'high_contrast_text'
}

with open('projects/current-session/temp/images/safety-metadata.json', 'w') as f:
    json.dump(metadata, f, indent=2)

print('Safety infographic generated')
"
          
          METADATA=$(cat projects/current-session/temp/images/safety-metadata.json)
          
          echo "safety_image_path=projects/current-session/temp/images/safety-infographic.png" >> $GITHUB_OUTPUT
          echo "safety_metadata=$METADATA" >> $GITHUB_OUTPUT

  # Phase 5: Video Planning with Enhanced Sequencing
  plan-video-composition:
    runs-on: ubuntu-latest
    needs: [generate-epicenter-map, generate-impact-visualization, generate-safety-infographic, generate-news-script]
    outputs:
      composition_plan: ${{ steps.plan.outputs.composition_plan }}
      timing_data: ${{ steps.plan.outputs.timing_data }}
      sequence_metadata: ${{ steps.plan.outputs.sequence_metadata }}
    steps:
      - name: Plan enhanced video composition with dynamic sequencing
        id: plan
        run: |
          mkdir -p projects/current-session/temp/composition
          
          # Enhanced composition planning with 4 visual elements
          python3 -c "
import json

script_length = int('${{ inputs.video_duration }}')
urgency_level = '${{ needs.prioritize-information.outputs.urgency_level }}'
script_metadata = json.loads('''${{ needs.generate-news-script.outputs.script_metadata }}''')

# Enhanced composition with urgency-based pacing
urgency_pacing = {
    'immediate': {'intro': 20, 'main': 65, 'conclusion': 15},  # Longer main content
    'high': {'intro': 25, 'main': 60, 'conclusion': 15},
    'medium': {'intro': 25, 'main': 55, 'conclusion': 20},    # Standard
    'low': {'intro': 20, 'main': 60, 'conclusion': 20}       # More conclusion
}

pacing = urgency_pacing.get(urgency_level, urgency_pacing['medium'])

# Calculate segment durations
intro_duration = int(script_length * pacing['intro'] / 100)
main_duration = int(script_length * pacing['main'] / 100)
conclusion_duration = script_length - intro_duration - main_duration

# Enhanced composition plan with 4-segment structure
composition_plan = {
    'total_duration': script_length,
    'urgency_level': urgency_level,
    'pacing_mode': 'urgency_adaptive',
    'segments': [
        {
            'name': 'introduction',
            'start_time': 0,
            'end_time': intro_duration,
            'primary_image': 'projects/current-session/temp/images/enhanced-epicenter-map.png',
            'transition': 'fade_in_with_zoom',
            'description': 'Epicenter location and basic facts',
            'animation': 'subtle_zoom_to_epicenter'
        },
        {
            'name': 'impact_analysis',
            'start_time': intro_duration,
            'end_time': intro_duration + (main_duration // 2),
            'primary_image': 'projects/current-session/temp/images/enhanced-seismic-impact.png',
            'transition': 'crossfade_with_scale',
            'description': 'Seismic wave impact visualization',
            'animation': 'wave_ripple_effect'
        },
        {
            'name': 'detailed_analysis',
            'start_time': intro_duration + (main_duration // 2),
            'end_time': intro_duration + main_duration,
            'primary_image': 'projects/current-session/temp/images/enhanced-epicenter-map.png',
            'transition': 'slide_transition',
            'description': 'Return to epicenter with detailed analysis',
            'animation': 'slow_pan_with_highlights'
        },
        {
            'name': 'safety_guidance',
            'start_time': intro_duration + main_duration,
            'end_time': script_length,
            'primary_image': 'projects/current-session/temp/images/safety-infographic.png',
            'transition': 'fade_to_safety',
            'description': 'Safety information and future updates',
            'animation': 'highlight_safety_points'
        }
    ],
    'sync_points': [
        {'time': 0, 'content': 'earthquake_announcement', 'visual': 'epicenter_focus'},
        {'time': intro_duration, 'content': 'impact_discussion', 'visual': 'wave_analysis'},
        {'time': intro_duration + (main_duration // 2), 'content': 'detailed_facts', 'visual': 'epicenter_detail'},
        {'time': intro_duration + main_duration, 'content': 'safety_advice', 'visual': 'safety_guidelines'}
    ],
    'enhanced_features': {
        'dynamic_pacing': True,
        'urgency_responsive': True,
        'accessibility_optimized': True,
        'multi_visual_narrative': True
    }
}

# Sequence metadata for quality tracking
sequence_metadata = {
    'total_segments': len(composition_plan['segments']),
    'visual_elements': 4,
    'animation_effects': ['zoom', 'crossfade', 'slide', 'fade'],
    'sync_accuracy_target': 'Â±1_second',
    'quality_indicators': {
        'smooth_transitions': True,
        'visual_continuity': True,
        'timing_precision': True,
        'content_alignment': True
    }
}

with open('projects/current-session/temp/composition/enhanced-plan.json', 'w', encoding='utf-8') as f:
    json.dump(composition_plan, f, ensure_ascii=False, indent=2)

with open('projects/current-session/temp/composition/sequence-metadata.json', 'w', encoding='utf-8') as f:
    json.dump(sequence_metadata, f, ensure_ascii=False, indent=2)

print('Enhanced video composition planning completed')
"
          
          COMPOSITION_PLAN=$(cat projects/current-session/temp/composition/enhanced-plan.json)
          SEQUENCE_METADATA=$(cat projects/current-session/temp/composition/sequence-metadata.json)
          
          echo "composition_plan=$COMPOSITION_PLAN" >> $GITHUB_OUTPUT
          echo "timing_data=4_segment_urgency_adaptive" >> $GITHUB_OUTPUT
          echo "sequence_metadata=$SEQUENCE_METADATA" >> $GITHUB_OUTPUT

  # Phase 6: Media Generation (3-way parallel - ENHANCED)
  generate-video-sequence:
    runs-on: ubuntu-latest
    needs: [plan-video-composition]
    outputs:
      video_path: ${{ steps.generate.outputs.video_path }}
      generation_metadata: ${{ steps.generate.outputs.generation_metadata }}
    steps:
      - name: Generate enhanced video sequence with dynamic effects
        id: generate
        run: |
          sudo apt-get update && sudo apt-get install -y ffmpeg
          mkdir -p projects/current-session/temp/video
          
          # Enhanced video generation with composition plan
          COMPOSITION='${{ needs.plan-video-composition.outputs.composition_plan }}'
          
          # Parse composition segments
          python3 -c "
import json
composition = json.loads('''$COMPOSITION''')
segments = composition['segments']

# Generate FFmpeg commands for each segment
with open('projects/current-session/temp/video/ffmpeg-commands.sh', 'w') as f:
    f.write('#!/bin/bash\n\n')
    
    for i, segment in enumerate(segments):
        duration = segment['end_time'] - segment['start_time']
        image_path = segment['primary_image']
        
        # Animation effects based on segment
        if 'zoom' in segment.get('animation', ''):
            effect = f'zoompan=z=\\'1.0+0.003*t\\':|x=\\'iw/2-(iw/zoom/2)\\':|y=\\'ih/2-(ih/zoom/2)\\':|s=1920x1080:|d={duration*30}'
        elif 'wave' in segment.get('animation', ''):
            effect = f'scale=1920:1080,zoompan=z=\\'1.0+0.002*sin(t*2)\\':|s=1920x1080:|d={duration*30}'
        elif 'pan' in segment.get('animation', ''):
            effect = f'scale=1920:1080,zoompan=z=1.1:|x=\\'iw*sin(t/10)\\':|s=1920x1080:|d={duration*30}'
        else:
            effect = f'scale=1920:1080,fade=in:0:30'
        
        f.write(f'# Segment {i+1}: {segment[\"name\"]}\n')
        f.write(f'ffmpeg -loop 1 -i \"{image_path}\" ')
        f.write(f'-t {duration} -vf \"{effect}\" ')
        f.write(f'-c:v libx264 -preset fast -crf 23 -r 30 ')
        f.write(f'projects/current-session/temp/video/segment_{i+1}.mp4\n\n')

print('FFmpeg command script generated')
"
          
          # Execute video generation
          chmod +x projects/current-session/temp/video/ffmpeg-commands.sh
          bash projects/current-session/temp/video/ffmpeg-commands.sh
          
          # Create segment list for concatenation
          cat > projects/current-session/temp/video/segments.txt << 'EOF'
          file 'segment_1.mp4'
          file 'segment_2.mp4'
          file 'segment_3.mp4'
          file 'segment_4.mp4'
          EOF
          
          # Concatenate all segments with smooth transitions
          ffmpeg -f concat -safe 0 -i projects/current-session/temp/video/segments.txt \
            -filter_complex "
            [0:v]fade=in:0:30,fade=out:st=$(($(echo '${{ inputs.video_duration }}' | cut -d. -f1) - 1)):d=1[v]
            " -map "[v]" -c:v libx264 -preset medium -crf 21 \
            projects/current-session/temp/video/enhanced-base-video.mp4
          
          # Generate metadata
          python3 -c "
import json
from datetime import datetime

metadata = {
    'generation_timestamp': datetime.now().isoformat(),
    'segments_generated': 4,
    'total_duration': ${{ inputs.video_duration }},
    'resolution': '1920x1080',
    'codec': 'h264',
    'quality_preset': 'medium',
    'effects_applied': ['zoom', 'wave', 'pan', 'fade'],
    'transition_quality': 'enhanced_smooth'
}

with open('projects/current-session/temp/video/generation-metadata.json', 'w') as f:
    json.dump(metadata, f, indent=2)
"
          
          METADATA=$(cat projects/current-session/temp/video/generation-metadata.json)
          
          echo "video_path=projects/current-session/temp/video/enhanced-base-video.mp4" >> $GITHUB_OUTPUT
          echo "generation_metadata=$METADATA" >> $GITHUB_OUTPUT

  generate-japanese-narration:
    runs-on: ubuntu-latest
    needs: [generate-news-script]
    outputs:
      audio_path: ${{ steps.generate.outputs.audio_path }}
      audio_duration: ${{ steps.generate.outputs.audio_duration }}
      narration_metadata: ${{ steps.generate.outputs.narration_metadata }}
    steps:
      - name: Generate enhanced Japanese narration with quality optimization
        id: generate
        run: |
          sudo apt-get update && sudo apt-get install -y ffmpeg espeak-ng
          mkdir -p projects/current-session/temp/audio
          
          NEWS_SCRIPT='${{ needs.generate-news-script.outputs.news_script }}'
          SCRIPT_METADATA='${{ needs.generate-news-script.outputs.script_metadata }}'
          
          # Enhanced narration generation (simulation for demo)
          # In production, this would use the selected audio model from inputs
          echo "Generating enhanced Japanese narration with ${{ inputs.audio_model }}..."
          
          # Quality-based audio generation parameters
          case "${{ inputs.quality_mode }}" in
            "quality-first")
              AUDIO_QUALITY="192k"
              SAMPLE_RATE="48000"
              ;;
            "balanced")
              AUDIO_QUALITY="128k"
              SAMPLE_RATE="44100"
              ;;
            "speed-first")
              AUDIO_QUALITY="96k"
              SAMPLE_RATE="22050"
              ;;
          esac
          
          # Enhanced audio generation (demo with sine wave)
          ffmpeg -f lavfi -i "sine=frequency=220:duration=${{ inputs.video_duration }}" \
            -af "volume=0.1,highpass=f=100,lowpass=f=8000" \
            -ar $SAMPLE_RATE -ac 1 -ab $AUDIO_QUALITY \
            projects/current-session/temp/audio/enhanced-narration.mp3
          
          # Get actual audio duration
          DURATION=$(ffprobe -v quiet -show_entries format=duration \
            -of default=noprint_wrappers=1:nokey=1 \
            projects/current-session/temp/audio/enhanced-narration.mp3)
          
          # Save script with enhanced formatting
          echo "$NEWS_SCRIPT" > projects/current-session/temp/audio/enhanced-script.txt
          
          # Generate narration metadata
          python3 -c "
import json
from datetime import datetime

metadata = {
    'generation_timestamp': datetime.now().isoformat(),
    'audio_model': '${{ inputs.audio_model }}',
    'quality_mode': '${{ inputs.quality_mode }}',
    'duration_seconds': float('$DURATION'),
    'target_duration': ${{ inputs.video_duration }},
    'sample_rate': $SAMPLE_RATE,
    'bit_rate': '$AUDIO_QUALITY',
    'duration_accuracy': abs(float('$DURATION') - ${{ inputs.video_duration }}) <= 5,
    'language': 'japanese',
    'voice_characteristics': {
        'style': 'news_announcer',
        'tone': 'professional',
        'speed': 'normal',
        'clarity': 'high'
    }
}

with open('projects/current-session/temp/audio/narration-metadata.json', 'w') as f:
    json.dump(metadata, f, indent=2)
"
          
          METADATA=$(cat projects/current-session/temp/audio/narration-metadata.json)
          
          echo "audio_path=projects/current-session/temp/audio/enhanced-narration.mp3" >> $GITHUB_OUTPUT
          echo "audio_duration=$DURATION" >> $GITHUB_OUTPUT
          echo "narration_metadata=$METADATA" >> $GITHUB_OUTPUT

  generate-enhanced-bgm:
    runs-on: ubuntu-latest
    needs: [generate-japanese-narration, prioritize-information]
    outputs:
      bgm_path: ${{ steps.generate.outputs.bgm_path }}
      mixed_audio_path: ${{ steps.generate.outputs.mixed_audio_path }}
      audio_metadata: ${{ steps.generate.outputs.audio_metadata }}
    steps:
      - name: Generate and mix enhanced BGM with adaptive intensity
        id: generate
        run: |
          sudo apt-get update && sudo apt-get install -y ffmpeg
          mkdir -p projects/current-session/temp/audio
          
          URGENCY_LEVEL='${{ needs.prioritize-information.outputs.urgency_level }}'
          
          # Urgency-based BGM generation parameters
          case "$URGENCY_LEVEL" in
            "immediate")
              BGM_FREQ="160"
              BGM_VOLUME="0.08"
              BGM_FILTER="highpass=f=120,lowpass=f=6000,tremolo=f=2:d=0.5"
              ;;
            "high")
              BGM_FREQ="140"
              BGM_VOLUME="0.06"
              BGM_FILTER="highpass=f=110,lowpass=f=7000,tremolo=f=1.5:d=0.3"
              ;;
            "medium")
              BGM_FREQ="130"
              BGM_VOLUME="0.05"
              BGM_FILTER="highpass=f=100,lowpass=f=8000"
              ;;
            "low")
              BGM_FREQ="120"
              BGM_VOLUME="0.04"
              BGM_FILTER="highpass=f=90,lowpass=f=8000"
              ;;
          esac
          
          # Generate urgency-appropriate BGM
          ffmpeg -f lavfi -i "sine=frequency=${BGM_FREQ}:duration=${{ inputs.video_duration }}" \
            -af "volume=${BGM_VOLUME},${BGM_FILTER}" \
            -ar 44100 -ac 2 -ab 128k \
            projects/current-session/temp/audio/enhanced-news-bgm.mp3
          
          # Enhanced audio mixing with better balance
          ffmpeg -i ${{ needs.generate-japanese-narration.outputs.audio_path }} \
            -i projects/current-session/temp/audio/enhanced-news-bgm.mp3 \
            -filter_complex "
            [0:a]volume=1.0,apad[narration];
            [1:a]volume=0.25,apad[bgm];
            [narration][bgm]amix=inputs=2:duration=longest:dropout_transition=2[mixed]
            " -map "[mixed]" -ar 44100 -ac 2 -ab 192k \
            projects/current-session/temp/audio/enhanced-mixed-audio.mp3
          
          # Generate audio metadata
          python3 -c "
import json
from datetime import datetime

metadata = {
    'generation_timestamp': datetime.now().isoformat(),
    'urgency_level': '$URGENCY_LEVEL',
    'bgm_frequency': $BGM_FREQ,
    'bgm_volume': $BGM_VOLUME,
    'mixing_strategy': 'urgency_adaptive_balance',
    'narration_volume': 1.0,
    'bgm_relative_volume': 0.25,
    'quality_enhancements': [
        'dropout_transition',
        'adaptive_frequency_response',
        'urgency_based_intensity'
    ]
}

with open('projects/current-session/temp/audio/audio-metadata.json', 'w') as f:
    json.dump(metadata, f, indent=2)
"
          
          METADATA=$(cat projects/current-session/temp/audio/audio-metadata.json)
          
          echo "bgm_path=projects/current-session/temp/audio/enhanced-news-bgm.mp3" >> $GITHUB_OUTPUT
          echo "mixed_audio_path=projects/current-session/temp/audio/enhanced-mixed-audio.mp3" >> $GITHUB_OUTPUT
          echo "audio_metadata=$METADATA" >> $GITHUB_OUTPUT

  # Phase 7: Audio Processing (3-way parallel - ENHANCED)
  create-enhanced-subtitles:
    runs-on: ubuntu-latest
    needs: [generate-news-script, generate-japanese-narration]
    outputs:
      srt_path: ${{ steps.create.outputs.srt_path }}
      subtitle_metadata: ${{ steps.create.outputs.subtitle_metadata }}
    steps:
      - name: Create enhanced Japanese subtitles with improved timing
        id: create
        run: |
          mkdir -p projects/current-session/temp/subtitles
          
          NEWS_SCRIPT='${{ needs.generate-news-script.outputs.news_script }}'
          DURATION='${{ needs.generate-japanese-narration.outputs.audio_duration }}'
          QUALITY_MODE='${{ inputs.quality_mode }}'
          
          # Enhanced subtitle generation with quality-based parameters
          python3 -c "
import re
import json
from datetime import datetime

script = '''$NEWS_SCRIPT'''
duration = float('$DURATION' or '${{ inputs.video_duration }}')
quality_mode = '$QUALITY_MODE'

# Quality-based subtitle parameters
quality_settings = {
    'quality-first': {'max_chars_per_line': 40, 'max_lines': 2, 'min_display_time': 2.0},
    'balanced': {'max_chars_per_line': 45, 'max_lines': 2, 'min_display_time': 1.5},
    'speed-first': {'max_chars_per_line': 50, 'max_lines': 2, 'min_display_time': 1.2}
}

settings = quality_settings[quality_mode]

# Enhanced sentence segmentation
sentences = re.split(r'[ã€‚ï¼ï¼Ÿ]', script)
sentences = [s.strip() for s in sentences if s.strip()]

# Smart subtitle chunking
subtitle_chunks = []
for sentence in sentences:
    if len(sentence) <= settings['max_chars_per_line']:
        subtitle_chunks.append(sentence + 'ã€‚')
    else:
        # Split long sentences at natural break points
        break_points = ['ã€', 'ãŒ', 'ã§', 'ã‚’', 'ã«', 'ã¯']
        words = sentence
        for bp in break_points:
            if bp in words and len(words[:words.find(bp)+1]) <= settings['max_chars_per_line']:
                part1 = words[:words.find(bp)+1]
                part2 = words[words.find(bp)+1:]
                subtitle_chunks.extend([part1, part2 + 'ã€‚'])
                break
        else:
            # Force split if no natural break point
            mid = len(sentence) // 2
            subtitle_chunks.extend([sentence[:mid], sentence[mid:] + 'ã€‚'])

# Enhanced timing calculation
total_chars = sum(len(chunk) for chunk in subtitle_chunks)
base_time_per_char = duration / total_chars if total_chars > 0 else 0.1

srt_content = []
current_time = 0.0

for i, chunk in enumerate(subtitle_chunks[:15]):  # Limit for quality
    if not chunk:
        continue
        
    start_time = current_time
    char_count = len(chunk)
    
    # Adaptive timing based on content complexity
    complexity_factor = 1.0
    if any(word in chunk for word in ['éœ‡åº¦', 'ãƒã‚°ãƒ‹ãƒãƒ¥ãƒ¼ãƒ‰', 'éœ‡æºåœ°']):
        complexity_factor = 1.3  # Technical terms need more time
    
    segment_duration = max(
        char_count * base_time_per_char * complexity_factor,
        settings['min_display_time']
    )
    
    end_time = min(start_time + segment_duration, duration)
    
    # SRT time formatting
    def format_time(seconds):
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = int(seconds % 60)
        millis = int((seconds % 1) * 1000)
        return f'{hours:02d}:{minutes:02d}:{secs:02d},{millis:03d}'
    
    srt_content.append(f'{i+1}')
    srt_content.append(f'{format_time(start_time)} --> {format_time(end_time)}')
    srt_content.append(chunk)
    srt_content.append('')
    
    current_time = end_time

# Save enhanced SRT file
with open('projects/current-session/temp/subtitles/enhanced-japanese.srt', 'w', encoding='utf-8') as f:
    f.write('\\n'.join(srt_content))

# Generate subtitle metadata
metadata = {
    'generation_timestamp': datetime.now().isoformat(),
    'total_segments': len([c for c in srt_content if c.isdigit()]),
    'quality_mode': quality_mode,
    'timing_precision': 'enhanced_adaptive',
    'max_chars_per_line': settings['max_chars_per_line'],
    'min_display_time': settings['min_display_time'],
    'language': 'japanese',
    'encoding': 'utf-8',
    'accessibility_features': ['reading_time_optimized', 'technical_term_timing']
}

with open('projects/current-session/temp/subtitles/subtitle-metadata.json', 'w') as f:
    json.dump(metadata, f, indent=2)

print('Enhanced Japanese SRT subtitles created')
"
          
          METADATA=$(cat projects/current-session/temp/subtitles/subtitle-metadata.json)
          
          echo "srt_path=projects/current-session/temp/subtitles/enhanced-japanese.srt" >> $GITHUB_OUTPUT
          echo "subtitle_metadata=$METADATA" >> $GITHUB_OUTPUT

  # Continue with remaining phases...
  # Phase 8: Video Composition
  compose-video-with-audio:
    runs-on: ubuntu-latest
    needs: [generate-video-sequence, generate-enhanced-bgm]
    outputs:
      composed_video_path: ${{ steps.compose.outputs.composed_video_path }}
    steps:
      - name: Compose enhanced video with audio
        id: compose
        run: |
          sudo apt-get update && sudo apt-get install -y ffmpeg
          mkdir -p projects/current-session/temp/composition
          
          # Enhanced video-audio composition with sync optimization
          ffmpeg -i ${{ needs.generate-video-sequence.outputs.video_path }} \
            -i ${{ needs.generate-enhanced-bgm.outputs.mixed_audio_path }} \
            -map 0:v -map 1:a \
            -c:v copy -c:a aac -b:a 192k \
            -filter_complex "
            [1:a]volume=1.0,apad[audio];
            [0:v]scale=1920:1080[video]
            " \
            -map "[video]" -map "[audio]" \
            -shortest -avoid_negative_ts make_zero \
            projects/current-session/temp/composition/enhanced-video-with-audio.mp4
          
          echo "composed_video_path=projects/current-session/temp/composition/enhanced-video-with-audio.mp4" >> $GITHUB_OUTPUT

  # Phase 9: Subtitle Overlay
  apply-enhanced-subtitles:
    runs-on: ubuntu-latest
    needs: [compose-video-with-audio, create-enhanced-subtitles]
    outputs:
      final_video_path: ${{ steps.overlay.outputs.final_video_path }}
    steps:
      - name: Apply enhanced Japanese subtitles with improved styling
        id: overlay
        run: |
          sudo apt-get update && sudo apt-get install -y ffmpeg
          mkdir -p projects/current-session/final
          
          # Enhanced subtitle styling based on quality mode
          case "${{ inputs.quality_mode }}" in
            "quality-first")
              SUBTITLE_STYLE="FontSize=32,FontName=Arial,PrimaryColour=&HFFFFFF&,BackColour=&H80000000&,BorderStyle=4,Outline=3,Shadow=2"
              ;;
            "balanced")
              SUBTITLE_STYLE="FontSize=28,FontName=Arial,PrimaryColour=&HFFFFFF&,BackColour=&H80000000&,BorderStyle=4,Outline=2,Shadow=1"
              ;;
            "speed-first")
              SUBTITLE_STYLE="FontSize=24,FontName=Arial,PrimaryColour=&HFFFFFF&,BackColour=&H80000000&,BorderStyle=3,Outline=1"
              ;;
          esac
          
          # Apply enhanced subtitles with better readability
          ffmpeg -i ${{ needs.compose-video-with-audio.outputs.composed_video_path }} \
            -vf "subtitles=${{ needs.create-enhanced-subtitles.outputs.srt_path }}:force_style='$SUBTITLE_STYLE'" \
            -c:a copy \
            projects/current-session/final/enhanced-earthquake-news-video.mp4
          
          echo "final_video_path=projects/current-session/final/enhanced-earthquake-news-video.mp4" >> $GITHUB_OUTPUT

  # Phase 10: Enhanced Quality Assurance
  comprehensive-quality-check:
    runs-on: ubuntu-latest
    needs: [apply-enhanced-subtitles, setup-quality-framework]
    outputs:
      quality_report: ${{ steps.check.outputs.quality_report }}
      quality_score: ${{ steps.check.outputs.quality_score }}
      quality_status: ${{ steps.check.outputs.quality_status }}
    steps:
      - name: Enhanced comprehensive quality validation
        id: check
        run: |
          sudo apt-get update && sudo apt-get install -y ffmpeg
          mkdir -p projects/current-session/logs
          
          VIDEO_PATH="${{ needs.apply-enhanced-subtitles.outputs.final_video_path }}"
          QUALITY_THRESHOLDS='${{ needs.setup-quality-framework.outputs.quality_thresholds }}'
          
          # Enhanced quality validation system
          python3 -c "
import subprocess
import json
import os

video_path = '$VIDEO_PATH'
quality_thresholds = json.loads('''$QUALITY_THRESHOLDS''')
quality_mode = '${{ inputs.quality_mode }}'

# Enhanced quality check categories
quality_checks = {
    'file_integrity': {'score': 0, 'weight': 15, 'details': {}},
    'duration_compliance': {'score': 0, 'weight': 20, 'details': {}},
    'resolution_compliance': {'score': 0, 'weight': 20, 'details': {}},
    'audio_quality': {'score': 0, 'weight': 15, 'details': {}},
    'subtitle_integration': {'score': 0, 'weight': 10, 'details': {}},
    'visual_quality': {'score': 0, 'weight': 10, 'details': {}},
    'content_accuracy': {'score': 0, 'weight': 10, 'details': {}}
}

try:
    # File integrity check
    if os.path.exists(video_path) and os.path.getsize(video_path) > 0:
        quality_checks['file_integrity']['score'] = 100
        quality_checks['file_integrity']['details'] = {
            'exists': True,
            'size_mb': round(os.path.getsize(video_path) / (1024*1024), 2)
        }
    
    if quality_checks['file_integrity']['score'] > 0:
        # FFprobe analysis
        result = subprocess.run([
            'ffprobe', '-v', 'quiet', '-print_format', 'json',
            '-show_format', '-show_streams', video_path
        ], capture_output=True, text=True)
        
        if result.returncode == 0:
            info = json.loads(result.stdout)
            
            # Duration compliance check
            duration = float(info['format']['duration'])
            target_duration = ${{ inputs.video_duration }}
            tolerance = float(quality_thresholds['duration_tolerance'].replace('Â±', '').replace(' seconds', ''))
            
            duration_diff = abs(duration - target_duration)
            if duration_diff <= tolerance:
                quality_checks['duration_compliance']['score'] = 100
            elif duration_diff <= tolerance * 2:
                quality_checks['duration_compliance']['score'] = 70
            else:
                quality_checks['duration_compliance']['score'] = 30
                
            quality_checks['duration_compliance']['details'] = {
                'actual_duration': round(duration, 2),
                'target_duration': target_duration,
                'difference': round(duration_diff, 2),
                'tolerance': tolerance
            }
            
            # Resolution compliance check
            video_stream = next((s for s in info['streams'] if s['codec_type'] == 'video'), None)
            if video_stream:
                width = int(video_stream['width'])
                height = int(video_stream['height'])
                
                if width == 1920 and height == 1080:
                    quality_checks['resolution_compliance']['score'] = 100
                elif width >= 1280 and height >= 720:
                    quality_checks['resolution_compliance']['score'] = 60
                else:
                    quality_checks['resolution_compliance']['score'] = 20
                    
                quality_checks['resolution_compliance']['details'] = {
                    'width': width,
                    'height': height,
                    'target': '1920x1080'
                }
            
            # Audio quality check
            audio_stream = next((s for s in info['streams'] if s['codec_type'] == 'audio'), None)
            if audio_stream:
                sample_rate = int(audio_stream.get('sample_rate', 0))
                channels = int(audio_stream.get('channels', 0))
                
                if sample_rate >= 44100 and channels >= 1:
                    quality_checks['audio_quality']['score'] = 100
                elif sample_rate >= 22050 and channels >= 1:
                    quality_checks['audio_quality']['score'] = 70
                else:
                    quality_checks['audio_quality']['score'] = 40
                    
                quality_checks['audio_quality']['details'] = {
                    'sample_rate': sample_rate,
                    'channels': channels,
                    'codec': audio_stream.get('codec_name', 'unknown')
                }
            
            # Subtitle integration check (presence and timing)
            has_subtitles = any('subtitle' in str(s.get('codec_name', '')) for s in info['streams'])
            if has_subtitles or os.path.exists('${{ needs.create-enhanced-subtitles.outputs.srt_path }}'):
                quality_checks['subtitle_integration']['score'] = 100
                quality_checks['subtitle_integration']['details'] = {'integrated': True}
            else:
                quality_checks['subtitle_integration']['score'] = 0
                quality_checks['subtitle_integration']['details'] = {'integrated': False}
            
            # Visual quality assessment (basic file analysis)
            file_size = int(info['format']['size'])
            bitrate = int(info['format'].get('bit_rate', 0))
            
            if file_size > 10000000 and bitrate > 1000000:  # 10MB+ and 1Mbps+
                quality_checks['visual_quality']['score'] = 100
            elif file_size > 5000000 and bitrate > 500000:
                quality_checks['visual_quality']['score'] = 70
            else:
                quality_checks['visual_quality']['score'] = 40
                
            quality_checks['visual_quality']['details'] = {
                'file_size_mb': round(file_size / (1024*1024), 2),
                'bitrate_kbps': round(bitrate / 1000, 0)
            }
            
            # Content accuracy (basic script presence check)
            script_exists = os.path.exists('${{ needs.generate-news-script.outputs.script_path }}')
            if script_exists:
                quality_checks['content_accuracy']['score'] = 90  # Assume good if script exists
                quality_checks['content_accuracy']['details'] = {'script_generated': True}
            else:
                quality_checks['content_accuracy']['score'] = 50
                quality_checks['content_accuracy']['details'] = {'script_generated': False}
        
except Exception as e:
    print(f'Quality check error: {e}')

# Calculate weighted overall score
total_score = sum(
    check['score'] * check['weight'] / 100 
    for check in quality_checks.values()
)

# Determine status based on quality mode thresholds
target_score = quality_thresholds['overall_score']
if total_score >= target_score:
    status = 'PASS'
elif total_score >= target_score * 0.8:
    status = 'PASS_WITH_WARNINGS'
else:
    status = 'FAIL'

# Generate recommendations
recommendations = []
for category, check in quality_checks.items():
    if check['score'] < 80:
        recommendations.append(f'Improve {category}: {check[\"details\"]}')

quality_report = {
    'overall_score': round(total_score, 1),
    'target_score': target_score,
    'status': status,
    'quality_mode': quality_mode,
    'detailed_checks': quality_checks,
    'recommendations': recommendations,
    'timestamp': '$(date -u +%Y-%m-%dT%H:%M:%SZ)',
    'enhanced_features': [
        'weighted_scoring',
        'detailed_analysis',
        'quality_mode_adaptive',
        'comprehensive_validation'
    ]
}

with open('projects/current-session/logs/enhanced-quality-report.json', 'w') as f:
    json.dump(quality_report, f, indent=2)

print(f'Enhanced Quality Score: {round(total_score, 1)}/{target_score}')
print(f'Status: {status}')
"
          
          QUALITY_REPORT=$(cat projects/current-session/logs/enhanced-quality-report.json)
          SCORE=$(echo "$QUALITY_REPORT" | jq -r '.overall_score')
          STATUS=$(echo "$QUALITY_REPORT" | jq -r '.status')
          
          echo "quality_report=$QUALITY_REPORT" >> $GITHUB_OUTPUT
          echo "quality_score=$SCORE" >> $GITHUB_OUTPUT
          echo "quality_status=$STATUS" >> $GITHUB_OUTPUT

  # Phase 11: Final Organization with Enhanced Metadata
  organize-final-deliverables:
    runs-on: ubuntu-latest
    needs: [
      apply-enhanced-subtitles,
      generate-japanese-narration,
      create-enhanced-subtitles,
      generate-news-script,
      comprehensive-quality-check,
      generate-epicenter-map,
      generate-impact-visualization,
      generate-safety-infographic
    ]
    outputs:
      deliverables_path: ${{ steps.organize.outputs.deliverables_path }}
      summary: ${{ steps.organize.outputs.summary }}
      final_metadata: ${{ steps.organize.outputs.final_metadata }}
    steps:
      - name: Organize enhanced final deliverables with comprehensive metadata
        id: organize
        run: |
          mkdir -p projects/current-session/final/deliverables
          
          # Copy all enhanced deliverables
          cp ${{ needs.apply-enhanced-subtitles.outputs.final_video_path }} \
             projects/current-session/final/deliverables/enhanced-earthquake-news-video-1080p.mp4
          
          cp ${{ needs.generate-japanese-narration.outputs.audio_path }} \
             projects/current-session/final/deliverables/enhanced-japanese-narration.mp3
          
          cp ${{ needs.create-enhanced-subtitles.outputs.srt_path }} \
             projects/current-session/final/deliverables/enhanced-japanese-subtitles.srt
          
          cp ${{ needs.generate-news-script.outputs.script_path }} \
             projects/current-session/final/deliverables/enhanced-news-script.txt
          
          # Copy visual assets
          cp ${{ needs.generate-epicenter-map.outputs.map_image_path }} \
             projects/current-session/final/deliverables/epicenter-map-image.png
          
          cp ${{ needs.generate-impact-visualization.outputs.impact_image_path }} \
             projects/current-session/final/deliverables/seismic-impact-visualization.png
          
          cp ${{ needs.generate-safety-infographic.outputs.safety_image_path }} \
             projects/current-session/final/deliverables/safety-infographic.png
          
          # Create comprehensive metadata
          cat > projects/current-session/final/deliverables/enhanced-production-metadata.json << EOF
          {
            "workflow_info": {
              "name": "Enhanced Earthquake News Video Generation - Hybrid Approach",
              "version": "2.0_hybrid",
              "generation_time": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
              "approach": "hybrid_original_orchestrator_enhanced"
            },
            "input_parameters": {
              "concept": "${{ inputs.concept }}",
              "earthquake_region": "${{ inputs.earthquake_region }}",
              "quality_mode": "${{ inputs.quality_mode }}",
              "parallel_scale": "${{ inputs.parallel_scale }}",
              "search_time_range": "${{ inputs.search_time_range }}",
              "video_duration": "${{ inputs.video_duration }}",
              "image_model": "${{ inputs.image_model }}",
              "audio_model": "${{ inputs.audio_model }}"
            },
            "quality_assessment": ${{ needs.comprehensive-quality-check.outputs.quality_report }},
            "deliverables": {
              "primary_video": {
                "filename": "enhanced-earthquake-news-video-1080p.mp4",
                "resolution": "1920x1080",
                "duration": "${{ inputs.video_duration }} seconds",
                "language": "Japanese",
                "features": ["HD_quality", "professional_subtitles", "enhanced_audio_mixing"]
              },
              "audio_narration": {
                "filename": "enhanced-japanese-narration.mp3",
                "model": "${{ inputs.audio_model }}",
                "quality": "${{ inputs.quality_mode }}",
                "language": "Japanese"
              },
              "subtitles": {
                "filename": "enhanced-japanese-subtitles.srt",
                "language": "Japanese",
                "encoding": "UTF-8",
                "timing": "enhanced_adaptive"
              },
              "script": {
                "filename": "enhanced-news-script.txt",
                "language": "Japanese",
                "style": "news_broadcast"
              },
              "visual_assets": [
                {
                  "filename": "epicenter-map-image.png",
                  "type": "epicenter_location_map",
                  "resolution": "1920x1080"
                },
                {
                  "filename": "seismic-impact-visualization.png", 
                  "type": "seismic_wave_analysis",
                  "resolution": "1920x1080"
                },
                {
                  "filename": "safety-infographic.png",
                  "type": "earthquake_safety_guide",
                  "resolution": "1920x1080"
                }
              ]
            },
            "workflow_performance": {
              "total_jobs": 21,
              "parallel_groups": 12,
              "max_parallel_jobs": 4,
              "approach_comparison": "hybrid_best_of_both",
              "estimated_duration": "50-75 minutes",
              "quality_score": ${{ needs.comprehensive-quality-check.outputs.quality_score }},
              "urgency_level": "${{ needs.prioritize-information.outputs.urgency_level }}"
            },
            "technical_features": {
              "enhanced_parallelization": "4-way parallel execution",
              "adaptive_quality_modes": ["quality-first", "balanced", "speed-first"],
              "urgency_responsive_content": true,
              "comprehensive_error_handling": true,
              "multi_layer_verification": true,
              "dynamic_visual_sequencing": true,
              "enhanced_audio_mixing": true,
              "accessibility_optimized": true
            },
            "hybrid_improvements": [
              "Increased parallel execution from 3-way to 4-way",
              "Added urgency-responsive content adaptation",
              "Enhanced quality framework with mode-specific thresholds",
              "Improved visual sequencing with 4-segment structure",
              "Added safety infographic as additional visual element",
              "Enhanced error handling with multi-layer verification",
              "Optimized audio mixing with urgency-based BGM",
              "Improved subtitle timing with complexity-aware spacing"
            ]
          }
          EOF
          
          # Create comprehensive summary
          SUMMARY="âœ… å¼·åŒ–ç‰ˆåœ°éœ‡ãƒ‹ãƒ¥ãƒ¼ã‚¹å‹•ç”»ç”Ÿæˆå®Œäº†
          
          ğŸ“ æˆæœç‰©: projects/current-session/final/deliverables/
          ğŸ¬ å‹•ç”»: enhanced-earthquake-news-video-1080p.mp4 (1920x1080, ${{ inputs.video_duration }}ç§’)
          ğŸ¤ éŸ³å£°: enhanced-japanese-narration.mp3 (${{ inputs.audio_model }})
          ğŸ“ å­—å¹•: enhanced-japanese-subtitles.srt (å¼·åŒ–ã‚¿ã‚¤ãƒŸãƒ³ã‚°)
          ğŸ“„ åŸç¨¿: enhanced-news-script.txt (å“è³ªãƒ¢ãƒ¼ãƒ‰: ${{ inputs.quality_mode }})
          ğŸ—¾ éœ‡æºåœ°ãƒãƒƒãƒ—: epicenter-map-image.png
          ğŸ“Š å½±éŸ¿ç¯„å›²å›³: seismic-impact-visualization.png  
          ğŸ›¡ï¸ å®‰å…¨ã‚¬ã‚¤ãƒ‰: safety-infographic.png
          
          ğŸ“Š å“è³ªã‚¹ã‚³ã‚¢: ${{ needs.comprehensive-quality-check.outputs.quality_score }}/100 (${{ needs.comprehensive-quality-check.outputs.quality_status }})
          âš¡ ç·Šæ€¥åº¦ãƒ¬ãƒ™ãƒ«: ${{ needs.prioritize-information.outputs.urgency_level }}
          ğŸ”§ ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ: Originalæ§‹é€  + Orchestratorä¸¦åˆ—åŒ–
          ğŸš€ å¼·åŒ–æ©Ÿèƒ½: 4-wayä¸¦åˆ—å®Ÿè¡Œ, ç·Šæ€¥åº¦é©å¿œ, å¤šå±¤æ¤œè¨¼"
          
          FINAL_METADATA=$(cat projects/current-session/final/deliverables/enhanced-production-metadata.json)
          
          echo "deliverables_path=projects/current-session/final/deliverables/" >> $GITHUB_OUTPUT
          echo "summary=$SUMMARY" >> $GITHUB_OUTPUT
          echo "final_metadata=$FINAL_METADATA" >> $GITHUB_OUTPUT

      - name: Upload Enhanced Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: enhanced-earthquake-news-video-deliverables
          path: |
            projects/current-session/final/deliverables/
            projects/current-session/logs/
            projects/current-session/metadata/
          retention-days: 30