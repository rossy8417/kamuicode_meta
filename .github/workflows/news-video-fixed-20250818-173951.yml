name: News Video Creation Workflow

on:
  workflow_dispatch:
    inputs:
      news_topic:
        description: '„Éã„É•„Éº„Çπ„ÅÆ„Éà„Éî„ÉÉ„ÇØ'
        required: true
        default: 'ÊúÄÊñ∞AIÊäÄË°ì„ÅÆÈÄ≤Ê≠©'
        type: string
      duration:
        description: 'ÂãïÁîª„ÅÆÈï∑„Åï'
        required: true
        default: '60s'
        type: choice
        options:
          - '15s'
          - '30s'
          - '60s'
          - '90s'
          - '3min'
          - '5min'
      news_category:
        description: '„Éã„É•„Éº„Çπ„Ç´„ÉÜ„Ç¥„É™„Éº'
        required: true
        default: 'technology'
        type: choice
        options:
          - 'technology'
          - 'business'
          - 'science'
          - 'politics'
          - 'health'
          - 'sports'
          - 'entertainment'
      target_platform:
        description: 'ÈÖç‰ø°„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†'
        required: true
        default: 'youtube'
        type: choice
        options:
          - 'youtube'
          - 'instagram'
          - 'tiktok'
          - 'twitter'
      visual_style:
        description: '„Éì„Ç∏„É•„Ç¢„É´„Çπ„Çø„Ç§„É´'
        required: true
        default: 'cinematic'
        type: choice
        options:
          - 'cinematic'
          - 'documentary'
          - 'corporate'
      enable_fallback:
        description: '„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂá¶ÁêÜ„ÇíÊúâÂäπ„Å´„Åô„Çã'
        required: true
        default: true
        type: boolean
  push:
    paths-ignore:
      - '.github/workflows/**'

env:
  PROJECT_DIR: /home/runner/work/kamuicode_meta/kamuicode_meta/projects/issue-66-20250818-025742

jobs:
  check-trigger:
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
    steps:
      - name: Check Event Type
        id: check
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            echo "should_run=false" >> $GITHUB_OUTPUT
            echo "Skipping workflow for push event"
          else
            echo "should_run=true" >> $GITHUB_OUTPUT
          fi

  setup:
    needs: check-trigger
    if: needs.check-trigger.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      project_dir: ${{ steps.setup.outputs.project_dir }}
      news_topic: ${{ steps.setup.outputs.news_topic }}
      news_category: ${{ steps.setup.outputs.news_category }}
      duration: ${{ steps.setup.outputs.duration }}
      scene_count: ${{ steps.setup.outputs.scene_count }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install Dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y jq

      - name: Setup Project Environment
        id: setup
        run: |
          # Create project directory structure
          mkdir -p "${PROJECT_DIR}"
          mkdir -p "${PROJECT_DIR}/metadata"
          mkdir -p "${PROJECT_DIR}/media/images"
          mkdir -p "${PROJECT_DIR}/media/videos"
          mkdir -p "${PROJECT_DIR}/media/audio"
          mkdir -p "${PROJECT_DIR}/logs"
          mkdir -p "${PROJECT_DIR}/final"
          
          # Extract duration seconds
          DURATION_INPUT="${{ github.event.inputs.duration || '60s' }}"
          case "$DURATION_INPUT" in
            "15s") DURATION_SECONDS=15 ;;
            "30s") DURATION_SECONDS=30 ;;
            "60s") DURATION_SECONDS=60 ;;
            "90s") DURATION_SECONDS=90 ;;
            "3min") DURATION_SECONDS=180 ;;
            "5min") DURATION_SECONDS=300 ;;
            *) DURATION_SECONDS=60 ;;
          esac
          
          # Calculate scene count (5 seconds per scene)
          SCENE_COUNT=$(( (DURATION_SECONDS + 4) / 5 ))
          
          echo "project_dir=${PROJECT_DIR}" >> $GITHUB_OUTPUT
          echo "news_topic=${{ github.event.inputs.news_topic || 'ÊúÄÊñ∞AIÊäÄË°ì„ÅÆÈÄ≤Ê≠©' }}" >> $GITHUB_OUTPUT
          echo "news_category=${{ github.event.inputs.news_category || 'technology' }}" >> $GITHUB_OUTPUT
          echo "duration=${DURATION_SECONDS}" >> $GITHUB_OUTPUT
          echo "scene_count=${SCENE_COUNT}" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Project setup complete:"
          echo "- Project Dir: ${PROJECT_DIR}"
          echo "- Topic: ${{ github.event.inputs.news_topic || 'ÊúÄÊñ∞AIÊäÄË°ì„ÅÆÈÄ≤Ê≠©' }}"
          echo "- Category: ${{ github.event.inputs.news_category || 'technology' }}"
          echo "- Duration: ${DURATION_SECONDS}s"
          echo "- Scene Count: ${SCENE_COUNT}"

  news-collection:
    needs: [check-trigger, setup]
    if: needs.check-trigger.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 8
    outputs:
      news_summary: ${{ steps.collect.outputs.news_summary }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Collect News Information
        id: collect
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          TOPIC="${{ needs.setup.outputs.news_topic }}"
          CATEGORY="${{ needs.setup.outputs.news_category }}"
          
          SEARCH_PROMPT="Collect news information:
          Topic: ${TOPIC}
          Category: ${CATEGORY}
          Requirements:
          1. Search for latest news using WebSearch tool
          2. Get recent articles using NewsAPI if available
          3. Compile 5-7 key points about the topic
          4. Save summary to ${{ needs.setup.outputs.project_dir }}/metadata/news_summary.json
          5. Include source URLs and credibility scores
          6. Verify save with ls -la ${{ needs.setup.outputs.project_dir }}/metadata/"
          
          npx @anthropic-ai/claude-code \
            --mcp-config ".claude/mcp-kamuicode.json" \
            --allowedTools "WebSearch,mcp__newsapi-*,Write,Bash" \
            --max-turns 40 \
            --permission-mode "bypassPermissions" \
            -p "$SEARCH_PROMPT" || {
              echo "‚ö†Ô∏è News collection failed, creating fallback summary"
              {
                echo '{'
                echo '  "topic": "'$TOPIC'",'
                echo '  "category": "'$CATEGORY'",'
                echo '  "key_points": ['
                echo '    "ÊúÄÊñ∞„ÅÆ'$TOPIC'„Å´Èñ¢„Åô„ÇãÈáçË¶Å„Å™Áô∫Â±ï",'
                echo '    "Ê•≠Áïå„Å∏„ÅÆÂΩ±Èüø„Å®‰ªäÂæå„ÅÆÂ±ïÊúõ",'
                echo '    "Â∞ÇÈñÄÂÆ∂„Å´„Çà„ÇãÂàÜÊûê„Å®Ë¶ãËß£",'
                echo '    "ÊäÄË°ìÁöÑ„Å™Ë©≥Á¥∞„Å®ÂøúÁî®ÂèØËÉΩÊÄß",'
                echo '    "Á§æ‰ºöÁöÑÊÑèÁæ©„Å®Ë™≤È°å"'
                echo '  ],'
                echo '  "sources": ["fallback"],'
                echo '  "credibility_score": 0.7'
                echo '}'
              } > "${{ needs.setup.outputs.project_dir }}/metadata/news_summary.json"
            }
          
          # Verify and read summary
          ls -la "${{ needs.setup.outputs.project_dir }}/metadata/"
          if [ -f "${{ needs.setup.outputs.project_dir }}/metadata/news_summary.json" ]; then
            # Try to extract key_points, but handle different JSON structures
            SUMMARY=$(cat "${{ needs.setup.outputs.project_dir }}/metadata/news_summary.json" | jq -r '
              if .key_points then
                .key_points | if type == "array" then join("; ") else . end
              elif .summary then
                .summary
              elif .content then
                .content
              else
                "AI technology latest developments and analysis"
              end' 2>/dev/null || echo "Latest ${TOPIC} developments")
            # Clean up the summary - remove newlines and ensure single line
            SUMMARY=$(echo "$SUMMARY" | tr '\n' ' ' | tr -s ' ')
            echo "news_summary<<EOF" >> $GITHUB_OUTPUT
            echo "$SUMMARY" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "‚úÖ News collection completed"
          else
            echo "news_summary<<EOF" >> $GITHUB_OUTPUT
            echo "Latest ${TOPIC} developments and industry impact" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Using fallback summary"
          fi

      - name: Upload News Data
        uses: actions/upload-artifact@v4
        with:
          name: news-data
          path: ${{ needs.setup.outputs.project_dir }}/metadata/

  script-creation:
    needs: [check-trigger, setup, news-collection]
    if: needs.check-trigger.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 8
    outputs:
      script_ready: ${{ steps.script.outputs.script_ready }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download News Data
        uses: actions/download-artifact@v4
        with:
          name: news-data
          path: ${{ needs.setup.outputs.project_dir }}/metadata/

      - name: Create News Script
        id: script
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          TOPIC="${{ needs.setup.outputs.news_topic }}"
          DURATION="${{ needs.setup.outputs.duration }}"
          SCENE_COUNT="${{ needs.setup.outputs.scene_count }}"
          
          SCRIPT_PROMPT="Create professional news script:
          Topic: ${TOPIC}
          Duration: ${DURATION} seconds
          Scene count: ${SCENE_COUNT}
          Structure: Introduction (0-3s hook) + Main content (3-${DURATION}s)
          Requirements:
          1. Read news summary from ${{ needs.setup.outputs.project_dir }}/metadata/news_summary.json
          2. Create engaging ${DURATION}-second news script
          3. Divide into ${SCENE_COUNT} scenes (5 seconds each)
          4. Include professional news anchor narration
          5. Save script to ${{ needs.setup.outputs.project_dir }}/metadata/news_script.json
          6. Include scene descriptions for visual generation
          7. Save narration text to ${{ needs.setup.outputs.project_dir }}/metadata/narration_text.txt
          8. Verify with ls -la"
          
          npx @anthropic-ai/claude-code \
            --allowedTools "Read,Write,Bash" \
            --max-turns 40 \
            --permission-mode "bypassPermissions" \
            -p "$SCRIPT_PROMPT" || {
              echo "‚ö†Ô∏è Script creation failed, creating fallback"
              
              # Create fallback script
              {
                echo '{'
                echo '  "title": "'$TOPIC'",'
                echo '  "total_duration": '$DURATION','
                echo '  "scene_count": '$SCENE_COUNT','
                echo '  "scenes": ['
                for i in $(seq 1 $SCENE_COUNT); do
                  if [ $i -eq 1 ]; then
                    echo '    {"scene": '$i', "duration": 5, "narration": "‰ªäÊó•„ÅÆ„Éã„É•„Éº„Çπ„Åß„Åô„ÄÇ'$TOPIC'„Å´„Å§„ÅÑ„Å¶ÊúÄÊñ∞„ÅÆÊÉÖÂ†±„Çí„Åä‰ºù„Åà„Åó„Åæ„Åô„ÄÇ", "visual": "News studio with professional anchor"}'
                  elif [ $i -eq $SCENE_COUNT ]; then
                    echo '    {"scene": '$i', "duration": 5, "narration": "‰ª•‰∏ä„ÄÅ'$TOPIC'„Å´Èñ¢„Åô„Çã„Éã„É•„Éº„Çπ„Åß„Åó„Åü„ÄÇ", "visual": "Professional news studio conclusion"}'
                  else
                    echo '    {"scene": '$i', "duration": 5, "narration": "'$TOPIC'„ÅÆË©≥Á¥∞„Å™ÂàÜÊûê„Å®ÂΩ±Èüø„Å´„Å§„ÅÑ„Å¶„ÄÇ", "visual": "News background with graphics"}'
                  fi
                  [ $i -lt $SCENE_COUNT ] && echo ','
                done
                echo '  ]'
                echo '}'
              } > "${{ needs.setup.outputs.project_dir }}/metadata/news_script.json"
              
              # Create narration text
              echo "‰ªäÊó•„ÅÆ„Éã„É•„Éº„Çπ„Åß„Åô„ÄÇ${TOPIC}„Å´„Å§„ÅÑ„Å¶ÊúÄÊñ∞„ÅÆÊÉÖÂ†±„Çí„Åä‰ºù„Åà„Åó„Åæ„Åô„ÄÇ${TOPIC}„ÅÆË©≥Á¥∞„Å™ÂàÜÊûê„Å®ÂΩ±Èüø„Å´„Å§„ÅÑ„Å¶Â∞ÇÈñÄÂÆ∂„ÅÆË¶ãËß£„Çí„ÅîÁ¥π‰ªã„Åó„Åæ„Åô„ÄÇ‰ª•‰∏ä„ÄÅ${TOPIC}„Å´Èñ¢„Åô„Çã„Éã„É•„Éº„Çπ„Åß„Åó„Åü„ÄÇ" > "${{ needs.setup.outputs.project_dir }}/metadata/narration_text.txt"
            }
          
          # Verify files
          ls -la "${{ needs.setup.outputs.project_dir }}/metadata/"
          
          if [ -f "${{ needs.setup.outputs.project_dir }}/metadata/news_script.json" ] && [ -f "${{ needs.setup.outputs.project_dir }}/metadata/narration_text.txt" ]; then
            echo "script_ready=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Script creation completed"
          else
            echo "script_ready=false" >> $GITHUB_OUTPUT
            echo "‚ùå Script creation failed"
          fi

      - name: Upload Script Data
        uses: actions/upload-artifact@v4
        with:
          name: script-data
          path: ${{ needs.setup.outputs.project_dir }}/metadata/

  narration-generation:
    needs: [check-trigger, setup, script-creation]
    if: needs.check-trigger.outputs.should_run == 'true' && needs.script-creation.outputs.script_ready == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 8
    outputs:
      narration_ready: ${{ steps.narration.outputs.narration_ready }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Script Data
        uses: actions/download-artifact@v4
        with:
          name: script-data
          path: ${{ needs.setup.outputs.project_dir }}/metadata/

      - name: Generate Narration Audio
        id: narration
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          mkdir -p "${{ needs.setup.outputs.project_dir }}/media/audio"
          
          # Read narration text
          if [ -f "${{ needs.setup.outputs.project_dir }}/metadata/narration_text.txt" ]; then
            NARRATION_TEXT=$(cat "${{ needs.setup.outputs.project_dir }}/metadata/narration_text.txt")
          else
            NARRATION_TEXT="‰ªäÊó•„ÅÆ„Éã„É•„Éº„Çπ„Åß„Åô„ÄÇ${{ needs.setup.outputs.news_topic }}„Å´„Å§„ÅÑ„Å¶ÊúÄÊñ∞„ÅÆÊÉÖÂ†±„Çí„Åä‰ºù„Åà„Åó„Åæ„Åô„ÄÇ"
          fi
          
          AUDIO_PATH="${{ needs.setup.outputs.project_dir }}/media/audio/narration.mp3"
          
          TTS_PROMPT="Generate professional Japanese news narration:
          Text: '${NARRATION_TEXT}'
          Voice: Professional Japanese female news anchor
          Output: ${AUDIO_PATH}
          Requirements:
          1. Use MCP TTS tool for high quality audio
          2. Professional news anchor voice style
          3. Clear pronunciation and appropriate pace
          4. Save to ${AUDIO_PATH} using Write tool
          5. Verify with ls -la ${{ needs.setup.outputs.project_dir }}/media/audio/"
          
          npx @anthropic-ai/claude-code \
            --mcp-config ".claude/mcp-kamuicode.json" \
            --allowedTools "mcp__t2s-*,Write,Bash" \
            --max-turns 40 \
            --permission-mode "bypassPermissions" \
            -p "$TTS_PROMPT" || {
              echo "‚ö†Ô∏è MCP TTS failed, using local fallback"
              
              # Install espeak-ng for fallback
              sudo apt-get update && sudo apt-get install -y espeak-ng
              
              # Generate fallback narration
              espeak-ng "$NARRATION_TEXT" -w "${AUDIO_PATH}" -s 150 -v ja || {
                echo "‚ö†Ô∏è Fallback TTS failed, using placeholder"
                # Create a short silence as placeholder
                ffmpeg -f lavfi -i anullsrc=duration=5 -ar 44100 -ac 2 "${AUDIO_PATH}" -y
              }
            }
          
          # Verify audio file
          ls -la "${{ needs.setup.outputs.project_dir }}/media/audio/"
          
          AUDIO_FILE=$(find "${{ needs.setup.outputs.project_dir }}/media/audio/" -name "*.mp3" -o -name "*.wav" 2>/dev/null | head -1)
          if [ -n "$AUDIO_FILE" ] && [ -f "$AUDIO_FILE" ]; then
            FILE_SIZE=$(stat -c%s "$AUDIO_FILE" 2>/dev/null || echo 0)
            if [ "$FILE_SIZE" -gt 1000 ]; then
              echo "narration_ready=true" >> $GITHUB_OUTPUT
              echo "‚úÖ Narration generated: $AUDIO_FILE ($FILE_SIZE bytes)"
            else
              echo "narration_ready=false" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è Narration file too small: $FILE_SIZE bytes"
            fi
          else
            echo "narration_ready=false" >> $GITHUB_OUTPUT
            echo "‚ùå Narration generation failed"
          fi

      - name: Upload Audio Data
        uses: actions/upload-artifact@v4
        with:
          name: audio-data
          path: ${{ needs.setup.outputs.project_dir }}/media/audio/

  anchor-generation:
    needs: [check-trigger, setup]
    if: needs.check-trigger.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 8
    outputs:
      anchor_ready: ${{ steps.anchor.outputs.anchor_ready }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install ImageMagick
        run: |
          sudo apt-get update
          sudo apt-get install -y imagemagick

      - name: Generate News Anchor
        id: anchor
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          mkdir -p "${{ needs.setup.outputs.project_dir }}/media/images"
          
          ANCHOR_PATH="${{ needs.setup.outputs.project_dir }}/media/images/news_anchor.png"
          URL_PATH="${{ needs.setup.outputs.project_dir }}/media/images/news_anchor-url.txt"
          
          ANCHOR_PROMPT="Generate professional Japanese news anchor:
          Description: Professional Japanese female news anchor, 30s, business suit, front-facing, green screen background, studio lighting, professional appearance
          Seed: 42 (for consistency)
          Output: ${ANCHOR_PATH}
          Requirements:
          1. Generate with MCP T2I tool (mcp__t2i-kamui-imagen3__imagen_t2i)
          2. Save image to ${ANCHOR_PATH} using Write tool
          3. Save Google Cloud URL to ${URL_PATH} using Write tool
          4. Execute ls -la ${{ needs.setup.outputs.project_dir }}/media/images/ using Bash tool"
          
          npx @anthropic-ai/claude-code \
            --mcp-config ".claude/mcp-kamuicode.json" \
            --allowedTools "mcp__t2i-*,Write,Bash" \
            --max-turns 40 \
            --permission-mode "bypassPermissions" \
            -p "$ANCHOR_PROMPT" || {
              echo "‚ö†Ô∏è Anchor generation failed, creating placeholder"
              # Create placeholder image
              convert -size 1920x1080 xc:green -pointsize 72 -fill white -gravity center -annotate +0+0 "News Anchor" "${ANCHOR_PATH}"
            }
          
          # Download from URL if available
          [ -f "$URL_PATH" ] && curl -L -o "$ANCHOR_PATH" "$(cat $URL_PATH)" 2>/dev/null
          
          # Validate anchor generation by checking URL file
          if [ -f "$URL_PATH" ]; then
            ANCHOR_URL=$(cat "$URL_PATH")
            if [ -n "$ANCHOR_URL" ]; then
              echo "anchor_ready=true" >> $GITHUB_OUTPUT
              echo "anchor_url=$ANCHOR_URL" >> $GITHUB_OUTPUT
              echo "‚úÖ Anchor generated successfully: $ANCHOR_URL"
            else
              echo "anchor_ready=false" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è Anchor URL file is empty"
            fi
          else
            echo "anchor_ready=false" >> $GITHUB_OUTPUT
            echo "‚ùå Anchor URL file not found"
          fi

      - name: Upload Anchor Data
        uses: actions/upload-artifact@v4
        with:
          name: anchor-data
          path: ${{ needs.setup.outputs.project_dir }}/media/images/

  background-generation:
    needs: [check-trigger, setup, script-creation]
    if: needs.check-trigger.outputs.should_run == 'true' && needs.script-creation.outputs.script_ready == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 12
    strategy:
      matrix:
        scene: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
      fail-fast: false
    continue-on-error: true
    outputs:
      failed_scenes: ${{ steps.collect-failures.outputs.failed_scenes }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Script Data
        uses: actions/download-artifact@v4
        with:
          name: script-data
          path: ${{ needs.setup.outputs.project_dir }}/metadata/

      - name: Install ImageMagick
        run: |
          sudo apt-get update
          sudo apt-get install -y imagemagick

      - name: Generate Background for Scene ${{ matrix.scene }}
        id: background
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          SCENE_NUM=${{ matrix.scene }}
          SCENE_COUNT=${{ needs.setup.outputs.scene_count }}
          
          # Skip if scene number exceeds calculated count  
          if [ $SCENE_NUM -gt $SCENE_COUNT ]; then
            echo "Skipping scene $SCENE_NUM (exceeds count $SCENE_COUNT)"
            # Mark as skipped, not failed
            echo "scene_${SCENE_NUM}_skipped=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          mkdir -p "${{ needs.setup.outputs.project_dir }}/media/images"
          
          # Extract scene description from script
          SCENE_DESC="Professional news studio background, no people, clean modern design"
          if [ -f "${{ needs.setup.outputs.project_dir }}/metadata/news_script.json" ]; then
            SCENE_DESC=$(jq -r ".scenes[$((SCENE_NUM-1))].visual // \"Professional news studio background\"" "${{ needs.setup.outputs.project_dir }}/metadata/news_script.json" 2>/dev/null || echo "Professional news studio background")
          fi
          
          BG_PATH="${{ needs.setup.outputs.project_dir }}/media/images/background_scene${SCENE_NUM}.png"
          URL_PATH="${{ needs.setup.outputs.project_dir }}/media/images/background_scene${SCENE_NUM}-url.txt"
          
          BACKGROUND_PROMPT="Generate news background for scene ${SCENE_NUM}:
          Description: ${SCENE_DESC}, no people, professional lighting, news studio style
          Style: ${{ github.event.inputs.visual_style || 'cinematic' }}
          Output: ${BG_PATH}
          Requirements:
          1. Generate with MCP T2I tool
          2. No human figures (background only)
          3. Professional news studio aesthetic
          4. Save to ${BG_PATH} using Write tool
          5. Save URL to ${URL_PATH} using Write tool
          6. Verify with ls -la"
          
          # Retry mechanism for MCP background generation
          RETRY_COUNT=0
          MAX_RETRIES=2
          SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$SUCCESS" = "false" ]; do
            echo "üîÑ Background generation attempt $((RETRY_COUNT + 1))/$MAX_RETRIES for scene $SCENE_NUM"
            
            if npx @anthropic-ai/claude-code \
              --mcp-config ".claude/mcp-kamuicode.json" \
              --allowedTools "mcp__t2i-*,Write,Bash" \
              --max-turns 40 \
              --permission-mode "bypassPermissions" \
              -p "$BACKGROUND_PROMPT"; then
              
              echo "‚úÖ Background generation command completed for scene $SCENE_NUM"
              SUCCESS=true
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "‚ö†Ô∏è Background generation attempt $RETRY_COUNT failed for scene $SCENE_NUM"
              
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "üîÑ Retrying with modified prompt..."
                BACKGROUND_PROMPT="Generate news background for scene ${SCENE_NUM} (retry):
                Description: ${SCENE_DESC}, no people, professional lighting, news studio style
                Style: professional newsroom
                Output: ${BG_PATH}
                Requirements:
                1. Generate with MCP T2I tool (different seed)
                2. No human figures (background only)
                3. Professional news studio aesthetic
                4. Save to ${BG_PATH} using Write tool
                5. Save URL to ${URL_PATH} using Write tool
                6. Verify with ls -la
                Note: This is retry attempt $((RETRY_COUNT + 1))"
                sleep 5  # Wait before retry
              fi
            fi
          done
          
          if [ "$SUCCESS" = "false" ]; then
            echo "‚ùå All background generation attempts failed for scene $SCENE_NUM"
            echo "scene_${SCENE_NUM}_failed=true" >> $GITHUB_OUTPUT
            # Don't exit 1 here - let continue-on-error handle it
          fi
          
          # Download from URL if available (with error handling)
          if [ -f "$URL_PATH" ]; then
            echo "üì• Downloading background image from URL for scene $SCENE_NUM"
            if curl -L -o "$BG_PATH" "$(cat "$URL_PATH")" 2>/dev/null; then
              echo "‚úÖ URL download successful"
            else
              echo "‚ö†Ô∏è URL download failed, using locally generated file"
            fi
          fi
          
          # Enhanced image verification with multiple patterns
          echo "üîç Verifying background image for scene $SCENE_NUM"
          BG_IMAGE=""
          
          # Try multiple search patterns
          BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*scene${SCENE_NUM}*.png" -type f 2>/dev/null | head -1)
          if [ -z "$BG_IMAGE" ]; then
            BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*background*.png" -mmin -2 2>/dev/null | head -1)
          fi
          if [ -z "$BG_IMAGE" ]; then
            BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*.png" -mmin -1 2>/dev/null | head -1)
          fi
          
          # Save original generation metadata for recovery
          echo "üìù Saving recovery metadata for scene $SCENE_NUM"
          echo "{" > "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "  \"scene\": ${SCENE_NUM}," >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "  \"item_type\": \"IMAGE\"," >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "  \"item_name\": \"background\"," >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "  \"original_prompt\": \"${SCENE_DESC}\"," >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "  \"mcp_tools\": [\"mcp__t2i-*\"]," >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "  \"fallback_method\": \"imagemagick\"," >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "  \"execution_time\": \"$(date -Iseconds)\"" >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "}" >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"

          # Validate found image
          VALIDATION_SUCCESS=false
          if [ -n "$BG_IMAGE" ] && [ -f "$BG_IMAGE" ]; then
            FILE_SIZE=$(stat -c%s "$BG_IMAGE" 2>/dev/null || echo 0)
            if [ "$FILE_SIZE" -gt 10000 ]; then
              echo "‚úÖ Background generated for scene $SCENE_NUM: $BG_IMAGE (${FILE_SIZE} bytes)"
              echo "scene_${SCENE_NUM}_background_status=SUCCESS" >> $GITHUB_OUTPUT
              echo "scene_${SCENE_NUM}_background_file=$BG_IMAGE" >> $GITHUB_OUTPUT
              VALIDATION_SUCCESS=true
            else
              echo "‚ö†Ô∏è Background file too small for scene $SCENE_NUM (${FILE_SIZE} bytes)"
              echo "scene_${SCENE_NUM}_background_status=FAILED" >> $GITHUB_OUTPUT
              echo "scene_${SCENE_NUM}_background_failed=file_too_small" >> $GITHUB_OUTPUT
              echo "scene_${SCENE_NUM}_background_file_size=${FILE_SIZE}" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ùå Background image not found for scene $SCENE_NUM"
            echo "scene_${SCENE_NUM}_background_status=FAILED" >> $GITHUB_OUTPUT
            echo "scene_${SCENE_NUM}_background_failed=file_not_found" >> $GITHUB_OUTPUT
          fi
          
          # Final status report
          if [ "$VALIDATION_SUCCESS" = "true" ]; then
            echo "üéØ Scene $SCENE_NUM background generation completed successfully"
          else
            echo "‚ö†Ô∏è Scene $SCENE_NUM background generation completed with issues (will be handled by recovery system)"
          fi
          
          # Always exit successfully (let continue-on-error and recovery handle failures)
          exit 0

      - name: Collect Failed Items
        id: collect-failures
        if: always()
        run: |
          FAILED_ITEMS="[]"
          FAILED_BACKGROUNDS=""
          
          # Check for status files instead of step outputs
          echo "üîç Checking background generation artifacts..."
          ls -la ${{ needs.setup.outputs.project_dir }}/all-backgrounds/ 2>/dev/null || echo "No background artifacts found"
          
          # Look for background status files
          for i in {1..12}; do
            if [ $i -le ${{ needs.setup.outputs.scene_count }} ]; then
              # Check if background image exists in artifacts
              BG_FOUND=false
              BG_REASON="unknown"
              
              # Check multiple potential locations
              POSSIBLE_PATHS=(
                "${{ needs.setup.outputs.project_dir }}/all-backgrounds/background-data-scene-${i}/background_scene${i}.png"
                "${{ needs.setup.outputs.project_dir }}/all-backgrounds/background-data-scene-${i}/scene${i}_background.png"
              )
              
              for path in "${POSSIBLE_PATHS[@]}"; do
                if [ -f "$path" ]; then
                  FILE_SIZE=$(stat -c%s "$path" 2>/dev/null || echo 0)
                  if [ "$FILE_SIZE" -gt 10000 ]; then  # Minimum 10KB for valid image
                    BG_FOUND=true
                    echo "‚úÖ Found valid background: scene $i ($FILE_SIZE bytes)"
                    break
                  else
                    BG_REASON="file_too_small"
                  fi
                fi
              done
              
              if [ "$BG_FOUND" = "false" ]; then
                echo "‚ùå Missing background: scene $i"
                
                # Add to failed backgrounds list
                if [ -z "$FAILED_BACKGROUNDS" ]; then
                  FAILED_BACKGROUNDS="$i"
                else
                  FAILED_BACKGROUNDS="$FAILED_BACKGROUNDS,$i"
                fi
                
                # Add to detailed failed items using simple string construction
                FAILED_ITEMS=$(echo "$FAILED_ITEMS" | jq --arg scene "$i" --arg reason "$BG_REASON" \
                  '. + [{"scene": ($scene | tonumber), "type": "IMAGE", "item": "background", "reason": $reason}]')
              fi
            fi
          done
          
          echo "failed_backgrounds=[${FAILED_BACKGROUNDS}]" >> $GITHUB_OUTPUT
          echo "failed_items=$FAILED_ITEMS" >> $GITHUB_OUTPUT
          
          # Legacy compatibility
          if [ -n "$FAILED_BACKGROUNDS" ]; then
            echo "failed_scenes=[${FAILED_BACKGROUNDS}]" >> $GITHUB_OUTPUT
          else
            echo "failed_scenes=[]" >> $GITHUB_OUTPUT
          fi

      - name: Upload Background Data
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: background-data-scene-${{ matrix.scene }}
          path: ${{ needs.setup.outputs.project_dir }}/media/images/

  collect-background-failures:
    needs: [check-trigger, setup, background-generation]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      failed_backgrounds: ${{ steps.collect.outputs.failed_backgrounds }}
      failed_background_items: ${{ steps.collect.outputs.failed_background_items }}
    steps:
      - name: Download All Background Status Files
        uses: actions/download-artifact@v4
        with:
          pattern: background-data-scene-*
          path: ${{ needs.setup.outputs.project_dir }}/all-backgrounds/

      - name: Collect Failed Backgrounds
        id: collect
        run: |
          FAILED_BACKGROUNDS=""
          FAILED_BACKGROUND_ITEMS="[]"
          
          echo "üîç Analyzing background generation results for ${{ needs.setup.outputs.scene_count }} scenes"
          
          # Check each scene's background using artifact-based verification (most reliable)
          for i in {1..12}; do
            if [ $i -le ${{ needs.setup.outputs.scene_count }} ]; then
              echo "üîç Checking scene $i background status..."
              
              # Look for background image files in artifact directories
              BACKGROUND_FOUND=false
              FILE_SIZE=0
              ACTUAL_BG_FILE=""
              
              # Multiple potential locations for background files
              POSSIBLE_PATHS=(
                "${{ needs.setup.outputs.project_dir }}/all-backgrounds/background-data-scene-${i}/media/images/scene${i}.png"
                "${{ needs.setup.outputs.project_dir }}/all-backgrounds/background-data-scene-${i}/scene${i}.png"
                "${{ needs.setup.outputs.project_dir }}/all-backgrounds/background-data-scene-${i}/scene${i}_background.png"
              )
              
              for path in "${POSSIBLE_PATHS[@]}"; do
                if [ -f "$path" ]; then
                  ACTUAL_BG_FILE="$path"
                  FILE_SIZE=$(stat -c%s "$path" 2>/dev/null || echo 0)
                  echo "üìÅ Found background file: $path (${FILE_SIZE} bytes)"
                  
                  # Validate image file (minimum 50KB for proper image)
                  if [ "$FILE_SIZE" -gt 50000 ]; then
                    # Additional validation: check if it's a valid image
                    if file "$path" | grep -E "(PNG|JPEG|JPG)" >/dev/null 2>&1; then
                      BACKGROUND_FOUND=true
                      echo "‚úÖ Valid background image for scene $i: ${FILE_SIZE} bytes"
                      break
                    else
                      echo "‚ùå Invalid image format for scene $i"
                    fi
                  else
                    echo "‚ùå Background file too small for scene $i: ${FILE_SIZE} bytes"
                  fi
                fi
              done
              
              # Mark as failed if no valid background found
              if [ "$BACKGROUND_FOUND" = "false" ]; then
                echo "‚ùå Scene $i background: FAILED (no valid image found)"
                
                # Add failed scene
                if [ -z "$FAILED_BACKGROUNDS" ]; then
                  FAILED_BACKGROUNDS="$i"
                else
                  FAILED_BACKGROUNDS="$FAILED_BACKGROUNDS,$i"
                fi
                
                # Add to detailed failed items
                FAILED_BACKGROUND_ITEMS=$(echo "$FAILED_BACKGROUND_ITEMS" | jq \
                  --arg scene "$i" \
                  --arg size "$FILE_SIZE" \
                  --arg file "$ACTUAL_BG_FILE" \
                  '. + [{"scene": ($scene | tonumber), "type": "IMAGE", "item": "background", "reason": "validation_failed", "file_size": ($size | tonumber), "file_path": $file}]')
              else
                echo "‚úÖ Scene $i background: SUCCESS"
              fi
            fi
          done
          
          if [ -n "$FAILED_BACKGROUNDS" ]; then
            echo "Failed backgrounds: [$FAILED_BACKGROUNDS]"
            echo "failed_backgrounds=[${FAILED_BACKGROUNDS}]" >> $GITHUB_OUTPUT
          else
            echo "No failed backgrounds"
            echo "failed_backgrounds=[]" >> $GITHUB_OUTPUT
          fi
          
          echo "failed_background_items=$FAILED_BACKGROUND_ITEMS" >> $GITHUB_OUTPUT
          echo "üìä Background failure details: $FAILED_BACKGROUND_ITEMS"

  background-recovery:
    needs: [check-trigger, setup, collect-background-failures]
    if: |
      always() && 
      needs.check-trigger.outputs.should_run == 'true' &&
      needs.collect-background-failures.outputs.failed_backgrounds != '' &&
      needs.collect-background-failures.outputs.failed_backgrounds != '[]'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    strategy:
      matrix:
        scene: ${{ fromJson(needs.collect-background-failures.outputs.failed_backgrounds || '[]') }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Original Metadata
        uses: actions/download-artifact@v4
        with:
          name: background-data-scene-${{ matrix.scene }}
          path: ${{ needs.setup.outputs.project_dir }}/

      - name: Dynamic Background Recovery for Scene ${{ matrix.scene }}
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          SCENE_NUM=${{ matrix.scene }}
          mkdir -p "${{ needs.setup.outputs.project_dir }}/media/images"
          
          # Load original metadata
          METADATA_FILE="${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          if [ -f "$METADATA_FILE" ]; then
            ORIGINAL_PROMPT=$(jq -r '.original_prompt' "$METADATA_FILE")
            echo "üìã Loaded original prompt: $ORIGINAL_PROMPT"
          else
            ORIGINAL_PROMPT="Professional news studio background, no people, clean modern design"
            echo "‚ö†Ô∏è No metadata found, using default prompt"
          fi
          
          BG_PATH="${{ needs.setup.outputs.project_dir }}/media/images/background_scene${SCENE_NUM}_recovery.png"
          
          # Check MCP availability
          WORKFLOW_START="${{ github.run_started_at }}"
          ELAPSED_MINUTES=$(( ($(date +%s) - $(date -d "$WORKFLOW_START" +%s)) / 60 ))
          
          if [ $ELAPSED_MINUTES -lt 12 ]; then
            echo "üîÑ MCP available, attempting AI recovery (${ELAPSED_MINUTES}min elapsed)"
            
            RECOVERY_PROMPT="RECOVERY: Background generation for scene ${SCENE_NUM}
            Original prompt: ${ORIGINAL_PROMPT}
            Modified approach: Enhanced with different seed and parameters
            Seed: $((100 + SCENE_NUM + RANDOM % 1000))
            Requirements:
            1. Generate high-quality professional news background
            2. Save to ${BG_PATH} using Write tool
            3. Ensure file size > 10KB
            4. Verify with ls -la command"
            
            npx @anthropic-ai/claude-code \
              --mcp-config ".claude/mcp-kamuicode.json" \
              --allowedTools "mcp__t2i-*,Write,Bash" \
              --max-turns 40 \
              -p "$RECOVERY_PROMPT" || {
                echo "‚ö†Ô∏è MCP recovery failed, using fallback"
                convert -size 1920x1080 gradient:blue-darkblue -pointsize 48 -fill white -gravity center \
                  -annotate +0+0 "News Scene $SCENE_NUM\n(Recovery)" "$BG_PATH"
              }
          else
            echo "‚è∞ MCP timeout, using ImageMagick fallback (${ELAPSED_MINUTES}min elapsed)"
            convert -size 1920x1080 gradient:navy-lightblue -pointsize 64 -fill white -gravity center \
              -annotate +0+0 "Professional News\nScene $SCENE_NUM" "$BG_PATH"
          fi
          
          # Verify recovery result
          if [ -f "$BG_PATH" ]; then
            FILE_SIZE=$(stat -c%s "$BG_PATH" 2>/dev/null || echo 0)
            if [ "$FILE_SIZE" -gt 10000 ]; then
              echo "‚úÖ Recovery successful: $BG_PATH ($FILE_SIZE bytes)"
              echo "recovery_scene_${SCENE_NUM}_status=SUCCESS" >> $GITHUB_OUTPUT
            else
              echo "‚ùå Recovery file too small: $FILE_SIZE bytes"
              echo "recovery_scene_${SCENE_NUM}_status=FAILED" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ùå Recovery file not created"
            echo "recovery_scene_${SCENE_NUM}_status=FAILED" >> $GITHUB_OUTPUT
          fi

      - name: Upload Recovery Data
        uses: actions/upload-artifact@v4
        with:
          name: background-recovery-scene-${{ matrix.scene }}
          path: ${{ needs.setup.outputs.project_dir }}/media/images/

  scene-video-generation:
    needs: [check-trigger, setup, background-generation, collect-background-failures, background-recovery]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      (needs.background-recovery.result == 'success' || needs.background-recovery.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 25
    strategy:
      matrix:
        scene: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
      fail-fast: false
      max-parallel: 8  # GitHub runnerÂà∂ÈôêÂØæÁ≠ñÔºöÂêåÊôÇÂÆüË°åÊï∞Âà∂Èôê
    continue-on-error: false  # Âé≥Ê†ºÂåñÔºöÂ§±Êïó„ÇíÈö†ËîΩ„Åó„Å™„ÅÑ
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install FFmpeg and Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq

      - name: Download Background Data
        uses: actions/download-artifact@v4
        with:
          name: background-data-scene-${{ matrix.scene }}
          path: ${{ needs.setup.outputs.project_dir }}/media/images/
        continue-on-error: true

      - name: Generate Video for Scene ${{ matrix.scene }}
        id: video
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          CLAUDE_CODE_MAX_OUTPUT_TOKENS: 16000
        run: |
          SCENE_NUM=${{ matrix.scene }}
          SCENE_COUNT=${{ needs.setup.outputs.scene_count }}
          
          # Skip if scene number exceeds calculated count
          if [ $SCENE_NUM -gt $SCENE_COUNT ]; then
            echo "Skipping video for scene $SCENE_NUM (exceeds count $SCENE_COUNT)"
            exit 0
          fi
          
          mkdir -p "${{ needs.setup.outputs.project_dir }}/media/videos"
          
          # Extract scene description from script for recovery metadata
          SCENE_DESC="Professional news studio background, no people, clean modern design"
          if [ -f "${{ needs.setup.outputs.project_dir }}/metadata/news_script.json" ]; then
            SCENE_DESC=$(jq -r ".scenes[$((SCENE_NUM-1))].visual // \"Professional news studio background\"" "${{ needs.setup.outputs.project_dir }}/metadata/news_script.json" 2>/dev/null || echo "Professional news studio background")
          fi
          
          # Find background image (multiple patterns)
          BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*scene${SCENE_NUM}*.png" -type f 2>/dev/null | head -1)
          [ -z "$BG_IMAGE" ] && BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*background*.png" -mmin -5 2>/dev/null | head -1)
          [ -z "$BG_IMAGE" ] && BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*.png" 2>/dev/null | head -1)
          
          if [ -z "$BG_IMAGE" ] || [ ! -f "$BG_IMAGE" ]; then
            echo "‚ö†Ô∏è No background image found for scene $SCENE_NUM, creating fallback"
            BG_IMAGE="${{ needs.setup.outputs.project_dir }}/media/images/fallback_scene${SCENE_NUM}.png"
            convert -size 1920x1080 gradient:darkblue-blue -pointsize 60 -fill white -gravity center -annotate +0+0 "News Scene $SCENE_NUM" "$BG_IMAGE"
          fi
          
          VIDEO_PATH="${{ needs.setup.outputs.project_dir }}/media/videos/scene${SCENE_NUM}.mp4"
          URL_PATH="${{ needs.setup.outputs.project_dir }}/media/videos/scene${SCENE_NUM}-url.txt"
          
          # üö® MCP Connection Time Check (Critical for I2V success)
          WORKFLOW_START="${{ github.run_started_at }}"
          ELAPSED_MINUTES=$(( ($(date +%s) - $(date -d "$WORKFLOW_START" +%s)) / 60 ))
          
          echo "‚è±Ô∏è Workflow elapsed time: ${ELAPSED_MINUTES} minutes"
          
          if [ $ELAPSED_MINUTES -lt 12 ]; then
            echo "‚úÖ MCP connection viable - attempting I2V generation"
            
            I2V_PROMPT="Convert background image to video for scene ${SCENE_NUM}:
            Input image: ${BG_IMAGE}
            Output video: ${VIDEO_PATH}
            Requirements:
            1. Convert image to 5-second video using MCP I2V tool (preferred: i2v-fal-hailuo-02-fast)
            2. Gentle camera movement suitable for news
            3. 1920x1080 resolution, 30fps
            4. Save video to ${VIDEO_PATH} using Write tool
            5. Save URL to ${URL_PATH} using Write tool
            6. Execute ls -la ${VIDEO_PATH} using Bash tool to verify file creation
            7. Execute ffprobe -v error -show_entries format=duration -of csv=p=0 ${VIDEO_PATH} using Bash tool to verify MP4 structure"
            
            timeout 300 npx @anthropic-ai/claude-code \
              --mcp-config ".claude/mcp-kamuicode.json" \
              --allowedTools "mcp__i2v-*,Write,Bash" \
              --max-turns 60 \
              --permission-mode "bypassPermissions" \
              -p "$I2V_PROMPT" && echo "‚úÖ MCP I2V completed" || {
                echo "‚ö†Ô∏è MCP I2V failed or timed out, using FFmpeg fallback"
                ffmpeg -loop 1 -i "$BG_IMAGE" -c:v libx264 -t 5 -pix_fmt yuv420p -r 30 "$VIDEO_PATH" -y
              }
          else
            echo "‚ö†Ô∏è MCP connection expired (${ELAPSED_MINUTES} min) - using FFmpeg fallback"
            ffmpeg -loop 1 -i "$BG_IMAGE" -c:v libx264 -t 5 -pix_fmt yuv420p -r 30 "$VIDEO_PATH" -y
          fi
          
          # Download from URL if available
          [ -f "$URL_PATH" ] && curl -L -o "$VIDEO_PATH" "$(cat $URL_PATH)" 2>/dev/null
          
          # Verify video
          VIDEO_FILE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*scene${SCENE_NUM}*.mp4" -type f 2>/dev/null | head -1)
          [ -z "$VIDEO_FILE" ] && VIDEO_FILE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*.mp4" -mmin -3 2>/dev/null | head -1)
          
          if [ -n "$VIDEO_FILE" ] && [ -f "$VIDEO_FILE" ]; then
            FILE_SIZE=$(stat -c%s "$VIDEO_FILE" 2>/dev/null || echo 0)
            
            # üö® ENHANCED VALIDATION: Comprehensive MP4 structure validation
            VALID_VIDEO=false
            VALIDATION_ERRORS=""
            
            # Check 1: File size validation (stricter threshold)
            if [ "$FILE_SIZE" -le 150000 ]; then
              VALIDATION_ERRORS="file_too_small:${FILE_SIZE}bytes"
              echo "‚ùå Video file too small for scene $SCENE_NUM: ${FILE_SIZE} bytes (minimum: 150KB)"
            else
              echo "‚úÖ Size check passed: ${FILE_SIZE} bytes"
              
              # Check 2: MP4 structure validation with ffprobe
              if ! ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" >/dev/null 2>&1; then
                VALIDATION_ERRORS="corrupted_mp4:no_moov_atom"
                echo "‚ùå Video file corrupted (missing moov atom) for scene $SCENE_NUM"
              else
                echo "‚úÖ MP4 structure check passed"
                
                # Check 3: Duration validation
                DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" 2>/dev/null || echo "0")
                if ! python3 -c "import sys; sys.exit(0 if float('$DURATION') >= 3.0 else 1)" 2>/dev/null; then
                  VALIDATION_ERRORS="duration_too_short:${DURATION}s"
                  echo "‚ùå Video too short for scene $SCENE_NUM: ${DURATION}s (minimum: 3.0s)"
                else
                  echo "‚úÖ Duration check passed: ${DURATION}s"
                  
                  # Check 4: Video stream validation
                  if ! ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0 "$VIDEO_FILE" >/dev/null 2>&1; then
                    VALIDATION_ERRORS="no_video_stream"
                    echo "‚ùå No valid video stream found in scene $SCENE_NUM"
                  else
                    echo "‚úÖ Video stream check passed"
                    VALID_VIDEO=true
                    echo "üéâ ALL VALIDATIONS PASSED for scene $SCENE_NUM: $VIDEO_FILE (${FILE_SIZE} bytes, ${DURATION}s)"
                  fi
                fi
              fi
            fi
            
            # üö® CRITICAL: Strict Recovery System - No tolerance for failure
            if [ "$VALID_VIDEO" = "false" ]; then
              echo "üö® CRITICAL: Video validation failed for scene $SCENE_NUM: $VALIDATION_ERRORS"
              echo "üîß Initiating strict multi-level recovery process..."
              
              RECOVERY_SUCCESS=false
              
              # Recovery Level 1: Different MCP service retry (if time permits)
              if [ $ELAPSED_MINUTES -lt 10 ]; then
                echo "üîÑ Recovery Level 1: MCP retry with different service"
                RECOVERY_SEED=$((RANDOM + SCENE_NUM * 1000))
                
                # Try alternative I2V service
                RECOVERY_PROMPT="EMERGENCY RECOVERY Scene ${SCENE_NUM}:
                1. Generate 5-second video from $BG_IMAGE using different algorithm
                2. MANDATORY: Save to exact path: ${VIDEO_PATH}
                3. MANDATORY: Ensure file size >200KB and duration >4s
                4. MANDATORY: Use seed ${RECOVERY_SEED} for different result
                5. Execute ffprobe validation immediately after generation"
                
                timeout 180 npx @anthropic-ai/claude-code \
                  --mcp-config ".claude/mcp-kamuicode.json" \
                  --allowedTools "mcp__i2v-*,Write,Bash" \
                  --max-turns 30 \
                  --permission-mode "bypassPermissions" \
                  -p "$RECOVERY_PROMPT" 2>/dev/null && {
                    # Immediate re-validation
                    if [ -f "$VIDEO_FILE" ]; then
                      NEW_SIZE=$(stat -c%s "$VIDEO_FILE" 2>/dev/null || echo 0)
                      if [ "$NEW_SIZE" -gt 200000 ] && ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" >/dev/null 2>&1; then
                        NEW_DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" 2>/dev/null || echo "0")
                        if python3 -c "import sys; sys.exit(0 if float('$NEW_DURATION') >= 4.0 else 1)" 2>/dev/null; then
                          echo "‚úÖ Recovery Level 1 SUCCESS: Scene $SCENE_NUM recovered via MCP retry"
                          RECOVERY_SUCCESS=true
                        fi
                      fi
                    fi
                  }
              fi
              
              # Recovery Level 2: Enhanced FFmpeg fallback (if Level 1 failed)
              if [ "$RECOVERY_SUCCESS" = "false" ]; then
                echo "üîÑ Recovery Level 2: Enhanced FFmpeg fallback with narration"
                
                # Create high-quality fallback with scene information
                ffmpeg -loop 1 -i "$BG_IMAGE" \
                  -f lavfi -i sine=frequency=440:duration=5 \
                  -filter_complex "[0:v]scale=1920:1080,drawtext=text='Scene ${SCENE_NUM}':fontsize=72:fontcolor=white:x=(w-text_w)/2:y=(h-text_h)/2:box=1:boxcolor=black@0.5[v]" \
                  -map "[v]" -map "1:a" \
                  -c:v libx264 -c:a aac -t 5 -pix_fmt yuv420p -r 30 \
                  -shortest "$VIDEO_FILE" -y
                
                # Immediate validation of Level 2 fallback
                if [ -f "$VIDEO_FILE" ]; then
                  FALLBACK_SIZE=$(stat -c%s "$VIDEO_FILE" 2>/dev/null || echo 0)
                  if [ "$FALLBACK_SIZE" -gt 150000 ] && ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" >/dev/null 2>&1; then
                    FALLBACK_DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" 2>/dev/null || echo "0")
                    if python3 -c "import sys; sys.exit(0 if float('$FALLBACK_DURATION') >= 4.5 else 1)" 2>/dev/null; then
                      echo "‚úÖ Recovery Level 2 SUCCESS: Scene $SCENE_NUM recovered via FFmpeg fallback"
                      RECOVERY_SUCCESS=true
                    fi
                  fi
                fi
              fi
              
              # üö® CRITICAL: Final recovery validation and termination check
              if [ "$RECOVERY_SUCCESS" = "true" ]; then
                echo "üéâ Recovery SUCCESS for scene $SCENE_NUM - continuing workflow"
                VALID_VIDEO=true
              else
                echo "üö® CRITICAL FAILURE: All recovery attempts failed for scene $SCENE_NUM"
                echo "‚ùå Recovery Level 1 (MCP retry): FAILED"
                echo "‚ùå Recovery Level 2 (FFmpeg fallback): FAILED"
                echo "üõë TERMINATING WORKFLOW - Scene generation failure is not acceptable"
                echo ""
                echo "Error Details:"
                echo "- Original validation error: $VALIDATION_ERRORS"
                echo "- Recovery attempts: 2 levels attempted"
                echo "- Scene: $SCENE_NUM"
                echo "- Time elapsed: ${ELAPSED_MINUTES} minutes"
                echo ""
                echo "üö® WORKFLOW MUST BE TERMINATED - Cannot proceed with incomplete content"
                exit 1  # Force workflow termination
              fi
            fi
            
            # Final success validation
            if [ "$VALID_VIDEO" = "true" ]; then
              echo "scene_${SCENE_NUM}_video_status=SUCCESS" >> $GITHUB_OUTPUT
              echo "scene_${SCENE_NUM}_video_success=true" >> $GITHUB_OUTPUT
              echo "‚úÖ Scene $SCENE_NUM video generation CONFIRMED SUCCESSFUL"
            else
              echo "scene_${SCENE_NUM}_video_status=FAILED" >> $GITHUB_OUTPUT
              
              # Use validation errors from enhanced validation
              FAILURE_REASON="validation_failed"
              if [ -n "$VALIDATION_ERRORS" ]; then
                FAILURE_REASON="$VALIDATION_ERRORS"
              fi
              
              echo "scene_${SCENE_NUM}_video_failed=$FAILURE_REASON" >> $GITHUB_OUTPUT
              
              # Save enhanced recovery metadata
              METADATA_FILE="${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_video.json"
              echo "{" > "$METADATA_FILE"
              echo "  \"scene\": $SCENE_NUM," >> "$METADATA_FILE"
              echo "  \"item_type\": \"VIDEO\"," >> "$METADATA_FILE"
              echo "  \"item_name\": \"scene_video\"," >> "$METADATA_FILE"
              echo "  \"original_prompt\": \"$(echo "$SCENE_DESC" | sed 's/"/\\"/g')\"," >> "$METADATA_FILE"
              echo "  \"background_image\": \"$(echo "$BG_IMAGE" | sed 's/"/\\"/g')\"," >> "$METADATA_FILE"
              echo "  \"mcp_tools\": [\"mcp__i2v-fal-hailuo-02-fast\", \"mcp__i2v-fal-bytedance-seedance-v1-lite\"]," >> "$METADATA_FILE"
              echo "  \"fallback_method\": \"ffmpeg_enhanced\"," >> "$METADATA_FILE"
              echo "  \"generation_time\": \"$(date -Iseconds)\"," >> "$METADATA_FILE"
              echo "  \"workflow_elapsed_minutes\": $ELAPSED_MINUTES," >> "$METADATA_FILE"
              echo "  \"failure_reason\": \"$FAILURE_REASON\"," >> "$METADATA_FILE"
              echo "  \"file_size\": $FILE_SIZE," >> "$METADATA_FILE"
              echo "  \"validation_errors\": \"$VALIDATION_ERRORS\"," >> "$METADATA_FILE"
              echo "  \"validation_details\": \"Comprehensive MP4 validation: size+structure+duration+stream\"" >> "$METADATA_FILE"
              echo "}" >> "$METADATA_FILE"
            fi
          else
            echo "‚ùå Video generation failed for scene $SCENE_NUM"
            echo "scene_${SCENE_NUM}_video_status=FAILED" >> $GITHUB_OUTPUT
            echo "scene_${SCENE_NUM}_video_failed=file_not_found" >> $GITHUB_OUTPUT
            
            # Save recovery metadata for video regeneration
            METADATA_FILE="${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_video.json"
            echo "{" > "$METADATA_FILE"
            echo "  \"scene\": $SCENE_NUM," >> "$METADATA_FILE"
            echo "  \"item_type\": \"VIDEO\"," >> "$METADATA_FILE"
            echo "  \"item_name\": \"scene_video\"," >> "$METADATA_FILE"
            echo "  \"original_prompt\": \"$(echo "$SCENE_DESC" | sed 's/"/\\"/g')\"," >> "$METADATA_FILE"
            echo "  \"background_image\": \"$(echo "$BG_IMAGE" | sed 's/"/\\"/g')\"," >> "$METADATA_FILE"
            echo "  \"mcp_tools\": [\"mcp__i2v-*\"]," >> "$METADATA_FILE"
            echo "  \"fallback_method\": \"ffmpeg\"," >> "$METADATA_FILE"
            echo "  \"generation_time\": \"$(date -Iseconds)\"," >> "$METADATA_FILE"
            echo "  \"failure_reason\": \"file_not_found\"" >> "$METADATA_FILE"
            echo "}" >> "$METADATA_FILE"
          fi
          
          # Always exit successfully (let continue-on-error and status checks handle failures)
          echo "üéØ Scene $SCENE_NUM video generation step completed"
          exit 0

      - name: Save Video Generation Status
        if: always()
        run: |
          SCENE_NUM=${{ matrix.scene }}
          # Create directory if it doesn't exist
          mkdir -p "${{ needs.setup.outputs.project_dir }}"
          STATUS_FILE="${{ needs.setup.outputs.project_dir }}/video-status-scene${SCENE_NUM}.txt"
          
          # Check if this scene failed by looking for the video file
          VIDEO_FILE="${{ needs.setup.outputs.project_dir }}/media/videos/scene${SCENE_NUM}.mp4"
          
          if [ -f "$VIDEO_FILE" ]; then
            FILE_SIZE=$(stat -c%s "$VIDEO_FILE" 2>/dev/null || echo 0)
            
            # Enhanced validation matching the main validation
            VALID_VIDEO=false
            if [ "$FILE_SIZE" -gt 100000 ]; then
              if ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" >/dev/null 2>&1; then
                DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" 2>/dev/null || echo "0")
                if python3 -c "import sys; sys.exit(0 if float('$DURATION') >= 3.0 else 1)" 2>/dev/null; then
                  VALID_VIDEO=true
                fi
              fi
            fi
            
            if [ "$VALID_VIDEO" = "true" ]; then
              echo "SUCCESS" > "$STATUS_FILE"
              echo "Scene $SCENE_NUM video generation SUCCESS (size: $FILE_SIZE, duration: ${DURATION}s)"
            else
              echo "FAILED" > "$STATUS_FILE"
              echo "Scene $SCENE_NUM video generation FAILED (validation failed: size=$FILE_SIZE)"
            fi
          else
            echo "FAILED" > "$STATUS_FILE"
            echo "Scene $SCENE_NUM video generation FAILED (no file found)"
          fi

      - name: Upload Video Data
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: video-data-scene-${{ matrix.scene }}
          path: |
            ${{ needs.setup.outputs.project_dir }}/media/videos/
            ${{ needs.setup.outputs.project_dir }}/video-status-scene${{ matrix.scene }}.txt

  lipsync-processing:
    needs: [check-trigger, setup, anchor-generation, narration-generation]
    if: |
      needs.check-trigger.outputs.should_run == 'true' &&
      needs.anchor-generation.outputs.anchor_ready == 'true' &&
      needs.narration-generation.outputs.narration_ready == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 12
    outputs:
      lipsync_ready: ${{ steps.lipsync.outputs.lipsync_ready }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Anchor and Audio Data
        uses: actions/download-artifact@v4
        with:
          name: anchor-data
          path: ${{ needs.setup.outputs.project_dir }}/media/images/

      - name: Download Audio Data
        uses: actions/download-artifact@v4
        with:
          name: audio-data
          path: ${{ needs.setup.outputs.project_dir }}/media/audio/

      - name: Generate Lipsync Video
        id: lipsync
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          mkdir -p "${{ needs.setup.outputs.project_dir }}/media/videos"
          
          # Find anchor image and audio file
          ANCHOR_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*anchor*.png" -type f 2>/dev/null | head -1)
          AUDIO_FILE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*.mp3" -o -name "*.wav" 2>/dev/null | head -1)
          
          if [ -z "$ANCHOR_IMAGE" ] || [ -z "$AUDIO_FILE" ]; then
            echo "‚ùå Missing anchor image or audio file"
            echo "lipsync_ready=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          LIPSYNC_PATH="${{ needs.setup.outputs.project_dir }}/media/videos/anchor_lipsync.mp4"
          
          LIPSYNC_PROMPT="Create lipsync video:
          Image: ${ANCHOR_IMAGE}
          Audio: ${AUDIO_FILE}
          Output: ${LIPSYNC_PATH}
          Requirements:
          1. Generate lipsync video using MCP lipsync tool
          2. High quality lip synchronization
          3. Professional news anchor appearance
          4. Save to ${LIPSYNC_PATH} using Write tool
          5. Verify with ls -la"
          
          npx @anthropic-ai/claude-code \
            --mcp-config ".claude/mcp-kamuicode.json" \
            --allowedTools "mcp__v2v-*lipsync*,Write,Bash" \
            --max-turns 80 \
            --permission-mode "bypassPermissions" \
            -p "$LIPSYNC_PROMPT" || {
              echo "‚ö†Ô∏è Lipsync failed, creating fallback video"
              # Create fallback: static anchor image with audio
              ffmpeg -loop 1 -i "$ANCHOR_IMAGE" -i "$AUDIO_FILE" -c:v libx264 -c:a aac -shortest -pix_fmt yuv420p "$LIPSYNC_PATH" -y
            }
          
          # Verify lipsync video
          LIPSYNC_VIDEO=$(find "${{ needs.setup.outputs.project_dir }}" -name "*lipsync*.mp4" -type f 2>/dev/null | head -1)
          [ -z "$LIPSYNC_VIDEO" ] && LIPSYNC_VIDEO=$(find "${{ needs.setup.outputs.project_dir }}" -name "*anchor*.mp4" -mmin -5 2>/dev/null | head -1)
          
          if [ -n "$LIPSYNC_VIDEO" ] && [ -f "$LIPSYNC_VIDEO" ]; then
            FILE_SIZE=$(stat -c%s "$LIPSYNC_VIDEO" 2>/dev/null || echo 0)
            if [ "$FILE_SIZE" -gt 500000 ]; then
              echo "lipsync_ready=true" >> $GITHUB_OUTPUT
              echo "‚úÖ Lipsync video generated: $LIPSYNC_VIDEO"
            else
              echo "lipsync_ready=false" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è Lipsync video too small: $FILE_SIZE bytes"
            fi
          else
            echo "lipsync_ready=false" >> $GITHUB_OUTPUT
            echo "‚ùå Lipsync generation failed"
          fi

      - name: Upload Lipsync Data
        uses: actions/upload-artifact@v4
        with:
          name: lipsync-data
          path: ${{ needs.setup.outputs.project_dir }}/media/videos/

  collect-video-failures:
    needs: [check-trigger, setup, scene-video-generation]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      !cancelled()
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      failed_videos: ${{ steps.collect.outputs.failed_videos }}
      failed_video_items: ${{ steps.collect.outputs.failed_video_items }}
    steps:
      - name: Download All Video Status Files
        uses: actions/download-artifact@v4
        with:
          pattern: video-data-scene-*
          path: ${{ needs.setup.outputs.project_dir }}/all-videos/

      - name: Install FFmpeg and Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq

      - name: Collect Failed Videos
        id: collect
        run: |
          FAILED_VIDEOS=""
          FAILED_VIDEO_ITEMS="[]"
          
          echo "üîç Analyzing video generation results for ${{ needs.setup.outputs.scene_count }} scenes"
          
          # Check each scene's status using artifact-based verification (most reliable)
          for i in {1..12}; do
            if [ $i -le ${{ needs.setup.outputs.scene_count }} ]; then
              echo "üîç Checking scene $i video status..."
              
              # Look for video files in artifact directories
              VIDEO_FOUND=false
              FILE_SIZE=0
              ACTUAL_VIDEO_FILE=""
              
              # Multiple potential locations for video files
              POSSIBLE_PATHS=(
                "${{ needs.setup.outputs.project_dir }}/all-videos/video-data-scene-${i}/media/videos/scene${i}.mp4"
                "${{ needs.setup.outputs.project_dir }}/all-videos/video-data-scene-${i}/scene${i}.mp4"
                "${{ needs.setup.outputs.project_dir }}/all-videos/video-data-scene-${i}/scene${i}_video.mp4"
              )
              
              for path in "${POSSIBLE_PATHS[@]}"; do
                if [ -f "$path" ]; then
                  ACTUAL_VIDEO_FILE="$path"
                  FILE_SIZE=$(stat -c%s "$path" 2>/dev/null || echo 0)
                  VIDEO_FOUND=true
                  echo "üìÅ Found video: $path (${FILE_SIZE} bytes)"
                  break
                fi
              done
              
              # üö® MANDATORY MP4 structure validation (no fallback to size-only)
              VIDEO_REASON=""
              if [ "$VIDEO_FOUND" = "true" ] && [ "$FILE_SIZE" -gt 100000 ]; then
                # CRITICAL: Always validate MP4 structure - no exceptions
                if ffprobe -v error -show_entries format=duration -of csv=p=0 "$ACTUAL_VIDEO_FILE" >/dev/null 2>&1; then
                  DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$ACTUAL_VIDEO_FILE" 2>/dev/null || echo "0")
                  # Use python for floating point comparison (more reliable than bc)
                  if python3 -c "import sys; sys.exit(0 if float('$DURATION') >= 3.0 else 1)" 2>/dev/null; then
                    echo "‚úÖ Scene $i: Video validated (${FILE_SIZE} bytes, ${DURATION}s)"
                    continue  # Skip to next scene - this one is successful
                  else
                    echo "‚ö†Ô∏è Scene $i: Video too short (${DURATION}s)"
                    VIDEO_REASON="duration_too_short"
                  fi
                else
                  echo "‚ö†Ô∏è Scene $i: Video corrupted (no moov atom)"
                  VIDEO_REASON="corrupted_mp4"
                fi
              elif [ "$VIDEO_FOUND" = "true" ]; then
                echo "‚ö†Ô∏è Scene $i: Video file too small (${FILE_SIZE} bytes)"
                VIDEO_REASON="file_too_small"
              else
                echo "‚ùå Scene $i: No video file found"
                VIDEO_REASON="file_not_found"
              fi
              
              # Add failed scene to list
              if [ -z "$FAILED_VIDEOS" ]; then
                FAILED_VIDEOS="$i"
              else
                FAILED_VIDEOS="$FAILED_VIDEOS,$i"
              fi
              
              # Add to detailed failed items
              FAILED_VIDEO_ITEMS=$(echo "$FAILED_VIDEO_ITEMS" | jq --arg scene "$i" --arg reason "$VIDEO_REASON" \
                '. + [{"scene": ($scene | tonumber), "type": "VIDEO", "item": "scene_video", "reason": $reason}]')
              
              echo "‚ùå Scene $i video: FAILED ($VIDEO_REASON)"
            fi
          done
          
          if [ -n "$FAILED_VIDEOS" ]; then
            echo "Failed videos: [$FAILED_VIDEOS]"
            echo "failed_videos=[${FAILED_VIDEOS}]" >> $GITHUB_OUTPUT
          else
            echo "No failed videos"
            echo "failed_videos=[]" >> $GITHUB_OUTPUT
          fi
          
          # Store failed video items safely (avoid jq dependency)
          echo "failed_video_items<<EOF" >> $GITHUB_OUTPUT
          echo "$FAILED_VIDEO_ITEMS" >> $GITHUB_OUTPUT  
          echo "EOF" >> $GITHUB_OUTPUT
          echo "üìä Video failure details: $FAILED_VIDEO_ITEMS"


  unified-failure-analysis:
    needs: [check-trigger, setup, collect-background-failures, scene-video-generation, collect-video-failures, background-recovery]
    if: always() && needs.check-trigger.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      all_failed_items: ${{ steps.analyze.outputs.all_failed_items }}
      recovery_summary: ${{ steps.analyze.outputs.recovery_summary }}
      items_complete: ${{ steps.analyze.outputs.items_complete }}
    steps:
      - name: Unified Failure Analysis
        id: analyze
        run: |
          echo "üîç Performing unified failure analysis across all item types"
          
          # Collect failed backgrounds (ensure proper JSON format)
          BACKGROUND_FAILURES='${{ needs.collect-background-failures.outputs.failed_background_items }}'
          if [ "$BACKGROUND_FAILURES" = "" ] || [ "$BACKGROUND_FAILURES" = "null" ]; then
            BACKGROUND_FAILURES="[]"
          fi
          echo "üìä Background failures: $BACKGROUND_FAILURES"
          
          # Collect failed videos (ensure proper JSON format)
          VIDEO_FAILURES='${{ needs.collect-video-failures.outputs.failed_video_items }}'
          if [ "$VIDEO_FAILURES" = "" ] || [ "$VIDEO_FAILURES" = "null" ]; then
            VIDEO_FAILURES="[]"
          fi
          echo "üìä Video failures: $VIDEO_FAILURES"
          
          # Merge all failure types
          ALL_FAILED_ITEMS=$(echo '[]' | jq \
            --argjson bg_failures "$BACKGROUND_FAILURES" \
            --argjson video_failures "$VIDEO_FAILURES" \
            '. + $bg_failures + $video_failures')
          
          echo "üìà Combined failure analysis:"
          echo "$ALL_FAILED_ITEMS" | jq '.'
          
          # Create recovery summary
          TOTAL_FAILED=$(echo "$ALL_FAILED_ITEMS" | jq 'length')
          IMAGE_FAILED=$(echo "$ALL_FAILED_ITEMS" | jq '[.[] | select(.type == "IMAGE")] | length')
          VIDEO_FAILED=$(echo "$ALL_FAILED_ITEMS" | jq '[.[] | select(.type == "VIDEO")] | length')
          
          RECOVERY_SUMMARY=$(jq -n \
            --arg total "$TOTAL_FAILED" \
            --arg images "$IMAGE_FAILED" \
            --arg videos "$VIDEO_FAILED" \
            '{total_failed_items: ($total | tonumber), failed_by_type: {IMAGE: ($images | tonumber), VIDEO: ($videos | tonumber)}, recovery_attempted: true, analysis_timestamp: (now | todate)}' | jq -c)
          
          echo "üìã Recovery summary: $RECOVERY_SUMMARY"
          
          # Determine if all items are complete (no failures remaining)
          if [ "$TOTAL_FAILED" = "0" ]; then
            ITEMS_COMPLETE="true"
            echo "‚úÖ All items generated successfully - ready for next phase"
          else
            ITEMS_COMPLETE="false"
            echo "‚ö†Ô∏è $TOTAL_FAILED items still have issues after recovery"
          fi
          
          # Set outputs with proper JSON handling
          echo "all_failed_items<<EOF" >> $GITHUB_OUTPUT
          echo "$ALL_FAILED_ITEMS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "recovery_summary<<EOF" >> $GITHUB_OUTPUT
          echo "$RECOVERY_SUMMARY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "items_complete=$ITEMS_COMPLETE" >> $GITHUB_OUTPUT
          
          # GitHub Step Summary
          echo "## üîÑ Recovery System Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item Type | Failed | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|---------|" >> $GITHUB_STEP_SUMMARY
          echo "| Images | $IMAGE_FAILED | Recovery attempted |" >> $GITHUB_STEP_SUMMARY
          echo "| Videos | $VIDEO_FAILED | Recovery attempted |" >> $GITHUB_STEP_SUMMARY
          echo "| **Total** | **$TOTAL_FAILED** | All recoveries complete |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "$ITEMS_COMPLETE" = "true" ]; then
            echo "‚úÖ **Status:** All items ready for final composition" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è **Status:** Some items may need manual review" >> $GITHUB_STEP_SUMMARY
          fi

  editing-plan:
    needs: [check-trigger, setup, scene-video-generation, lipsync-processing, unified-failure-analysis]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      needs.unified-failure-analysis.outputs.items_complete == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 8
    outputs:
      plan_ready: ${{ steps.plan.outputs.plan_ready }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download All Media Assets
        uses: actions/download-artifact@v4
        with:
          pattern: "*-data*"
          path: ${{ needs.setup.outputs.project_dir }}/media/
          merge-multiple: true

      - name: Create Editing Plan
        id: plan
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          mkdir -p "${{ needs.setup.outputs.project_dir }}/metadata"
          
          PLAN_PROMPT="Analyze all generated media and create editing plan:
          Directory: ${{ needs.setup.outputs.project_dir }}/media/
          Duration: ${{ needs.setup.outputs.duration }} seconds
          Scenes: ${{ needs.setup.outputs.scene_count }}
          Requirements:
          1. List all available video, image, and audio files
          2. Create optimal editing sequence
          3. Plan picture-in-picture layout for anchor overlay
          4. Specify timing and transitions
          5. Save plan to ${{ needs.setup.outputs.project_dir }}/metadata/editing_plan.json
          6. Include FFmpeg command suggestions"
          
          npx @anthropic-ai/claude-code \
            --allowedTools "Bash,Read,Write" \
            --max-turns 40 \
            --permission-mode "bypassPermissions" \
            -p "$PLAN_PROMPT" || {
              echo "‚ö†Ô∏è Creating fallback editing plan"
              {
                echo '{'
                echo '  "duration": '${{ needs.setup.outputs.duration }}','
                echo '  "scenes": '${{ needs.setup.outputs.scene_count }}','
                echo '  "layout": "picture_in_picture",'
                echo '  "anchor_position": "bottom_right",'
                echo '  "anchor_size": "25%",'
                echo '  "transition": "fade",'
                echo '  "audio_mix": {"narration": -3, "bgm": -18}'
                echo '}'
              } > "${{ needs.setup.outputs.project_dir }}/metadata/editing_plan.json"
            }
          
          if [ -f "${{ needs.setup.outputs.project_dir }}/metadata/editing_plan.json" ]; then
            echo "plan_ready=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Editing plan created"
          else
            echo "plan_ready=false" >> $GITHUB_OUTPUT
            echo "‚ùå Editing plan creation failed"
          fi

      - name: Upload Plan Data
        uses: actions/upload-artifact@v4
        with:
          name: plan-data
          path: ${{ needs.setup.outputs.project_dir }}/metadata/

  dynamic-recovery-check:
    needs: [check-trigger, setup, scene-video-generation, lipsync-processing, collect-video-failures, unified-failure-analysis]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      needs.unified-failure-analysis.outputs.items_complete == 'false'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      recovery_needed: ${{ steps.validate.outputs.recovery_needed }}
      corrupted_scenes: ${{ steps.validate.outputs.corrupted_scenes }}
      corrupted_lipsync: ${{ steps.validate.outputs.corrupted_lipsync }}
      valid_scene_count: ${{ steps.validate.outputs.valid_scene_count }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download All Assets
        uses: actions/download-artifact@v4
        with:
          pattern: "*-data*"
          path: ${{ needs.setup.outputs.project_dir }}/
          merge-multiple: true

      - name: Install FFmpeg and Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq

      - name: Validate All Generated Content
        id: validate
        run: |
          echo "üîç ÂãïÁöÑ„Ç≥„É≥„ÉÜ„É≥„ÉÑÊ§úË®º„ÇíÈñãÂßã..."
          
          CORRUPTED_SCENES=""
          CORRUPTED_LIPSYNC=""
          VALID_SCENE_COUNT=0
          RECOVERY_NEEDED=false
          
          # „Ç∑„Éº„É≥ÂãïÁîª„ÅÆÊ§úË®º
          echo "üìπ „Ç∑„Éº„É≥ÂãïÁîª„ÅÆÊ§úË®º‰∏≠..."
          for scene_num in {1..12}; do
            video_file=$(find "${{ needs.setup.outputs.project_dir }}" -name "*scene${scene_num}*.mp4" -type f | head -1)
            
            if [ -f "$video_file" ]; then
              FILE_SIZE=$(stat -c%s "$video_file" 2>/dev/null || echo 0)
              
              # MP4ÊßãÈÄ†Ê§úË®ºÔºàscene-video-generation„Å®Âêå„Åò„É≠„Ç∏„ÉÉ„ÇØÔºâ
              VALID_VIDEO=false
              if [ "$FILE_SIZE" -gt 100000 ]; then
                if ffprobe -v error -show_entries format=duration -of csv=p=0 "$video_file" >/dev/null 2>&1; then
                  DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$video_file" 2>/dev/null || echo "0")
                  if python3 -c "import sys; sys.exit(0 if float('$DURATION') >= 3.0 else 1)" 2>/dev/null; then
                    echo "‚úÖ Scene $scene_num: Valid (${FILE_SIZE} bytes, ${DURATION}s)"
                    VALID_SCENE_COUNT=$((VALID_SCENE_COUNT + 1))
                    VALID_VIDEO=true
                  else
                    echo "‚ö†Ô∏è Scene $scene_num: Too short (${DURATION}s)"
                  fi
                else
                  echo "‚ö†Ô∏è Scene $scene_num: Corrupted (missing moov atom)"
                fi
              else
                echo "‚ö†Ô∏è Scene $scene_num: Too small (${FILE_SIZE} bytes)"
              fi
              
              if [ "$VALID_VIDEO" = "false" ]; then
                CORRUPTED_SCENES="$CORRUPTED_SCENES $scene_num"
                RECOVERY_NEEDED=true
              fi
            else
              echo "‚ùå Scene $scene_num: File not found"
              CORRUPTED_SCENES="$CORRUPTED_SCENES $scene_num"
              RECOVERY_NEEDED=true
            fi
          done
          
          # „É™„ÉÉ„Éó„Ç∑„É≥„ÇØÂãïÁîª„ÅÆÊ§úË®º
          echo "üé§ „É™„ÉÉ„Éó„Ç∑„É≥„ÇØÂãïÁîª„ÅÆÊ§úË®º‰∏≠..."
          lipsync_file=$(find "${{ needs.setup.outputs.project_dir }}" -name "*lipsync*.mp4" -type f | head -1)
          
          if [ -f "$lipsync_file" ]; then
            FILE_SIZE=$(stat -c%s "$lipsync_file" 2>/dev/null || echo 0)
            
            VALID_LIPSYNC=false
            if [ "$FILE_SIZE" -gt 100000 ]; then
              if ffprobe -v error -show_entries format=duration -of csv=p=0 "$lipsync_file" >/dev/null 2>&1; then
                DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$lipsync_file" 2>/dev/null || echo "0")
                if python3 -c "import sys; sys.exit(0 if float('$DURATION') >= 3.0 else 1)" 2>/dev/null; then
                  echo "‚úÖ Lipsync: Valid (${FILE_SIZE} bytes, ${DURATION}s)"
                  VALID_LIPSYNC=true
                else
                  echo "‚ö†Ô∏è Lipsync: Too short (${DURATION}s)"
                fi
              else
                echo "‚ö†Ô∏è Lipsync: Corrupted (missing moov atom)"
              fi
            else
              echo "‚ö†Ô∏è Lipsync: Too small (${FILE_SIZE} bytes)"
            fi
            
            if [ "$VALID_LIPSYNC" = "false" ]; then
              CORRUPTED_LIPSYNC="anchor_lipsync"
              RECOVERY_NEEDED=true
            fi
          else
            echo "‚ùå Lipsync: File not found"
            CORRUPTED_LIPSYNC="anchor_lipsync"
            RECOVERY_NEEDED=true
          fi
          
          # ÁµêÊûú„ÅÆÂá∫Âäõ
          echo "üìä Ê§úË®ºÁµêÊûú„Çµ„Éû„É™„Éº:"
          echo "- ÊúâÂäπ„Å™„Ç∑„Éº„É≥ÂãïÁîª: $VALID_SCENE_COUNT/12"
          echo "- Á†¥Êêç„Ç∑„Éº„É≥: $CORRUPTED_SCENES"
          echo "- Á†¥Êêç„É™„ÉÉ„Éó„Ç∑„É≥„ÇØ: $CORRUPTED_LIPSYNC"
          echo "- „É™„Ç´„Éê„É™„ÉºÂøÖË¶Å: $RECOVERY_NEEDED"
          
          # GitHub Outputs„Å´Ë®≠ÂÆö
          echo "recovery_needed=$RECOVERY_NEEDED" >> $GITHUB_OUTPUT
          echo "corrupted_scenes=${CORRUPTED_SCENES# }" >> $GITHUB_OUTPUT  # ÂÖàÈ†≠„Çπ„Éö„Éº„ÇπÈô§Âéª
          echo "corrupted_lipsync=$CORRUPTED_LIPSYNC" >> $GITHUB_OUTPUT
          echo "valid_scene_count=$VALID_SCENE_COUNT" >> $GITHUB_OUTPUT

  immediate-recovery:
    needs: [check-trigger, setup, dynamic-recovery-check]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      needs.dynamic-recovery-check.outputs.recovery_needed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 35
    outputs:
      recovery_completed: ${{ steps.recover.outputs.recovery_completed }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download All Assets
        uses: actions/download-artifact@v4
        with:
          pattern: "*-data*"
          path: ${{ needs.setup.outputs.project_dir }}/
          merge-multiple: true

      - name: Install FFmpeg and ImageMagick
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg imagemagick

      - name: Execute Dynamic Recovery
        id: recover
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          echo "üîß ÂãïÁöÑ„É™„Ç´„Éê„É™„Éº„ÇíÈñãÂßã..."
          
          CORRUPTED_SCENES="${{ needs.dynamic-recovery-check.outputs.corrupted_scenes }}"
          CORRUPTED_LIPSYNC="${{ needs.dynamic-recovery-check.outputs.corrupted_lipsync }}"
          RECOVERY_SUCCESS=true
          
          # „Ç∑„Éº„É≥ÂãïÁîª„ÅÆ„É™„Ç´„Éê„É™„Éº
          if [ -n "$CORRUPTED_SCENES" ]; then
            echo "üìπ Á†¥Êêç„Ç∑„Éº„É≥ÂãïÁîª„ÅÆ„É™„Ç´„Éê„É™„Éº: $CORRUPTED_SCENES"
            
            for scene_num in $CORRUPTED_SCENES; do
              echo "üîß Scene $scene_num „Çí„É™„Ç´„Éê„É™„Éº‰∏≠..."
              
              # ËÉåÊôØÁîªÂÉè„ÇíÂèñÂæó
              BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*scene${scene_num}*.png" -type f | head -1)
              if [ -z "$BG_IMAGE" ] || [ ! -f "$BG_IMAGE" ]; then
                BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*background*.png" | head -1)
              fi
              
              if [ -f "$BG_IMAGE" ]; then
                VIDEO_PATH="${{ needs.setup.outputs.project_dir }}/media/videos/scene${scene_num}.mp4"
                URL_PATH="${{ needs.setup.outputs.project_dir }}/media/videos/scene${scene_num}-url.txt"
                
                I2V_PROMPT="Scene ${scene_num} Á∑äÊÄ•„É™„Ç´„Éê„É™„Éº:
                ËÉåÊôØÁîªÂÉè: ${BG_IMAGE}
                Âá∫ÂäõÂãïÁîª: ${VIDEO_PATH}
                Ë¶Å‰ª∂:
                1. MCP I2V „ÉÑ„Éº„É´„Åß5ÁßíÂãïÁîª„ÇíÁîüÊàê (È´òÈÄü„Çµ„Éº„Éì„ÇπÂÑ™ÂÖà: veo3-fast „Åæ„Åü„ÅØ seedance-v1-lite)
                2. ${VIDEO_PATH}„Å´‰øùÂ≠ò
                3. URL„Çí${URL_PATH}„Å´‰øùÂ≠ò
                4. Ê§úË®º: „Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫>100KB„ÄÅÂÜçÁîüÊôÇÈñì>=3Áßí„ÄÅmoov atomÂ≠òÂú®
                5. 10ÂàÜ‰ª•ÂÜÖ„ÅßÂÆå‰∫Ü„Åó„Å™„ÅÑÂ†¥Âêà„ÅØ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Å∏"
                
                # MCPÂá¶ÁêÜ„Å´ÊôÇÈñìÂà∂Èôê„ÇíË®≠ÂÆö
                timeout 600 npx @anthropic-ai/claude-code \
                  --mcp-config ".claude/mcp-kamuicode.json" \
                  --allowedTools "mcp__i2v-kamui-veo3-fast,mcp__i2v-kamui-seedance-v1-lite,Write,Bash" \
                  --max-turns 60 \
                  --permission-mode "bypassPermissions" \
                  -p "$I2V_PROMPT" || {
                    echo "‚ö†Ô∏è MCP „É™„Ç´„Éê„É™„ÉºÂ§±Êïó/„Çø„Ç§„É†„Ç¢„Ç¶„Éà„ÄÅFFmpeg „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ"
                    ffmpeg -loop 1 -i "$BG_IMAGE" -c:v libx264 -t 5 -pix_fmt yuv420p -r 30 "$VIDEO_PATH" -y
                  }
                
                # URL„Åã„Çâ„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâË©¶Ë°å
                [ -f "$URL_PATH" ] && curl -L -o "$VIDEO_PATH" "$(cat $URL_PATH)" 2>/dev/null
                
                # „É™„Ç´„Éê„É™„ÉºÁµêÊûú„ÅÆÊ§úË®º
                if [ -f "$VIDEO_PATH" ]; then
                  FILE_SIZE=$(stat -c%s "$VIDEO_PATH" 2>/dev/null || echo 0)
                  if [ "$FILE_SIZE" -gt 100000 ]; then
                    if ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_PATH" >/dev/null 2>&1; then
                      echo "‚úÖ Scene $scene_num „É™„Ç´„Éê„É™„ÉºÊàêÂäü"
                    else
                      echo "‚ùå Scene $scene_num „É™„Ç´„Éê„É™„ÉºÂ§±ÊïóÔºàÁ†¥ÊêçÔºâ"
                      RECOVERY_SUCCESS=false
                    fi
                  else
                    echo "‚ùå Scene $scene_num „É™„Ç´„Éê„É™„ÉºÂ§±ÊïóÔºà„Çµ„Ç§„Ç∫‰∏çË∂≥Ôºâ"
                    RECOVERY_SUCCESS=false
                  fi
                else
                  echo "‚ùå Scene $scene_num „É™„Ç´„Éê„É™„ÉºÂ§±ÊïóÔºà„Éï„Ç°„Ç§„É´Êú™ÁîüÊàêÔºâ"
                  RECOVERY_SUCCESS=false
                fi
              else
                echo "‚ùå Scene $scene_num: ËÉåÊôØÁîªÂÉè„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì"
                RECOVERY_SUCCESS=false
              fi
            done
          fi
          
          # „É™„ÉÉ„Éó„Ç∑„É≥„ÇØÂãïÁîª„ÅÆ„É™„Ç´„Éê„É™„Éº
          if [ -n "$CORRUPTED_LIPSYNC" ]; then
            echo "üé§ „É™„ÉÉ„Éó„Ç∑„É≥„ÇØÂãïÁîª„ÅÆ„É™„Ç´„Éê„É™„Éº"
            
            ANCHOR_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*anchor*.png" -o -name "*news_anchor*.png" | head -1)
            AUDIO_FILE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*.mp3" -o -name "*.wav" | head -1)
            
            if [ -f "$ANCHOR_IMAGE" ] && [ -f "$AUDIO_FILE" ]; then
              LIPSYNC_PATH="${{ needs.setup.outputs.project_dir }}/anchor_lipsync.mp4"
              
              LIPSYNC_PROMPT="„É™„ÉÉ„Éó„Ç∑„É≥„ÇØÁ∑äÊÄ•„É™„Ç´„Éê„É™„Éº:
              „Ç¢„É≥„Ç´„ÉºÁîªÂÉè: ${ANCHOR_IMAGE}
              Èü≥Â£∞„Éï„Ç°„Ç§„É´: ${AUDIO_FILE}
              Âá∫ÂäõÂãïÁîª: ${LIPSYNC_PATH}
              Ë¶Å‰ª∂:
              1. MCP „É™„ÉÉ„Éó„Ç∑„É≥„ÇØ„ÉÑ„Éº„É´„ÅßÈü≥Â£∞ÂêåÊúüÂãïÁîªÁîüÊàê (È´òÈÄü„Çµ„Éº„Éì„Çπ: pixverse-lipsync ÂÑ™ÂÖà)
              2. ${LIPSYNC_PATH}„Å´‰øùÂ≠ò
              3. Ê§úË®º: Èü≥Â£∞„Å®Âè£„ÅÆÂãï„Åç„ÅåÂêåÊúü
              4. 8ÂàÜ‰ª•ÂÜÖ„ÅßÂÆå‰∫Ü„Åó„Å™„ÅÑÂ†¥Âêà„ÅØ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Å∏"
              
              # „É™„ÉÉ„Éó„Ç∑„É≥„ÇØÂá¶ÁêÜ„Å´ÊôÇÈñìÂà∂Èôê„ÇíË®≠ÂÆö
              timeout 480 npx @anthropic-ai/claude-code \
                --mcp-config ".claude/mcp-kamuicode.json" \
                --allowedTools "mcp__v2v-kamui-pixverse-lipsync,mcp__v2v-kamui-creatify-lipsync,Write,Bash" \
                --max-turns 40 \
                --permission-mode "bypassPermissions" \
                -p "$LIPSYNC_PROMPT" || {
                  echo "‚ö†Ô∏è „É™„ÉÉ„Éó„Ç∑„É≥„ÇØÂ§±Êïó/„Çø„Ç§„É†„Ç¢„Ç¶„Éà„ÄÅÈùôÊ≠¢Áîª„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ"
                  ffmpeg -loop 1 -i "$ANCHOR_IMAGE" -i "$AUDIO_FILE" -c:v libx264 -c:a aac -shortest "$LIPSYNC_PATH" -y
                }
              
              # „É™„Ç´„Éê„É™„ÉºÁµêÊûú„ÅÆÊ§úË®º
              if [ -f "$LIPSYNC_PATH" ]; then
                FILE_SIZE=$(stat -c%s "$LIPSYNC_PATH" 2>/dev/null || echo 0)
                if [ "$FILE_SIZE" -gt 100000 ]; then
                  if ffprobe -v error -show_entries format=duration -of csv=p=0 "$LIPSYNC_PATH" >/dev/null 2>&1; then
                    echo "‚úÖ „É™„ÉÉ„Éó„Ç∑„É≥„ÇØ „É™„Ç´„Éê„É™„ÉºÊàêÂäü"
                  else
                    echo "‚ùå „É™„ÉÉ„Éó„Ç∑„É≥„ÇØ „É™„Ç´„Éê„É™„ÉºÂ§±ÊïóÔºàÁ†¥ÊêçÔºâ"
                    RECOVERY_SUCCESS=false
                  fi
                else
                  echo "‚ùå „É™„ÉÉ„Éó„Ç∑„É≥„ÇØ „É™„Ç´„Éê„É™„ÉºÂ§±ÊïóÔºà„Çµ„Ç§„Ç∫‰∏çË∂≥Ôºâ"
                  RECOVERY_SUCCESS=false
                fi
              else
                echo "‚ùå „É™„ÉÉ„Éó„Ç∑„É≥„ÇØ „É™„Ç´„Éê„É™„ÉºÂ§±ÊïóÔºà„Éï„Ç°„Ç§„É´Êú™ÁîüÊàêÔºâ"
                RECOVERY_SUCCESS=false
              fi
            else
              echo "‚ùå „É™„ÉÉ„Éó„Ç∑„É≥„ÇØ: ÂøÖË¶Å„Å™„Éï„Ç°„Ç§„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì"
              RECOVERY_SUCCESS=false
            fi
          fi
          
          # üö® CRITICAL: Final Recovery System validation and termination
          if [ "$RECOVERY_SUCCESS" = "true" ]; then
            echo "recovery_completed=true" >> $GITHUB_OUTPUT
            echo "üéâ ALL RECOVERY ATTEMPTS SUCCESSFUL - Workflow can continue"
            echo ""
            echo "Recovery Summary:"
            echo "‚úÖ Scene recoveries: Success"
            echo "‚úÖ Lipsync recovery: Success"
            echo "‚úÖ All validation checks: Passed"
          else
            echo "recovery_completed=false" >> $GITHUB_OUTPUT
            echo ""
            echo "üö® CRITICAL FAILURE: RECOVERY SYSTEM FAILED"
            echo "‚ùå Recovery attempts could not resolve all issues"
            echo ""
            echo "Failed recovery items:"
            if [ -n "$CORRUPTED_SCENES" ]; then
              echo "‚ùå Scene videos: $CORRUPTED_SCENES"
            fi
            if [ "$CORRUPTED_LIPSYNC" = "true" ]; then
              echo "‚ùå Lipsync video: Failed to recover"
            fi
            echo ""
            echo "üõë TERMINATING WORKFLOW - Recovery failure is not acceptable"
            echo "üìã Recovery Policy: All content must be successfully generated or recovered"
            echo "üö® Manual intervention required before workflow can proceed"
            echo ""
            echo "This workflow termination prevents:"
            echo "- Proceeding with incomplete video content"
            echo "- Creating defective final compositions"
            echo "- Delivering substandard results"
            echo ""
            exit 1  # Force immediate workflow termination
          fi

      - name: Upload Recovered Assets
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: recovered-assets
          path: |
            ${{ needs.setup.outputs.project_dir }}/media/videos/
            ${{ needs.setup.outputs.project_dir }}/anchor_lipsync.mp4

  final-composition:
    needs: [check-trigger, setup, scene-video-generation, lipsync-processing, editing-plan, dynamic-recovery-check, immediate-recovery, unified-failure-analysis]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      !cancelled() &&
      (
        (needs.unified-failure-analysis.outputs.items_complete == 'true' && needs.editing-plan.result == 'success') ||
        (needs.unified-failure-analysis.outputs.items_complete == 'false' && needs.immediate-recovery.outputs.recovery_completed == 'true' && needs.immediate-recovery.result == 'success')
      )
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      final_video: ${{ steps.compose.outputs.final_video }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download All Assets
        uses: actions/download-artifact@v4
        with:
          pattern: "*-data*"
          path: ${{ needs.setup.outputs.project_dir }}/
          merge-multiple: true

      - name: Download Recovered Assets (if available)
        uses: actions/download-artifact@v4
        if: needs.dynamic-recovery-check.outputs.recovery_needed == 'true'
        continue-on-error: true
        with:
          name: recovered-assets
          path: ${{ needs.setup.outputs.project_dir }}/

      - name: Install FFmpeg and Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq

      - name: Compose Final Video
        id: compose
        run: |
          mkdir -p "${{ needs.setup.outputs.project_dir }}/final"
          
          # List available assets
          echo "=== Available Assets ==="
          find "${{ needs.setup.outputs.project_dir }}" -type f -name "*.mp4" -o -name "*.png" -o -name "*.mp3" -o -name "*.wav" | sort
          
          # Find and validate background videos (post-recovery validation)
          echo "üîç Post-recovery video validation..."
          VALID_VIDEOS=""
          TOTAL_DURATION=0
          
          for video in $(find "${{ needs.setup.outputs.project_dir }}" -name "*scene*.mp4" -type f | sort); do
            if [ -f "$video" ]; then
              # Quick validation (files should be valid after recovery)
              FILE_SIZE=$(stat -c%s "$video" 2>/dev/null || echo 0)
              if [ "$FILE_SIZE" -gt 100000 ]; then
                if ffprobe -v error -show_entries format=duration -of csv=p=0 "$video" >/dev/null 2>&1; then
                  DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$video" 2>/dev/null || echo "0")
                  if python3 -c "import sys; sys.exit(0 if float('$DURATION') >= 3.0 else 1)" 2>/dev/null; then
                    echo "‚úÖ Valid video: $video (${FILE_SIZE} bytes, ${DURATION}s)"
                    VALID_VIDEOS="$VALID_VIDEOS $video"
                    TOTAL_DURATION=$(python3 -c "print(float('$TOTAL_DURATION') + float('$DURATION'))" 2>/dev/null || echo "$TOTAL_DURATION")
                  else
                    echo "‚ö†Ô∏è Unexpected short video after recovery: $video (${DURATION}s)"
                    # Note: This should not happen after successful recovery
                  fi
                else
                  echo "‚ö†Ô∏è Unexpected corrupted video after recovery: $video"
                  # Note: This should not happen after successful recovery
                fi
              else
                echo "‚ö†Ô∏è Unexpected small video after recovery: $video (${FILE_SIZE} bytes)"
              fi
            fi
          done
          
          echo "üìä Post-recovery summary:"
          echo "- Valid videos found: $(echo $VALID_VIDEOS | wc -w)"
          echo "- Total duration: ${TOTAL_DURATION}s"
          
          BACKGROUND_VIDEOS="$VALID_VIDEOS"
          
          # Validate lipsync video
          LIPSYNC_CANDIDATES=$(find "${{ needs.setup.outputs.project_dir }}" -name "*lipsync*.mp4" -type f)
          LIPSYNC_VIDEO=""
          for video in $LIPSYNC_CANDIDATES; do
            if [ -f "$video" ]; then
              FILE_SIZE=$(stat -c%s "$video" 2>/dev/null || echo 0)
              if [ "$FILE_SIZE" -gt 100000 ]; then
                if ffprobe -v error -show_entries format=duration -of csv=p=0 "$video" >/dev/null 2>&1; then
                  echo "‚úÖ Valid lipsync video: $video"
                  LIPSYNC_VIDEO="$video"
                  break
                else
                  echo "‚ö†Ô∏è Skipping corrupted lipsync video: $video (missing moov atom)"
                fi
              else
                echo "‚ö†Ô∏è Skipping small lipsync video: $video (${FILE_SIZE} bytes)"
              fi
            fi
          done
          
          AUDIO_FILE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*.mp3" -o -name "*.wav" | head -1)
          
          FINAL_OUTPUT="${{ needs.setup.outputs.project_dir }}/final/news_video_final.mp4"
          
          if [ -n "$BACKGROUND_VIDEOS" ] && [ -n "$LIPSYNC_VIDEO" ] && [ -f "$LIPSYNC_VIDEO" ]; then
            echo "‚úÖ Found assets for composition"
            
            # Create video list for concatenation
            VIDEO_LIST="${{ needs.setup.outputs.project_dir }}/final/video_list.txt"
            echo -n > "$VIDEO_LIST"
            
            # Add background videos to list
            for video in $BACKGROUND_VIDEOS; do
              if [ -f "$video" ]; then
                echo "file '$video'" >> "$VIDEO_LIST"
              fi
            done
            
            # Concatenate background videos
            CONCAT_BG="${{ needs.setup.outputs.project_dir }}/final/background_concat.mp4"
            if [ -s "$VIDEO_LIST" ]; then
              ffmpeg -f concat -safe 0 -i "$VIDEO_LIST" -c copy "$CONCAT_BG" -y
            else
              echo "‚ö†Ô∏è No valid background videos, using fallback"
              ffmpeg -f lavfi -i color=blue:size=1920x1080:duration=${{ needs.setup.outputs.duration }} -r 30 "$CONCAT_BG" -y
            fi
            
            # Overlay anchor video (picture-in-picture)
            if [ -f "$CONCAT_BG" ] && [ -f "$LIPSYNC_VIDEO" ]; then
              ffmpeg -i "$CONCAT_BG" -i "$LIPSYNC_VIDEO" \
                -filter_complex "[1:v]scale=480:270[anchor];[0:v][anchor]overlay=W-w-20:H-h-20[v]" \
                -map "[v]" -map "1:a" -c:v libx264 -c:a aac -t ${{ needs.setup.outputs.duration }} \
                "$FINAL_OUTPUT" -y
            else
              echo "‚ö†Ô∏è Missing video files, creating simple output"
              cp "$LIPSYNC_VIDEO" "$FINAL_OUTPUT" 2>/dev/null || {
                ffmpeg -f lavfi -i testsrc=duration=${{ needs.setup.outputs.duration }}:size=1920x1080:rate=30 \
                  -f lavfi -i sine=frequency=1000:duration=${{ needs.setup.outputs.duration }} \
                  -c:v libx264 -c:a aac "$FINAL_OUTPUT" -y
              }
            fi
          else
            echo "‚ö†Ô∏è Missing essential assets, creating fallback video"
            # Create fallback news video (fixed FFmpeg syntax)
            ffmpeg -f lavfi -i color=darkblue:size=1920x1080:duration=${{ needs.setup.outputs.duration }} \
              -f lavfi -i sine=frequency=440:duration=${{ needs.setup.outputs.duration }} \
              -filter_complex "[0:v]drawtext=text='News Video\: ${{ needs.setup.outputs.news_topic }}':fontsize=48:fontcolor=white:x=(w-text_w)/2:y=(h-text_h)/2[v]" \
              -map "[v]" -map "1:a" -c:v libx264 -c:a aac "$FINAL_OUTPUT" -y
          fi
          
          # Verify final video
          if [ -f "$FINAL_OUTPUT" ]; then
            FILE_SIZE=$(stat -c%s "$FINAL_OUTPUT" 2>/dev/null || echo 0)
            DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$FINAL_OUTPUT" 2>/dev/null || echo "0")
            
            echo "‚úÖ Final video created:"
            echo "- Path: $FINAL_OUTPUT"
            echo "- Size: $FILE_SIZE bytes"
            echo "- Duration: ${DURATION}s"
            
            echo "final_video=$FINAL_OUTPUT" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Final video creation failed"
            echo "final_video=" >> $GITHUB_OUTPUT
          fi

      - name: Upload Final Video
        uses: actions/upload-artifact@v4
        with:
          name: final-video
          path: ${{ needs.setup.outputs.project_dir }}/final/

  quality-verification:
    needs: [check-trigger, setup, final-composition]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      needs.final-composition.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 8
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Final Video
        uses: actions/download-artifact@v4
        with:
          name: final-video
          path: ${{ needs.setup.outputs.project_dir }}/final/

      - name: Verify Video Quality
        run: |
          FINAL_VIDEO="${{ needs.final-composition.outputs.final_video }}"
          
          if [ -n "$FINAL_VIDEO" ] && [ -f "$FINAL_VIDEO" ]; then
            echo "=== Quality Verification ==="
            
            # Check file size
            FILE_SIZE=$(stat -c%s "$FINAL_VIDEO" 2>/dev/null || echo 0)
            echo "File size: $FILE_SIZE bytes"
            
            # Check video properties
            ffprobe -v error -select_streams v:0 -show_entries stream=width,height,r_frame_rate,duration -of csv=p=0 "$FINAL_VIDEO" 2>/dev/null || echo "Video probe failed"
            
            # Check audio properties
            ffprobe -v error -select_streams a:0 -show_entries stream=codec_name,sample_rate,channels -of csv=p=0 "$FINAL_VIDEO" 2>/dev/null || echo "Audio probe failed"
            
            if [ "$FILE_SIZE" -gt 1000000 ]; then
              echo "‚úÖ Video quality verification passed"
            else
              echo "‚ö†Ô∏è Video file seems small, but process completed"
            fi
          else
            echo "‚ùå No final video found for verification"
          fi
          
          # Create execution summary
          SUMMARY_FILE="${{ needs.setup.outputs.project_dir }}/final/execution_summary.txt"
          {
            echo "=== News Video Creation Summary ==="
            echo "Topic: ${{ needs.setup.outputs.news_topic }}"
            echo "Category: ${{ needs.setup.outputs.news_category }}"
            echo "Duration: ${{ needs.setup.outputs.duration }}s"
            echo "Scenes: ${{ needs.setup.outputs.scene_count }}"
            echo "Completion: $(date)"
            echo ""
            echo "Generated Assets:"
            find "${{ needs.setup.outputs.project_dir }}" -type f -name "*.mp4" -o -name "*.png" -o -name "*.mp3" -o -name "*.wav" -o -name "*.json" | sort
          } > "$SUMMARY_FILE"
          
          echo "‚úÖ Quality verification completed"

      - name: Final Status Summary
        if: always()
        run: |
          echo "## üé¨ News Video Creation Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Topic:** ${{ needs.setup.outputs.news_topic }}" >> $GITHUB_STEP_SUMMARY
          echo "**Category:** ${{ needs.setup.outputs.news_category }}" >> $GITHUB_STEP_SUMMARY
          echo "**Duration:** ${{ needs.setup.outputs.duration }}s" >> $GITHUB_STEP_SUMMARY
          echo "**Scenes:** ${{ needs.setup.outputs.scene_count }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Job Status:" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Setup: Complete" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.news-collection.result == 'success' && '‚úÖ' || '‚ùå' }} News Collection" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.script-creation.result == 'success' && '‚úÖ' || '‚ùå' }} Script Creation" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.narration-generation.result == 'success' && '‚úÖ' || '‚ùå' }} Narration Generation" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.anchor-generation.result == 'success' && '‚úÖ' || '‚ùå' }} Anchor Generation" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.background-generation.result == 'success' && '‚úÖ' || '‚ö†Ô∏è' }} Background Generation" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.scene-video-generation.result == 'success' && '‚úÖ' || '‚ö†Ô∏è' }} Scene Video Generation" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.lipsync-processing.result == 'success' && '‚úÖ' || '‚ùå' }} Lipsync Processing" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.final-composition.result == 'success' && '‚úÖ' || '‚ùå' }} Final Composition" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Final Video:** ${{ needs.final-composition.outputs.final_video || 'Not available' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üìÅ **Artifacts:** All generated files are available in workflow artifacts" >> $GITHUB_STEP_SUMMARY
