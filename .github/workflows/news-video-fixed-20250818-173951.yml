name: News Video Creation Workflow

on:
  workflow_dispatch:
    inputs:
      news_topic:
        description: 'ニュースのトピック'
        required: true
        default: '最新AI技術の進歩'
        type: string
      duration:
        description: '動画の長さ'
        required: true
        default: '60s'
        type: choice
        options:
          - '15s'
          - '30s'
          - '60s'
          - '90s'
          - '3min'
          - '5min'
      news_category:
        description: 'ニュースカテゴリー'
        required: true
        default: 'technology'
        type: choice
        options:
          - 'technology'
          - 'business'
          - 'science'
          - 'politics'
          - 'health'
          - 'sports'
          - 'entertainment'
      target_platform:
        description: '配信プラットフォーム'
        required: true
        default: 'youtube'
        type: choice
        options:
          - 'youtube'
          - 'instagram'
          - 'tiktok'
          - 'twitter'
      visual_style:
        description: 'ビジュアルスタイル'
        required: true
        default: 'cinematic'
        type: choice
        options:
          - 'cinematic'
          - 'documentary'
          - 'corporate'
      enable_fallback:
        description: 'フォールバック処理を有効にする'
        required: true
        default: true
        type: boolean
  push:
    paths-ignore:
      - '.github/workflows/**'

env:
  PROJECT_DIR: /home/runner/work/kamuicode_meta/kamuicode_meta/projects/issue-66-20250818-025742

jobs:
  check-trigger:
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
    steps:
      - name: Check Event Type
        id: check
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            echo "should_run=false" >> $GITHUB_OUTPUT
            echo "Skipping workflow for push event"
          else
            echo "should_run=true" >> $GITHUB_OUTPUT
          fi

  setup:
    needs: check-trigger
    if: needs.check-trigger.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      project_dir: ${{ steps.setup.outputs.project_dir }}
      news_topic: ${{ steps.setup.outputs.news_topic }}
      news_category: ${{ steps.setup.outputs.news_category }}
      duration: ${{ steps.setup.outputs.duration }}
      scene_count: ${{ steps.setup.outputs.scene_count }}
      scene_array: ${{ steps.setup.outputs.scene_array }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install Dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y jq

      - name: Setup Project Environment
        id: setup
        run: |
          # Create project directory structure
          mkdir -p "${PROJECT_DIR}"
          mkdir -p "${PROJECT_DIR}/metadata"
          mkdir -p "${PROJECT_DIR}/media/images"
          mkdir -p "${PROJECT_DIR}/media/videos"
          mkdir -p "${PROJECT_DIR}/media/audio"
          mkdir -p "${PROJECT_DIR}/logs"
          mkdir -p "${PROJECT_DIR}/final"
          
          # Extract duration seconds
          DURATION_INPUT="${{ github.event.inputs.duration || '60s' }}"
          case "$DURATION_INPUT" in
            "15s") DURATION_SECONDS=15 ;;
            "30s") DURATION_SECONDS=30 ;;
            "60s") DURATION_SECONDS=60 ;;
            "90s") DURATION_SECONDS=90 ;;
            "3min") DURATION_SECONDS=180 ;;
            "5min") DURATION_SECONDS=300 ;;
            *) DURATION_SECONDS=60 ;;
          esac
          
          # Calculate scene count (5 seconds per scene)
          SCENE_COUNT=$(( (DURATION_SECONDS + 4) / 5 ))
          
          # Create scene array for matrix
          SCENE_ARRAY="["
          for i in $(seq 1 $SCENE_COUNT); do
            if [ $i -gt 1 ]; then SCENE_ARRAY="${SCENE_ARRAY},"; fi
            SCENE_ARRAY="${SCENE_ARRAY}${i}"
          done
          SCENE_ARRAY="${SCENE_ARRAY}]"
          
          echo "project_dir=${PROJECT_DIR}" >> $GITHUB_OUTPUT
          echo "news_topic=${{ github.event.inputs.news_topic || '最新AI技術の進歩' }}" >> $GITHUB_OUTPUT
          echo "news_category=${{ github.event.inputs.news_category || 'technology' }}" >> $GITHUB_OUTPUT
          echo "duration=${DURATION_SECONDS}" >> $GITHUB_OUTPUT
          echo "scene_count=${SCENE_COUNT}" >> $GITHUB_OUTPUT
          echo "scene_array=${SCENE_ARRAY}" >> $GITHUB_OUTPUT
          
          echo "✅ Project setup complete:"
          echo "- Project Dir: ${PROJECT_DIR}"
          echo "- Topic: ${{ github.event.inputs.news_topic || '最新AI技術の進歩' }}"
          echo "- Category: ${{ github.event.inputs.news_category || 'technology' }}"
          echo "- Duration: ${DURATION_SECONDS}s"
          echo "- Scene Count: ${SCENE_COUNT}"
          echo "- Scene Array: ${SCENE_ARRAY}"

  news-collection:
    needs: [check-trigger, setup]
    if: needs.check-trigger.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 8
    outputs:
      news_summary: ${{ steps.collect.outputs.news_summary }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Collect News Information
        id: collect
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          TOPIC="${{ needs.setup.outputs.news_topic }}"
          CATEGORY="${{ needs.setup.outputs.news_category }}"
          
          SEARCH_PROMPT="Collect news information:
          Topic: ${TOPIC}
          Category: ${CATEGORY}
          Requirements:
          1. Search for latest news using WebSearch tool
          2. Get recent articles using NewsAPI if available
          3. Compile 5-7 key points about the topic
          4. Save summary to ${{ needs.setup.outputs.project_dir }}/metadata/news_summary.json
          5. Include source URLs and credibility scores
          6. Verify save with ls -la ${{ needs.setup.outputs.project_dir }}/metadata/"
          
          npx @anthropic-ai/claude-code \
            --mcp-config ".claude/mcp-kamuicode.json" \
            --allowedTools "WebSearch,mcp__external-newsapi*,Write,Bash" \
            --max-turns 40 \
            --permission-mode "bypassPermissions" \
            -p "$SEARCH_PROMPT" || {
              echo "⚠️ News collection failed, creating fallback summary"
              {
                echo '{'
                echo '  "topic": "'$TOPIC'",'
                echo '  "category": "'$CATEGORY'",'
                echo '  "key_points": ['
                echo '    "最新の'$TOPIC'に関する重要な発展",'
                echo '    "業界への影響と今後の展望",'
                echo '    "専門家による分析と見解",'
                echo '    "技術的な詳細と応用可能性",'
                echo '    "社会的意義と課題"'
                echo '  ],'
                echo '  "sources": ["fallback"],'
                echo '  "credibility_score": 0.7'
                echo '}'
              } > "${{ needs.setup.outputs.project_dir }}/metadata/news_summary.json"
            }
          
          # Verify and read summary
          ls -la "${{ needs.setup.outputs.project_dir }}/metadata/"
          if [ -f "${{ needs.setup.outputs.project_dir }}/metadata/news_summary.json" ]; then
            # Try to extract key_points, but handle different JSON structures
            SUMMARY=$(cat "${{ needs.setup.outputs.project_dir }}/metadata/news_summary.json" | jq -r '
              if .key_points then
                .key_points | if type == "array" then join("; ") else . end
              elif .summary then
                .summary
              elif .content then
                .content
              else
                "AI technology latest developments and analysis"
              end' 2>/dev/null || echo "Latest ${TOPIC} developments")
            # Clean up the summary - remove newlines and ensure single line
            SUMMARY=$(echo "$SUMMARY" | tr '\n' ' ' | tr -s ' ')
            echo "news_summary<<EOF" >> $GITHUB_OUTPUT
            echo "$SUMMARY" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "✅ News collection completed"
          else
            echo "news_summary<<EOF" >> $GITHUB_OUTPUT
            echo "Latest ${TOPIC} developments and industry impact" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "⚠️ Using fallback summary"
          fi

      - name: Upload News Data
        uses: actions/upload-artifact@v4
        with:
          name: news-data
          path: ${{ needs.setup.outputs.project_dir }}/metadata/

  script-creation:
    needs: [check-trigger, setup, news-collection]
    if: needs.check-trigger.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 8
    outputs:
      script_ready: ${{ steps.script.outputs.script_ready }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download News Data
        uses: actions/download-artifact@v4
        with:
          name: news-data
          path: ${{ needs.setup.outputs.project_dir }}/metadata/

      - name: Create News Script
        id: script
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          TOPIC="${{ needs.setup.outputs.news_topic }}"
          DURATION="${{ needs.setup.outputs.duration }}"
          SCENE_COUNT="${{ needs.setup.outputs.scene_count }}"
          
          SCRIPT_PROMPT="Create professional 60-second single-topic news script:
          Topic: ${TOPIC}
          Duration: 60 seconds (STRICT CONSTRAINT)
          Scene count: 12 scenes
          
          CRITICAL TEXT LENGTH CONSTRAINTS:
          - Each scene: 20-25 characters MAXIMUM (for 5-second narration)
          - Total script: 240-300 characters
          - Single news topic deep dive (NOT multiple trends)
          
          Structure for single topic coverage:
          Scene 1-2: News introduction and hook (40-50 chars)
          Scene 3-5: Background and context (60-75 chars)  
          Scene 6-8: Main details and specifics (60-75 chars)
          Scene 9-10: Impact and implications (40-50 chars)
          Scene 11-12: Future outlook and conclusion (40-50 chars)
          
          Requirements:
          1. Read news summary from ${{ needs.setup.outputs.project_dir }}/metadata/news_summary.json
          2. Focus on SINGLE news item for detailed 60-second coverage
          3. Each scene narration: 20-25 characters (5 seconds reading time)
          4. Create comprehensive single-topic analysis
          5. Professional news anchor style, concise but informative
          6. Save script to ${{ needs.setup.outputs.project_dir }}/metadata/news_script.json
          7. Include scene descriptions for visual generation
          8. Save narration text to ${{ needs.setup.outputs.project_dir }}/metadata/narration_text.txt
          9. Add character count validation for each scene
          10. Verify with ls -la"
          
          npx @anthropic-ai/claude-code \
            --allowedTools "Read,Write,Bash" \
            --max-turns 40 \
            --permission-mode "bypassPermissions" \
            -p "$SCRIPT_PROMPT" || {
              echo "⚠️ Script creation failed, creating fallback"
              
              # Create fallback script
              {
                echo '{'
                echo '  "title": "'$TOPIC'",'
                echo '  "total_duration": '$DURATION','
                echo '  "scene_count": '$SCENE_COUNT','
                echo '  "scenes": ['
                for i in $(seq 1 $SCENE_COUNT); do
                  if [ $i -eq 1 ]; then
                    echo '    {"scene": '$i', "duration": 5, "narration": "今日のニュースです。'$TOPIC'について最新の情報をお伝えします。", "visual": "News studio with professional anchor"}'
                  elif [ $i -eq $SCENE_COUNT ]; then
                    echo '    {"scene": '$i', "duration": 5, "narration": "以上、'$TOPIC'に関するニュースでした。", "visual": "Professional news studio conclusion"}'
                  else
                    echo '    {"scene": '$i', "duration": 5, "narration": "'$TOPIC'の詳細な分析と影響について。", "visual": "News background with graphics"}'
                  fi
                  [ $i -lt $SCENE_COUNT ] && echo ','
                done
                echo '  ]'
                echo '}'
              } > "${{ needs.setup.outputs.project_dir }}/metadata/news_script.json"
              
              # Create narration text
              echo "今日のニュースです。${TOPIC}について最新の情報をお伝えします。${TOPIC}の詳細な分析と影響について専門家の見解をご紹介します。以上、${TOPIC}に関するニュースでした。" > "${{ needs.setup.outputs.project_dir }}/metadata/narration_text.txt"
            }
          
          # Verify files
          ls -la "${{ needs.setup.outputs.project_dir }}/metadata/"
          
          # Basic script validation (character count validation will be added later)
          if [ -f "${{ needs.setup.outputs.project_dir }}/metadata/news_script.json" ]; then
            echo "🔍 Validating script structure..."
            SCENE_COUNT=$(jq '.scenes | length' "${{ needs.setup.outputs.project_dir }}/metadata/news_script.json" 2>/dev/null || echo "0")
            if [ "$SCENE_COUNT" -eq 12 ]; then
              echo "✅ Script has correct scene count: $SCENE_COUNT"
            else
              echo "⚠️ Scene count mismatch: $SCENE_COUNT (expected: 12)"
            fi
          fi
          
          if [ -f "${{ needs.setup.outputs.project_dir }}/metadata/news_script.json" ] && [ -f "${{ needs.setup.outputs.project_dir }}/metadata/narration_text.txt" ]; then
            echo "script_ready=true" >> $GITHUB_OUTPUT
            echo "✅ Script creation and validation completed"
          else
            echo "script_ready=false" >> $GITHUB_OUTPUT
            echo "❌ Script creation failed"
          fi

      - name: Upload Script Data
        uses: actions/upload-artifact@v4
        with:
          name: script-data
          path: ${{ needs.setup.outputs.project_dir }}/metadata/

  narration-generation:
    needs: [check-trigger, setup, script-creation]
    if: needs.check-trigger.outputs.should_run == 'true' && needs.script-creation.outputs.script_ready == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 8
    outputs:
      narration_ready: ${{ steps.narration.outputs.narration_ready }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Script Data
        uses: actions/download-artifact@v4
        with:
          name: script-data
          path: ${{ needs.setup.outputs.project_dir }}/metadata/

      - name: Generate Narration Audio
        id: narration
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          mkdir -p "${{ needs.setup.outputs.project_dir }}/media/audio"
          
          # Read narration text
          if [ -f "${{ needs.setup.outputs.project_dir }}/metadata/narration_text.txt" ]; then
            NARRATION_TEXT=$(cat "${{ needs.setup.outputs.project_dir }}/metadata/narration_text.txt")
          else
            NARRATION_TEXT="今日のニュースです。${{ needs.setup.outputs.news_topic }}について最新の情報をお伝えします。"
          fi
          
          AUDIO_PATH="${{ needs.setup.outputs.project_dir }}/media/audio/narration.mp3"
          
          TTS_PROMPT="Generate professional Japanese news narration:
          Text: '${NARRATION_TEXT}'
          Voice: Professional Japanese female news anchor
          Output: ${AUDIO_PATH}
          Requirements:
          1. Use MCP TTS tool for high quality audio
          2. Professional news anchor voice style
          3. Clear pronunciation and appropriate pace
          4. Save to ${AUDIO_PATH} using Write tool
          5. Verify with ls -la ${{ needs.setup.outputs.project_dir }}/media/audio/"
          
          npx @anthropic-ai/claude-code \
            --mcp-config ".claude/mcp-kamuicode.json" \
            --allowedTools "mcp__t2s-kamui-*,Write,Bash" \
            --max-turns 40 \
            --permission-mode "bypassPermissions" \
            -p "$TTS_PROMPT" || {
              echo "⚠️ MCP TTS failed, using local fallback"
              
              # Install espeak-ng for fallback
              sudo apt-get update && sudo apt-get install -y espeak-ng
              
              # Generate fallback narration
              espeak-ng "$NARRATION_TEXT" -w "${AUDIO_PATH}" -s 150 -v ja || {
                echo "⚠️ Fallback TTS failed, using placeholder"
                # Create a short silence as placeholder
                ffmpeg -f lavfi -i anullsrc=duration=5 -ar 44100 -ac 2 "${AUDIO_PATH}" -y
              }
            }
          
          # Verify audio file
          ls -la "${{ needs.setup.outputs.project_dir }}/media/audio/"
          
          AUDIO_FILE=$(find "${{ needs.setup.outputs.project_dir }}/media/audio/" -name "*.mp3" -o -name "*.wav" 2>/dev/null | head -1)
          if [ -n "$AUDIO_FILE" ] && [ -f "$AUDIO_FILE" ]; then
            FILE_SIZE=$(stat -c%s "$AUDIO_FILE" 2>/dev/null || echo 0)
            if [ "$FILE_SIZE" -gt 1000 ]; then
              # Install FFmpeg for audio processing
              sudo apt-get update && sudo apt-get install -y ffmpeg bc
              
              # Check audio duration and adjust if needed
              CURRENT_DURATION=$(ffprobe -v quiet -show_entries format=duration -of csv=p=0 "$AUDIO_FILE" 2>/dev/null || echo "0")
              TARGET_DURATION=60
              MIN_DURATION=55
              MAX_DURATION=65
              
              echo "🎵 Current narration duration: ${CURRENT_DURATION}s (target: ${TARGET_DURATION}s)"
              
              if (( $(echo "$CURRENT_DURATION > $MAX_DURATION" | bc -l) )); then
                echo "⚠️ Audio too long (${CURRENT_DURATION}s > ${MAX_DURATION}s) - compressing"
                SPEED_FACTOR=$(echo "scale=3; $CURRENT_DURATION / $TARGET_DURATION" | bc -l)
                ADJUSTED_FILE="${AUDIO_FILE%.mp3}_adjusted.mp3"
                
                ffmpeg -i "$AUDIO_FILE" -filter:a "atempo=$SPEED_FACTOR" -c:a mp3 "$ADJUSTED_FILE" -y
                
                if [ -f "$ADJUSTED_FILE" ]; then
                  mv "$ADJUSTED_FILE" "$AUDIO_FILE"
                  NEW_DURATION=$(ffprobe -v quiet -show_entries format=duration -of csv=p=0 "$AUDIO_FILE" 2>/dev/null || echo "0")
                  echo "✅ Audio compressed to ${NEW_DURATION}s (speed: ${SPEED_FACTOR}x)"
                else
                  echo "⚠️ Audio compression failed, using original"
                fi
                
              elif (( $(echo "$CURRENT_DURATION < $MIN_DURATION" | bc -l) )); then
                echo "⚠️ Audio too short (${CURRENT_DURATION}s < ${MIN_DURATION}s) - extending"
                SPEED_FACTOR=$(echo "scale=3; $CURRENT_DURATION / $TARGET_DURATION" | bc -l)
                ADJUSTED_FILE="${AUDIO_FILE%.mp3}_adjusted.mp3"
                
                ffmpeg -i "$AUDIO_FILE" -filter:a "atempo=$SPEED_FACTOR" -c:a mp3 "$ADJUSTED_FILE" -y
                
                if [ -f "$ADJUSTED_FILE" ]; then
                  mv "$ADJUSTED_FILE" "$AUDIO_FILE"
                  NEW_DURATION=$(ffprobe -v quiet -show_entries format=duration -of csv=p=0 "$AUDIO_FILE" 2>/dev/null || echo "0")
                  echo "✅ Audio extended to ${NEW_DURATION}s (speed: ${SPEED_FACTOR}x)"
                else
                  echo "⚠️ Audio extension failed, using original"
                fi
              else
                echo "✅ Audio duration within acceptable range: ${CURRENT_DURATION}s"
              fi
              
              # Final verification
              FINAL_DURATION=$(ffprobe -v quiet -show_entries format=duration -of csv=p=0 "$AUDIO_FILE" 2>/dev/null || echo "0")
              echo "📊 Final narration duration: ${FINAL_DURATION}s"
              
              echo "narration_ready=true" >> $GITHUB_OUTPUT
              echo "✅ Narration generated and adjusted: $AUDIO_FILE ($FILE_SIZE bytes, ${FINAL_DURATION}s)"
            else
              echo "narration_ready=false" >> $GITHUB_OUTPUT
              echo "⚠️ Narration file too small: $FILE_SIZE bytes"
            fi
          else
            echo "narration_ready=false" >> $GITHUB_OUTPUT
            echo "❌ Narration generation failed"
          fi

      - name: Upload Audio Data
        uses: actions/upload-artifact@v4
        with:
          name: audio-data
          path: ${{ needs.setup.outputs.project_dir }}/media/audio/

  anchor-generation:
    needs: [check-trigger, setup]
    if: needs.check-trigger.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 8
    outputs:
      anchor_ready: ${{ steps.anchor.outputs.anchor_ready }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install ImageMagick
        run: |
          sudo apt-get update
          sudo apt-get install -y imagemagick

      - name: Generate News Anchor
        id: anchor
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          mkdir -p "${{ needs.setup.outputs.project_dir }}/media/images"
          
          ANCHOR_PATH="${{ needs.setup.outputs.project_dir }}/media/images/news_anchor.png"
          URL_PATH="${{ needs.setup.outputs.project_dir }}/media/images/news_anchor-url.txt"
          
          ANCHOR_PROMPT="Generate professional Japanese news anchor:
          Description: Professional Japanese female news anchor, 30s, business suit, front-facing, green screen background, studio lighting, professional appearance
          Seed: 42 (for consistency)
          Output: ${ANCHOR_PATH}
          Requirements:
          1. Generate with MCP T2I tool (mcp__t2i-kamui-imagen3__imagen_t2i)
          2. Save image to ${ANCHOR_PATH} using Write tool
          3. Save Google Cloud URL to ${URL_PATH} using Write tool
          4. Execute ls -la ${{ needs.setup.outputs.project_dir }}/media/images/ using Bash tool"
          
          npx @anthropic-ai/claude-code \
            --mcp-config ".claude/mcp-kamuicode.json" \
            --allowedTools "mcp__t2i-kamui-*,Write,Bash" \
            --max-turns 40 \
            --permission-mode "bypassPermissions" \
            -p "$ANCHOR_PROMPT" || {
              echo "⚠️ Anchor generation failed, creating placeholder"
              # Create placeholder image
              convert -size 1920x1080 xc:green -pointsize 72 -fill white -gravity center -annotate +0+0 "News Anchor" "${ANCHOR_PATH}"
            }
          
          # Download from URL if available
          [ -f "$URL_PATH" ] && curl -L -o "$ANCHOR_PATH" "$(cat $URL_PATH)" 2>/dev/null
          
          # Validate anchor generation by checking URL file
          if [ -f "$URL_PATH" ]; then
            ANCHOR_URL=$(cat "$URL_PATH")
            if [ -n "$ANCHOR_URL" ]; then
              echo "anchor_ready=true" >> $GITHUB_OUTPUT
              echo "anchor_url=$ANCHOR_URL" >> $GITHUB_OUTPUT
              echo "✅ Anchor generated successfully: $ANCHOR_URL"
            else
              echo "anchor_ready=false" >> $GITHUB_OUTPUT
              echo "⚠️ Anchor URL file is empty"
            fi
          else
            echo "anchor_ready=false" >> $GITHUB_OUTPUT
            echo "❌ Anchor URL file not found"
          fi

      - name: Upload Anchor Data
        uses: actions/upload-artifact@v4
        with:
          name: anchor-data
          path: ${{ needs.setup.outputs.project_dir }}/media/images/

  background-generation:
    needs: [check-trigger, setup, news-collection, script-creation]
    if: needs.check-trigger.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 12
    strategy:
      matrix:
        scene: ${{ fromJson(needs.setup.outputs.scene_array) }}
      fail-fast: false
    continue-on-error: true
    outputs:
      failed_scenes: ${{ steps.collect-failures.outputs.failed_scenes }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Script Data
        uses: actions/download-artifact@v4
        with:
          name: script-data
          path: ${{ needs.setup.outputs.project_dir }}/metadata/

      - name: Install ImageMagick and Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y imagemagick jq

      - name: Generate Background for Scene ${{ matrix.scene }}
        id: background
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          SCENE_NUM=${{ matrix.scene }}
          SCENE_COUNT=${{ needs.setup.outputs.scene_count }}
          
          # Skip if scene number exceeds calculated count  
          if [ $SCENE_NUM -gt $SCENE_COUNT ]; then
            echo "Skipping scene $SCENE_NUM (exceeds count $SCENE_COUNT)"
            # Mark as skipped, not failed
            echo "scene_${SCENE_NUM}_skipped=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          mkdir -p "${{ needs.setup.outputs.project_dir }}/media/images"
          
          # Extract scene description from script
          SCENE_DESC="Professional news studio background, no people, clean modern design"
          if [ -f "${{ needs.setup.outputs.project_dir }}/metadata/news_script.json" ]; then
            SCENE_DESC=$(jq -r ".scenes[$((SCENE_NUM-1))].visual // \"Professional news studio background\"" "${{ needs.setup.outputs.project_dir }}/metadata/news_script.json" 2>/dev/null || echo "Professional news studio background")
          fi
          
          BG_PATH="${{ needs.setup.outputs.project_dir }}/media/images/background_scene${SCENE_NUM}.png"
          URL_PATH="${{ needs.setup.outputs.project_dir }}/media/images/background_scene${SCENE_NUM}-url.txt"
          
          BACKGROUND_PROMPT="Generate news background for scene ${SCENE_NUM}:
          Description: ${SCENE_DESC}, no people, professional lighting, news studio style
          Style: ${{ github.event.inputs.visual_style || 'cinematic' }}
          
          Requirements:
          1. Generate image using mcp__t2i-kamui-imagen3__imagen_t2i tool
          2. No human figures (background only)
          3. Professional news studio aesthetic
          4. Extract the URL from MCP response (Google Imagen3 URL or fal.ai URL)
          5. Save ONLY the URL to ${URL_PATH} using Write tool
          6. Display the URL for verification
          
          DO NOT try to save image files directly - only save the URL!"
          
          # Retry mechanism for MCP background generation
          RETRY_COUNT=0
          MAX_RETRIES=2
          SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$SUCCESS" = "false" ]; do
            echo "🔄 Background generation attempt $((RETRY_COUNT + 1))/$MAX_RETRIES for scene $SCENE_NUM"
            
            if npx @anthropic-ai/claude-code \
              --mcp-config ".claude/mcp-kamuicode.json" \
              --allowedTools "mcp__t2i-kamui-*,Write,Bash" \
              --max-turns 40 \
              --permission-mode "bypassPermissions" \
              -p "$BACKGROUND_PROMPT"; then
              
              echo "✅ Background generation command completed for scene $SCENE_NUM"
              SUCCESS=true
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "⚠️ Background generation attempt $RETRY_COUNT failed for scene $SCENE_NUM"
              
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "🔄 Retrying with modified prompt..."
                BACKGROUND_PROMPT="Generate news background for scene ${SCENE_NUM} (retry):
                Description: ${SCENE_DESC}, no people, professional lighting, news studio style
                Style: professional newsroom
                
                Requirements:
                1. Generate image using mcp__t2i-kamui-imagen3__imagen_t2i tool (different seed)
                2. No human figures (background only)
                3. Professional news studio aesthetic
                4. Extract the URL from MCP response (Google Imagen3 URL or fal.ai URL)
                5. Save ONLY the URL to ${URL_PATH} using Write tool
                6. Display the URL for verification
                
                DO NOT try to save image files directly - only save the URL!
                Note: This is retry attempt $((RETRY_COUNT + 1))"
                sleep 5  # Wait before retry
              fi
            fi
          done
          
          # Check if URL was generated successfully
          if [ "$SUCCESS" = "true" ] && [ -f "$URL_PATH" ]; then
            echo "✅ URL generation successful for scene $SCENE_NUM"
            echo "📥 Downloading background image from URL..."
            
            # Enhanced URL download with validation and multiple fallbacks
            DOWNLOAD_SUCCESS=false
            IMAGE_URL=$(cat "$URL_PATH")
            
            echo "📥 Attempting to download: $IMAGE_URL"
            
            # Try direct download first
            if curl -L -o "$BG_PATH" "$IMAGE_URL" --connect-timeout 10 --max-time 30 2>/dev/null; then
              # Validate downloaded file
              DOWNLOAD_SIZE=$(stat -c%s "$BG_PATH" 2>/dev/null || echo 0)
              if [ "$DOWNLOAD_SIZE" -gt 50000 ]; then
                if file "$BG_PATH" | grep -E "(PNG|JPEG|JPG)" >/dev/null 2>&1; then
                  echo "✅ URL download successful: ${DOWNLOAD_SIZE} bytes"
                  echo "scene_${SCENE_NUM}_url=$(cat "$URL_PATH")" >> $GITHUB_OUTPUT
                  DOWNLOAD_SUCCESS=true
                else
                  echo "⚠️ Downloaded file is not a valid image: ${DOWNLOAD_SIZE} bytes"
                fi
              else
                echo "⚠️ Downloaded file too small: ${DOWNLOAD_SIZE} bytes (likely placeholder/error)"
              fi
            else
              echo "⚠️ URL download failed (network/timeout error)"
            fi
            
            # If download failed, use enhanced ImageMagick fallback
            if [ "$DOWNLOAD_SUCCESS" = "false" ]; then
              echo "🔄 Using enhanced ImageMagick fallback for professional background"
              
              # Create high-quality news studio background with better design
              convert -size 1920x1080 \
                \( -size 1920x1080 gradient:blue-navy \) \
                \( -size 1920x1080 xc:transparent \
                   -fill 'rgba(255,255,255,0.1)' \
                   -draw 'rectangle 100,200 1820,880' \
                   -blur 2x2 \) \
                -composite \
                \( -size 400x200 xc:'#1E90FF' -blur 5x5 \) \
                -geometry +1400+100 -composite \
                \( -size 300x150 xc:'#4682B4' -blur 3x3 \) \
                -geometry +200+150 -composite \
                -pointsize 48 -fill white -gravity center \
                -annotate +0-300 "NEWS STUDIO" \
                -pointsize 24 -fill white \
                -annotate +0-250 "Scene $SCENE_NUM Background" \
                "$BG_PATH"
                
              echo "✅ Enhanced ImageMagick fallback created"
              echo "scene_${SCENE_NUM}_fallback=true" >> $GITHUB_OUTPUT
            fi
          elif [ "$SUCCESS" = "false" ]; then
            echo "❌ All background generation attempts failed for scene $SCENE_NUM"
            echo "scene_${SCENE_NUM}_failed=true" >> $GITHUB_OUTPUT
            # Don't exit 1 here - let continue-on-error handle it
          else
            echo "⚠️ URL file not found for scene $SCENE_NUM"
            echo "scene_${SCENE_NUM}_failed=true" >> $GITHUB_OUTPUT
          fi
          
          # Enhanced image verification with multiple patterns
          echo "🔍 Verifying background image for scene $SCENE_NUM"
          BG_IMAGE=""
          
          # Try multiple search patterns
          BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*scene${SCENE_NUM}*.png" -type f 2>/dev/null | head -1)
          if [ -z "$BG_IMAGE" ]; then
            BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*background*.png" -mmin -2 2>/dev/null | head -1)
          fi
          if [ -z "$BG_IMAGE" ]; then
            BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*.png" -mmin -1 2>/dev/null | head -1)
          fi
          
          # Save original generation metadata for recovery
          echo "📝 Saving recovery metadata for scene $SCENE_NUM"
          echo "{" > "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "  \"scene\": ${SCENE_NUM}," >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "  \"item_type\": \"IMAGE\"," >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "  \"item_name\": \"background\"," >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "  \"original_prompt\": \"${SCENE_DESC}\"," >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "  \"mcp_tools\": [\"mcp__t2i-*\"]," >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "  \"fallback_method\": \"imagemagick\"," >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "  \"execution_time\": \"$(date -Iseconds)\"" >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "}" >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"

          # Validate found image
          VALIDATION_SUCCESS=false
          if [ -n "$BG_IMAGE" ] && [ -f "$BG_IMAGE" ]; then
            FILE_SIZE=$(stat -c%s "$BG_IMAGE" 2>/dev/null || echo 0)
            if [ "$FILE_SIZE" -gt 10000 ]; then
              echo "✅ Background generated for scene $SCENE_NUM: $BG_IMAGE (${FILE_SIZE} bytes)"
              echo "scene_${SCENE_NUM}_background_status=SUCCESS" >> $GITHUB_OUTPUT
              echo "scene_${SCENE_NUM}_background_file=$BG_IMAGE" >> $GITHUB_OUTPUT
              VALIDATION_SUCCESS=true
            else
              echo "⚠️ Background file too small for scene $SCENE_NUM (${FILE_SIZE} bytes)"
              echo "scene_${SCENE_NUM}_background_status=FAILED" >> $GITHUB_OUTPUT
              echo "scene_${SCENE_NUM}_background_failed=file_too_small" >> $GITHUB_OUTPUT
              echo "scene_${SCENE_NUM}_background_file_size=${FILE_SIZE}" >> $GITHUB_OUTPUT
            fi
          else
            echo "❌ Background image not found for scene $SCENE_NUM"
            echo "scene_${SCENE_NUM}_background_status=FAILED" >> $GITHUB_OUTPUT
            echo "scene_${SCENE_NUM}_background_failed=file_not_found" >> $GITHUB_OUTPUT
          fi
          
          # Final status report
          if [ "$VALIDATION_SUCCESS" = "true" ]; then
            echo "🎯 Scene $SCENE_NUM background generation completed successfully"
          else
            echo "⚠️ Scene $SCENE_NUM background generation completed with issues (will be handled by recovery system)"
          fi
          
          # Always exit successfully (let continue-on-error and recovery handle failures)
          exit 0

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          
      - name: Download All Background Artifacts
        uses: actions/download-artifact@v4
        if: always()
        with:
          pattern: background-data-scene-*
          path: ${{ needs.setup.outputs.project_dir }}/all-backgrounds/
          merge-multiple: false
          
      - name: Collect Failed Items
        id: collect-failures
        if: always()
        run: |
          FAILED_ITEMS="[]"
          FAILED_BACKGROUNDS=""
          
          # Check for status files instead of step outputs
          echo "🔍 Checking background generation artifacts..."
          ls -la ${{ needs.setup.outputs.project_dir }}/all-backgrounds/ 2>/dev/null || echo "No background artifacts found"
          
          # Look for background status files
          ACTUAL_SCENE_COUNT=${{ needs.setup.outputs.scene_count }}
          for i in $(seq 1 $ACTUAL_SCENE_COUNT); do
              # Check if background image exists in artifacts
              BG_FOUND=false
              BG_REASON="unknown"
              
              # Check multiple potential locations
              POSSIBLE_PATHS=(
                "${{ needs.setup.outputs.project_dir }}/all-backgrounds/background-data-scene-${i}/background_scene${i}.png"
                "${{ needs.setup.outputs.project_dir }}/all-backgrounds/background-data-scene-${i}/scene${i}_background.png"
              )
              
              for path in "${POSSIBLE_PATHS[@]}"; do
                if [ -f "$path" ]; then
                  FILE_SIZE=$(stat -c%s "$path" 2>/dev/null || echo 0)
                  if [ "$FILE_SIZE" -gt 10000 ]; then  # Minimum 10KB for valid image
                    BG_FOUND=true
                    echo "✅ Found valid background: scene $i ($FILE_SIZE bytes)"
                    break
                  else
                    BG_REASON="file_too_small"
                  fi
                fi
              done
              
              if [ "$BG_FOUND" = "false" ]; then
                echo "❌ Missing background: scene $i"
                
                # Add to failed backgrounds list
                if [ -z "$FAILED_BACKGROUNDS" ]; then
                  FAILED_BACKGROUNDS="$i"
                else
                  FAILED_BACKGROUNDS="$FAILED_BACKGROUNDS,$i"
                fi
                
                # Add to detailed failed items using safe jq construction
                if command -v jq >/dev/null 2>&1; then
                  FAILED_ITEMS=$(echo "$FAILED_ITEMS" | jq --arg scene "$i" --arg reason "$BG_REASON" \
                    '. + [{"scene": ($scene | tonumber), "type": "IMAGE", "item": "background", "reason": $reason}]' 2>/dev/null || echo "[]")
                else
                  echo "⚠️ jq not available, using simple format"
                  FAILED_ITEMS="[{\"scene\":$i,\"type\":\"IMAGE\",\"item\":\"background\",\"reason\":\"$BG_REASON\"}]"
                fi
              fi
          done
          
          # Validate FAILED_ITEMS JSON before output
          if echo "$FAILED_ITEMS" | jq . >/dev/null 2>&1; then
            echo "✅ FAILED_ITEMS JSON is valid"
          else
            echo "⚠️ FAILED_ITEMS JSON invalid, using fallback"
            FAILED_ITEMS="[]"
          fi
          
          echo "failed_backgrounds=[${FAILED_BACKGROUNDS}]" >> $GITHUB_OUTPUT
          
          # Use heredoc for complex JSON output to avoid formatting issues
          echo "failed_items<<EOF" >> $GITHUB_OUTPUT
          echo "$FAILED_ITEMS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Legacy compatibility
          if [ -n "$FAILED_BACKGROUNDS" ]; then
            echo "failed_scenes=[${FAILED_BACKGROUNDS}]" >> $GITHUB_OUTPUT
          else
            echo "failed_scenes=[]" >> $GITHUB_OUTPUT
          fi

      - name: Upload Background Data
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: background-data-scene-${{ matrix.scene }}
          path: ${{ needs.setup.outputs.project_dir }}/media/images/

  collect-background-failures:
    needs: [check-trigger, setup, background-generation]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      !cancelled()
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      failed_backgrounds: ${{ steps.collect.outputs.failed_backgrounds }}
      failed_background_items: ${{ steps.collect.outputs.failed_background_items }}
    steps:
      - name: Download All Background Status Files
        uses: actions/download-artifact@v4
        with:
          pattern: background-data-scene-*
          path: ${{ needs.setup.outputs.project_dir }}/all-backgrounds/

      - name: Install Dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y jq

      - name: Collect Failed Backgrounds
        id: collect
        run: |
          FAILED_BACKGROUNDS=""
          FAILED_BACKGROUND_ITEMS="[]"
          
          echo "🔍 Analyzing background generation results for ${{ needs.setup.outputs.scene_count }} scenes"
          
          # Check each scene's background using artifact-based verification (most reliable)
          ACTUAL_SCENE_COUNT=${{ needs.setup.outputs.scene_count }}
          for i in $(seq 1 $ACTUAL_SCENE_COUNT); do
              echo "🔍 Checking scene $i background status..."
              
              # Look for background image files in artifact directories
              BACKGROUND_FOUND=false
              FILE_SIZE=0
              ACTUAL_BG_FILE=""
              
              # Multiple potential locations for background files based on actual artifact structure
              POSSIBLE_PATHS=(
                "${{ needs.setup.outputs.project_dir }}/all-backgrounds/background-data-scene-${i}/background_scene${i}.png"
                "${{ needs.setup.outputs.project_dir }}/all-backgrounds/background-data-scene-${i}/background_scene${i}.jpg"
                "${{ needs.setup.outputs.project_dir }}/all-backgrounds/background-data-scene-${i}/scene${i}_background.png"
                "${{ needs.setup.outputs.project_dir }}/all-backgrounds/background-data-scene-${i}/scene${i}.png"
              )
              
              # First, try known paths
              for path in "${POSSIBLE_PATHS[@]}"; do
                if [ -f "$path" ]; then
                  ACTUAL_BG_FILE="$path"
                  FILE_SIZE=$(stat -c%s "$path" 2>/dev/null || echo 0)
                  echo "📁 Found background file: $path (${FILE_SIZE} bytes)"
                  
                  # Validate image file (minimum 50KB for proper image)
                  if [ "$FILE_SIZE" -gt 50000 ]; then
                    # Additional validation: check if it's a valid image
                    if file "$path" | grep -E "(PNG|JPEG|JPG)" >/dev/null 2>&1; then
                      BACKGROUND_FOUND=true
                      echo "✅ Valid background image for scene $i: ${FILE_SIZE} bytes"
                      break
                    else
                      echo "❌ Invalid image format for scene $i"
                    fi
                  else
                    echo "❌ Background file too small for scene $i: ${FILE_SIZE} bytes"
                  fi
                fi
              done
              
              # If not found in known paths, search for any image file in the artifact directory
              if [ "$BACKGROUND_FOUND" = "false" ]; then
                ARTIFACT_DIR="${{ needs.setup.outputs.project_dir }}/all-backgrounds/background-data-scene-${i}"
                if [ -d "$ARTIFACT_DIR" ]; then
                  echo "🔍 Searching any image files in $ARTIFACT_DIR"
                  for img_file in "$ARTIFACT_DIR"/*.{png,jpg,jpeg,PNG,JPG,JPEG}; do
                    if [ -f "$img_file" ]; then
                      ACTUAL_BG_FILE="$img_file"
                      FILE_SIZE=$(stat -c%s "$img_file" 2>/dev/null || echo 0)
                      echo "📁 Found image file: $img_file (${FILE_SIZE} bytes)"
                      
                      # Validate image file
                      if [ "$FILE_SIZE" -gt 50000 ]; then
                        if file "$img_file" | grep -E "(PNG|JPEG|JPG)" >/dev/null 2>&1; then
                          BACKGROUND_FOUND=true
                          echo "✅ Valid background image for scene $i: ${FILE_SIZE} bytes"
                          break
                        fi
                      fi
                    fi
                  done
                fi
              fi
              
              # Mark as failed if no valid background found
              if [ "$BACKGROUND_FOUND" = "false" ]; then
                echo "❌ Scene $i background: FAILED (no valid image found)"
                
                # Add failed scene
                if [ -z "$FAILED_BACKGROUNDS" ]; then
                  FAILED_BACKGROUNDS="$i"
                else
                  FAILED_BACKGROUNDS="$FAILED_BACKGROUNDS,$i"
                fi
                
                # Add to detailed failed items
                FAILED_BACKGROUND_ITEMS=$(echo "$FAILED_BACKGROUND_ITEMS" | jq \
                  --arg scene "$i" \
                  --arg size "$FILE_SIZE" \
                  --arg file "$ACTUAL_BG_FILE" \
                  '. + [{"scene": ($scene | tonumber), "type": "IMAGE", "item": "background", "reason": "validation_failed", "file_size": ($size | tonumber), "file_path": $file}]')
              else
                echo "✅ Scene $i background: SUCCESS"
              fi
          done
          
          if [ -n "$FAILED_BACKGROUNDS" ]; then
            echo "Failed backgrounds: [$FAILED_BACKGROUNDS]"
            echo "failed_backgrounds=[${FAILED_BACKGROUNDS}]" >> $GITHUB_OUTPUT
          else
            echo "No failed backgrounds"
            echo "failed_backgrounds=[]" >> $GITHUB_OUTPUT
          fi
          
          # Use heredoc for complex JSON output to avoid formatting issues
          echo "failed_background_items<<EOF" >> $GITHUB_OUTPUT
          echo "$FAILED_BACKGROUND_ITEMS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "📊 Background failure details: $FAILED_BACKGROUND_ITEMS"

  background-recovery:
    needs: [check-trigger, setup, collect-background-failures]
    if: |
      always() && 
      needs.check-trigger.outputs.should_run == 'true' &&
      needs.collect-background-failures.outputs.failed_backgrounds != '' &&
      needs.collect-background-failures.outputs.failed_backgrounds != '[]'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    strategy:
      matrix:
        scene: ${{ fromJson(needs.collect-background-failures.outputs.failed_backgrounds || '[]') }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Script Data
        uses: actions/download-artifact@v4
        with:
          name: script-data
          path: ${{ needs.setup.outputs.project_dir }}/

      - name: Install Dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y jq imagemagick

      - name: Recovery Background Generation for Scene ${{ matrix.scene }}
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          SCENE_NUM=${{ matrix.scene }}
          mkdir -p "${{ needs.setup.outputs.project_dir }}/media/images"
          
          # Extract scene description from script (same as original)
          SCENE_DESC="Professional news studio background, no people, clean modern design"
          if [ -f "${{ needs.setup.outputs.project_dir }}/metadata/news_script.json" ]; then
            SCENE_DESC=$(jq -r ".scenes[$((SCENE_NUM-1))].visual // \"Professional news studio background\"" "${{ needs.setup.outputs.project_dir }}/metadata/news_script.json" 2>/dev/null || echo "Professional news studio background")
          fi
          
          BG_PATH="${{ needs.setup.outputs.project_dir }}/media/images/background_scene${SCENE_NUM}.png"
          URL_PATH="${{ needs.setup.outputs.project_dir }}/media/images/background_scene${SCENE_NUM}-url.txt"
          
          BACKGROUND_PROMPT="Generate news background for scene ${SCENE_NUM} (RECOVERY):
          Description: ${SCENE_DESC}, no people, professional lighting, news studio style
          Style: cinematic, enhanced recovery version
          
          Requirements:
          1. Generate image using mcp__t2i-kamui-imagen3__imagen_t2i tool
          2. No human figures (background only)
          3. Professional news studio aesthetic
          4. Extract the URL from MCP response (Google Imagen3 URL or fal.ai URL)
          5. Save ONLY the URL to ${URL_PATH} using Write tool
          6. Display the URL for verification
          
          DO NOT try to save image files directly - only save the URL!"
          
          # Retry mechanism for MCP background recovery (same as original)
          RETRY_COUNT=0
          MAX_RETRIES=2
          SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$SUCCESS" = "false" ]; do
            echo "🔄 Recovery attempt $((RETRY_COUNT + 1))/$MAX_RETRIES for scene $SCENE_NUM"
            
            if npx @anthropic-ai/claude-code \
              --mcp-config ".claude/mcp-kamuicode.json" \
              --allowedTools "mcp__t2i-kamui-*,Write,Bash" \
              --max-turns 40 \
              --permission-mode "bypassPermissions" \
              -p "$BACKGROUND_PROMPT"; then
              
              echo "✅ Background recovery command completed for scene $SCENE_NUM"
              SUCCESS=true
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "⚠️ Background recovery attempt $RETRY_COUNT failed for scene $SCENE_NUM"
              
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "🔄 Retrying with modified prompt..."
                BACKGROUND_PROMPT="Generate news background for scene ${SCENE_NUM} (RECOVERY retry):
                Description: ${SCENE_DESC}, no people, professional lighting, news studio style
                Style: professional newsroom
                
                Requirements:
                1. Generate image using mcp__t2i-kamui-imagen3__imagen_t2i tool (different seed)
                2. No human figures (background only)
                3. Professional news studio aesthetic
                4. Extract the URL from MCP response (Google Imagen3 URL or fal.ai URL)
                5. Save ONLY the URL to ${URL_PATH} using Write tool
                6. Display the URL for verification
                
                DO NOT try to save image files directly - only save the URL!
                Note: This is recovery retry attempt $((RETRY_COUNT + 1))"
                sleep 5  # Wait before retry
              fi
            fi
          done
          
          # Check if URL was generated successfully (same as original)
          if [ "$SUCCESS" = "true" ] && [ -f "$URL_PATH" ]; then
            echo "✅ URL generation successful for recovery scene $SCENE_NUM"
            echo "📥 Downloading background image from URL..."
            
            # Enhanced URL download with validation and multiple fallbacks
            DOWNLOAD_SUCCESS=false
            IMAGE_URL=$(cat "$URL_PATH")
            
            echo "📥 Attempting to download: $IMAGE_URL"
            
            # Try direct download first
            if curl -L -o "$BG_PATH" "$IMAGE_URL" --connect-timeout 10 --max-time 30 2>/dev/null; then
              # Validate downloaded file
              DOWNLOAD_SIZE=$(stat -c%s "$BG_PATH" 2>/dev/null || echo 0)
              if [ "$DOWNLOAD_SIZE" -gt 50000 ]; then
                if file "$BG_PATH" | grep -E "(PNG|JPEG|JPG)" >/dev/null 2>&1; then
                  echo "✅ URL download successful: ${DOWNLOAD_SIZE} bytes"
                  DOWNLOAD_SUCCESS=true
                else
                  echo "⚠️ Downloaded file is not a valid image: ${DOWNLOAD_SIZE} bytes"
                fi
              else
                echo "⚠️ Downloaded file too small: ${DOWNLOAD_SIZE} bytes (likely placeholder/error)"
              fi
            else
              echo "⚠️ URL download failed (network/timeout error)"
            fi
            
            # If download failed, use enhanced ImageMagick fallback
            if [ "$DOWNLOAD_SUCCESS" = "false" ]; then
              echo "🔄 Using enhanced ImageMagick fallback for professional background"
              
              # Create high-quality news studio background with better design
              convert -size 1920x1080 \
                \( -size 1920x1080 gradient:blue-navy \) \
                \( -size 1920x1080 xc:transparent \
                   -fill 'rgba(255,255,255,0.1)' \
                   -draw 'rectangle 100,200 1820,880' \
                   -blur 2x2 \) \
                -composite \
                \( -size 400x200 xc:'#1E90FF' -blur 5x5 \) \
                -geometry +1400+100 -composite \
                \( -size 300x150 xc:'#4682B4' -blur 3x3 \) \
                -geometry +200+150 -composite \
                -pointsize 48 -fill white -gravity center \
                -annotate +0-300 "NEWS STUDIO" \
                -pointsize 24 -fill white \
                -annotate +0-250 "Scene $SCENE_NUM Background" \
                "$BG_PATH"
                
              echo "✅ Enhanced ImageMagick fallback created"
            fi
          elif [ "$SUCCESS" = "false" ]; then
            echo "❌ All recovery attempts failed for scene $SCENE_NUM, using enhanced ImageMagick fallback"
            # Enhanced fallback for failed recovery attempts
            convert -size 1920x1080 \
              \( -size 1920x1080 gradient:darkred-maroon \) \
              \( -size 1920x1080 xc:transparent \
                 -fill 'rgba(255,255,255,0.15)' \
                 -draw 'rectangle 150,250 1770,830' \
                 -blur 3x3 \) \
              -composite \
              -pointsize 42 -fill white -gravity center \
              -annotate +0-200 "EMERGENCY STUDIO" \
              -pointsize 28 -fill white \
              -annotate +0-150 "Recovery Scene $SCENE_NUM" \
              -pointsize 20 -fill 'rgba(255,255,255,0.8)' \
              -annotate +0+300 "Technical Difficulties - Please Stand By" \
              "$BG_PATH"
          else
            echo "⚠️ URL file not found for recovery scene $SCENE_NUM, using enhanced ImageMagick fallback"
            # Enhanced fallback for missing URL files
            convert -size 1920x1080 \
              \( -size 1920x1080 gradient:darkgreen-forestgreen \) \
              \( -size 1920x1080 xc:transparent \
                 -fill 'rgba(255,255,255,0.12)' \
                 -draw 'rectangle 120,220 1800,860' \
                 -blur 2x2 \) \
              -composite \
              -pointsize 44 -fill white -gravity center \
              -annotate +0-200 "BACKUP STUDIO" \
              -pointsize 26 -fill white \
              -annotate +0-150 "Recovery Scene $SCENE_NUM" \
              -pointsize 18 -fill 'rgba(255,255,255,0.9)' \
              -annotate +0+320 "Alternative Background System Active" \
              "$BG_PATH"
          fi
          
          # Enhanced recovery result verification
          if [ -f "$BG_PATH" ]; then
            FILE_SIZE=$(stat -c%s "$BG_PATH" 2>/dev/null || echo 0)
            
            # Enhanced validation: size + format + dimensions
            if [ "$FILE_SIZE" -gt 50000 ]; then
              # Check if it's a valid image format
              if file "$BG_PATH" | grep -E "(PNG|JPEG|JPG)" >/dev/null 2>&1; then
                # Check image dimensions (should be 1920x1080 or close)
                DIMENSIONS=$(identify -format "%wx%h" "$BG_PATH" 2>/dev/null || echo "unknown")
                if [[ "$DIMENSIONS" =~ ^[0-9]+x[0-9]+$ ]]; then
                  echo "✅ Recovery successful: $BG_PATH ($FILE_SIZE bytes, ${DIMENSIONS})"
                  echo "recovery_scene_${SCENE_NUM}_status=SUCCESS" >> $GITHUB_OUTPUT
                  echo "recovery_scene_${SCENE_NUM}_file_size=${FILE_SIZE}" >> $GITHUB_OUTPUT
                  echo "recovery_scene_${SCENE_NUM}_dimensions=${DIMENSIONS}" >> $GITHUB_OUTPUT
                else
                  echo "⚠️ Recovery file has invalid dimensions: $DIMENSIONS"
                  echo "recovery_scene_${SCENE_NUM}_status=PARTIAL" >> $GITHUB_OUTPUT
                fi
              else
                echo "❌ Recovery file is not a valid image format: $FILE_SIZE bytes"
                echo "recovery_scene_${SCENE_NUM}_status=FAILED" >> $GITHUB_OUTPUT
              fi
            else
              echo "❌ Recovery file too small: $FILE_SIZE bytes (minimum 50KB required)"
              echo "recovery_scene_${SCENE_NUM}_status=FAILED" >> $GITHUB_OUTPUT
            fi
          else
            echo "❌ Recovery file not created"
            echo "recovery_scene_${SCENE_NUM}_status=FAILED" >> $GITHUB_OUTPUT
          fi

      - name: Upload Recovery Data
        uses: actions/upload-artifact@v4
        with:
          name: background-recovery-scene-${{ matrix.scene }}
          path: ${{ needs.setup.outputs.project_dir }}/media/images/

  scene-video-generation:
    needs: [check-trigger, setup, background-generation, collect-background-failures, background-recovery]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      !cancelled() &&
      (needs.collect-background-failures.result == 'success' || needs.collect-background-failures.result == 'skipped') &&
      (needs.background-recovery.result == 'success' || needs.background-recovery.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 25
    strategy:
      matrix:
        scene: ${{ fromJson(needs.setup.outputs.scene_array) }}
      fail-fast: false
      max-parallel: 8  # GitHub runner制限対策：同時実行数制限
    continue-on-error: false  # 厳格化：失敗を隠蔽しない
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install FFmpeg and Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq

      - name: Download Original Background Data
        uses: actions/download-artifact@v4
        with:
          name: background-data-scene-${{ matrix.scene }}
          path: ${{ needs.setup.outputs.project_dir }}/media/images/
        continue-on-error: true

      - name: Download Recovery Background Data
        uses: actions/download-artifact@v4
        if: needs.background-recovery.result == 'success'
        with:
          name: background-recovery-scene-${{ matrix.scene }}
          path: ${{ needs.setup.outputs.project_dir }}/media/images/
        continue-on-error: true

      - name: Generate Video for Scene ${{ matrix.scene }}
        id: video
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          CLAUDE_CODE_MAX_OUTPUT_TOKENS: 16000
        run: |
          SCENE_NUM=${{ matrix.scene }}
          SCENE_COUNT=${{ needs.setup.outputs.scene_count }}
          
          # Skip if scene number exceeds calculated count
          if [ $SCENE_NUM -gt $SCENE_COUNT ]; then
            echo "Skipping video for scene $SCENE_NUM (exceeds count $SCENE_COUNT)"
            exit 0
          fi
          
          mkdir -p "${{ needs.setup.outputs.project_dir }}/media/videos"
          
          # Extract scene description from script for recovery metadata
          SCENE_DESC="Professional news studio background, no people, clean modern design"
          if [ -f "${{ needs.setup.outputs.project_dir }}/metadata/news_script.json" ]; then
            SCENE_DESC=$(jq -r ".scenes[$((SCENE_NUM-1))].visual // \"Professional news studio background\"" "${{ needs.setup.outputs.project_dir }}/metadata/news_script.json" 2>/dev/null || echo "Professional news studio background")
          fi
          
          # Find background image (multiple patterns)
          BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*scene${SCENE_NUM}*.png" -type f 2>/dev/null | head -1)
          [ -z "$BG_IMAGE" ] && BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*background*.png" -mmin -5 2>/dev/null | head -1)
          [ -z "$BG_IMAGE" ] && BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*.png" 2>/dev/null | head -1)
          
          if [ -z "$BG_IMAGE" ] || [ ! -f "$BG_IMAGE" ]; then
            echo "⚠️ No background image found for scene $SCENE_NUM, creating fallback"
            BG_IMAGE="${{ needs.setup.outputs.project_dir }}/media/images/fallback_scene${SCENE_NUM}.png"
            convert -size 1920x1080 gradient:darkblue-blue -pointsize 60 -fill white -gravity center -annotate +0+0 "News Scene $SCENE_NUM" "$BG_IMAGE"
          fi
          
          VIDEO_PATH="${{ needs.setup.outputs.project_dir }}/media/videos/scene${SCENE_NUM}.mp4"
          URL_PATH="${{ needs.setup.outputs.project_dir }}/media/videos/scene${SCENE_NUM}-url.txt"
          
          # 🚨 MCP Connection Time Check (Critical for I2V success)
          WORKFLOW_START="${{ github.run_started_at }}"
          ELAPSED_MINUTES=$(( ($(date +%s) - $(date -d "$WORKFLOW_START" +%s)) / 60 ))
          
          echo "⏱️ Workflow elapsed time: ${ELAPSED_MINUTES} minutes"
          
          if [ $ELAPSED_MINUTES -lt 12 ]; then
            echo "✅ MCP connection viable - attempting I2V generation"
            
            I2V_PROMPT="Convert background image to video for scene ${SCENE_NUM}:
            Input image: ${BG_IMAGE}
            Output video: ${VIDEO_PATH}
            Requirements:
            1. Convert image to 5-second video using MCP I2V tool (preferred: i2v-fal-hailuo-02-fast)
            2. Gentle camera movement suitable for news
            3. 1920x1080 resolution, 30fps
            4. Save video to ${VIDEO_PATH} using Write tool
            5. Save URL to ${URL_PATH} using Write tool
            6. Execute ls -la ${VIDEO_PATH} using Bash tool to verify file creation
            7. Execute ffprobe -v error -show_entries format=duration -of csv=p=0 ${VIDEO_PATH} using Bash tool to verify MP4 structure"
            
            timeout 300 npx @anthropic-ai/claude-code \
              --mcp-config ".claude/mcp-kamuicode.json" \
              --allowedTools "mcp__i2v-kamui-*,Write,Bash" \
              --max-turns 60 \
              --permission-mode "bypassPermissions" \
              -p "$I2V_PROMPT" && echo "✅ MCP I2V completed" || {
                echo "⚠️ MCP I2V failed or timed out, using FFmpeg fallback"
                ffmpeg -loop 1 -i "$BG_IMAGE" -c:v libx264 -t 5 -pix_fmt yuv420p -r 30 "$VIDEO_PATH" -y
              }
          else
            echo "⚠️ MCP connection expired (${ELAPSED_MINUTES} min) - using FFmpeg fallback"
            ffmpeg -loop 1 -i "$BG_IMAGE" -c:v libx264 -t 5 -pix_fmt yuv420p -r 30 "$VIDEO_PATH" -y
          fi
          
          # Download from URL if available
          [ -f "$URL_PATH" ] && curl -L -o "$VIDEO_PATH" "$(cat $URL_PATH)" 2>/dev/null
          
          # Verify video
          VIDEO_FILE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*scene${SCENE_NUM}*.mp4" -type f 2>/dev/null | head -1)
          [ -z "$VIDEO_FILE" ] && VIDEO_FILE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*.mp4" -mmin -3 2>/dev/null | head -1)
          
          if [ -n "$VIDEO_FILE" ] && [ -f "$VIDEO_FILE" ]; then
            FILE_SIZE=$(stat -c%s "$VIDEO_FILE" 2>/dev/null || echo 0)
            
            # 🚨 ENHANCED VALIDATION: Comprehensive MP4 structure validation
            VALID_VIDEO=false
            VALIDATION_ERRORS=""
            
            # Check 1: File size validation (stricter threshold)
            if [ "$FILE_SIZE" -le 150000 ]; then
              VALIDATION_ERRORS="file_too_small:${FILE_SIZE}bytes"
              echo "❌ Video file too small for scene $SCENE_NUM: ${FILE_SIZE} bytes (minimum: 150KB)"
            else
              echo "✅ Size check passed: ${FILE_SIZE} bytes"
              
              # Check 2: MP4 structure validation with ffprobe
              if ! ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" >/dev/null 2>&1; then
                VALIDATION_ERRORS="corrupted_mp4:no_moov_atom"
                echo "❌ Video file corrupted (missing moov atom) for scene $SCENE_NUM"
              else
                echo "✅ MP4 structure check passed"
                
                # Check 3: Duration validation
                DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" 2>/dev/null || echo "0")
                if ! python3 -c "import sys; sys.exit(0 if float('$DURATION') >= 3.0 else 1)" 2>/dev/null; then
                  VALIDATION_ERRORS="duration_too_short:${DURATION}s"
                  echo "❌ Video too short for scene $SCENE_NUM: ${DURATION}s (minimum: 3.0s)"
                else
                  echo "✅ Duration check passed: ${DURATION}s"
                  
                  # Check 4: Video stream validation
                  if ! ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0 "$VIDEO_FILE" >/dev/null 2>&1; then
                    VALIDATION_ERRORS="no_video_stream"
                    echo "❌ No valid video stream found in scene $SCENE_NUM"
                  else
                    echo "✅ Video stream check passed"
                    VALID_VIDEO=true
                    echo "🎉 ALL VALIDATIONS PASSED for scene $SCENE_NUM: $VIDEO_FILE (${FILE_SIZE} bytes, ${DURATION}s)"
                  fi
                fi
              fi
            fi
            
            # 🚨 CRITICAL: Strict Recovery System - No tolerance for failure
            if [ "$VALID_VIDEO" = "false" ]; then
              echo "🚨 CRITICAL: Video validation failed for scene $SCENE_NUM: $VALIDATION_ERRORS"
              echo "🔧 Initiating strict multi-level recovery process..."
              
              RECOVERY_SUCCESS=false
              
              # Recovery Level 1: Different MCP service retry (if time permits)
              if [ $ELAPSED_MINUTES -lt 10 ]; then
                echo "🔄 Recovery Level 1: MCP retry with different service"
                RECOVERY_SEED=$((RANDOM + SCENE_NUM * 1000))
                
                # Try alternative I2V service
                RECOVERY_PROMPT="EMERGENCY RECOVERY Scene ${SCENE_NUM}:
                1. Generate 5-second video from $BG_IMAGE using different algorithm
                2. MANDATORY: Save to exact path: ${VIDEO_PATH}
                3. MANDATORY: Ensure file size >200KB and duration >4s
                4. MANDATORY: Use seed ${RECOVERY_SEED} for different result
                5. Execute ffprobe validation immediately after generation"
                
                timeout 180 npx @anthropic-ai/claude-code \
                  --mcp-config ".claude/mcp-kamuicode.json" \
                  --allowedTools "mcp__i2v-kamui-*,Write,Bash" \
                  --max-turns 30 \
                  --permission-mode "bypassPermissions" \
                  -p "$RECOVERY_PROMPT" 2>/dev/null && {
                    # Immediate re-validation
                    if [ -f "$VIDEO_FILE" ]; then
                      NEW_SIZE=$(stat -c%s "$VIDEO_FILE" 2>/dev/null || echo 0)
                      if [ "$NEW_SIZE" -gt 200000 ] && ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" >/dev/null 2>&1; then
                        NEW_DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" 2>/dev/null || echo "0")
                        if python3 -c "import sys; sys.exit(0 if float('$NEW_DURATION') >= 4.0 else 1)" 2>/dev/null; then
                          echo "✅ Recovery Level 1 SUCCESS: Scene $SCENE_NUM recovered via MCP retry"
                          RECOVERY_SUCCESS=true
                        fi
                      fi
                    fi
                  }
              fi
              
              # Recovery Level 2: Enhanced FFmpeg fallback (if Level 1 failed)
              if [ "$RECOVERY_SUCCESS" = "false" ]; then
                echo "🔄 Recovery Level 2: Enhanced FFmpeg fallback with narration"
                
                # Create high-quality fallback with scene information
                ffmpeg -loop 1 -i "$BG_IMAGE" \
                  -f lavfi -i sine=frequency=440:duration=5 \
                  -filter_complex "[0:v]scale=1920:1080,drawtext=text='Scene ${SCENE_NUM}':fontsize=72:fontcolor=white:x=(w-text_w)/2:y=(h-text_h)/2:box=1:boxcolor=black@0.5[v]" \
                  -map "[v]" -map "1:a" \
                  -c:v libx264 -c:a aac -t 5 -pix_fmt yuv420p -r 30 \
                  -shortest "$VIDEO_FILE" -y
                
                # Immediate validation of Level 2 fallback
                if [ -f "$VIDEO_FILE" ]; then
                  FALLBACK_SIZE=$(stat -c%s "$VIDEO_FILE" 2>/dev/null || echo 0)
                  if [ "$FALLBACK_SIZE" -gt 150000 ] && ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" >/dev/null 2>&1; then
                    FALLBACK_DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" 2>/dev/null || echo "0")
                    if python3 -c "import sys; sys.exit(0 if float('$FALLBACK_DURATION') >= 4.5 else 1)" 2>/dev/null; then
                      echo "✅ Recovery Level 2 SUCCESS: Scene $SCENE_NUM recovered via FFmpeg fallback"
                      RECOVERY_SUCCESS=true
                    fi
                  fi
                fi
              fi
              
              # 🚨 CRITICAL: Final recovery validation and termination check
              if [ "$RECOVERY_SUCCESS" = "true" ]; then
                echo "🎉 Recovery SUCCESS for scene $SCENE_NUM - continuing workflow"
                VALID_VIDEO=true
              else
                echo "🚨 CRITICAL FAILURE: All recovery attempts failed for scene $SCENE_NUM"
                echo "❌ Recovery Level 1 (MCP retry): FAILED"
                echo "❌ Recovery Level 2 (FFmpeg fallback): FAILED"
                echo "⚠️ MARKING SCENE FOR VIDEO RECOVERY - Scene generation will be handled by video-recovery job"
                echo ""
                echo "Error Details:"
                echo "- Original validation error: $VALIDATION_ERRORS"
                echo "- Recovery attempts: 2 levels attempted"
                echo "- Scene: $SCENE_NUM"
                echo "- Time elapsed: ${ELAPSED_MINUTES} minutes"
                echo ""
                echo "📋 Scene marked for video-recovery system - workflow continues"
                
                # Mark scene as failed for video recovery instead of terminating
                echo "scene_${SCENE_NUM}_video_status=FAILED" >> $GITHUB_OUTPUT
                echo "scene_${SCENE_NUM}_video_success=false" >> $GITHUB_OUTPUT
                echo "scene_${SCENE_NUM}_needs_recovery=true" >> $GITHUB_OUTPUT
              fi
            fi
            
            # Final success validation
            if [ "$VALID_VIDEO" = "true" ]; then
              echo "scene_${SCENE_NUM}_video_status=SUCCESS" >> $GITHUB_OUTPUT
              echo "scene_${SCENE_NUM}_video_success=true" >> $GITHUB_OUTPUT
              echo "✅ Scene $SCENE_NUM video generation CONFIRMED SUCCESSFUL"
            else
              echo "scene_${SCENE_NUM}_video_status=FAILED" >> $GITHUB_OUTPUT
              
              # Use validation errors from enhanced validation
              FAILURE_REASON="validation_failed"
              if [ -n "$VALIDATION_ERRORS" ]; then
                FAILURE_REASON="$VALIDATION_ERRORS"
              fi
              
              echo "scene_${SCENE_NUM}_video_failed=$FAILURE_REASON" >> $GITHUB_OUTPUT
              
              # Save enhanced recovery metadata
              METADATA_FILE="${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_video.json"
              echo "{" > "$METADATA_FILE"
              echo "  \"scene\": $SCENE_NUM," >> "$METADATA_FILE"
              echo "  \"item_type\": \"VIDEO\"," >> "$METADATA_FILE"
              echo "  \"item_name\": \"scene_video\"," >> "$METADATA_FILE"
              echo "  \"original_prompt\": \"$(echo "$SCENE_DESC" | sed 's/"/\\"/g')\"," >> "$METADATA_FILE"
              echo "  \"background_image\": \"$(echo "$BG_IMAGE" | sed 's/"/\\"/g')\"," >> "$METADATA_FILE"
              echo "  \"mcp_tools\": [\"mcp__i2v-fal-hailuo-02-fast\", \"mcp__i2v-fal-bytedance-seedance-v1-lite\"]," >> "$METADATA_FILE"
              echo "  \"fallback_method\": \"ffmpeg_enhanced\"," >> "$METADATA_FILE"
              echo "  \"generation_time\": \"$(date -Iseconds)\"," >> "$METADATA_FILE"
              echo "  \"workflow_elapsed_minutes\": $ELAPSED_MINUTES," >> "$METADATA_FILE"
              echo "  \"failure_reason\": \"$FAILURE_REASON\"," >> "$METADATA_FILE"
              echo "  \"file_size\": $FILE_SIZE," >> "$METADATA_FILE"
              echo "  \"validation_errors\": \"$VALIDATION_ERRORS\"," >> "$METADATA_FILE"
              echo "  \"validation_details\": \"Comprehensive MP4 validation: size+structure+duration+stream\"" >> "$METADATA_FILE"
              echo "}" >> "$METADATA_FILE"
            fi
          else
            echo "❌ Video generation failed for scene $SCENE_NUM"
            echo "scene_${SCENE_NUM}_video_status=FAILED" >> $GITHUB_OUTPUT
            echo "scene_${SCENE_NUM}_video_failed=file_not_found" >> $GITHUB_OUTPUT
            
            # Save recovery metadata for video regeneration
            METADATA_FILE="${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_video.json"
            echo "{" > "$METADATA_FILE"
            echo "  \"scene\": $SCENE_NUM," >> "$METADATA_FILE"
            echo "  \"item_type\": \"VIDEO\"," >> "$METADATA_FILE"
            echo "  \"item_name\": \"scene_video\"," >> "$METADATA_FILE"
            echo "  \"original_prompt\": \"$(echo "$SCENE_DESC" | sed 's/"/\\"/g')\"," >> "$METADATA_FILE"
            echo "  \"background_image\": \"$(echo "$BG_IMAGE" | sed 's/"/\\"/g')\"," >> "$METADATA_FILE"
            echo "  \"mcp_tools\": [\"mcp__i2v-*\"]," >> "$METADATA_FILE"
            echo "  \"fallback_method\": \"ffmpeg\"," >> "$METADATA_FILE"
            echo "  \"generation_time\": \"$(date -Iseconds)\"," >> "$METADATA_FILE"
            echo "  \"failure_reason\": \"file_not_found\"" >> "$METADATA_FILE"
            echo "}" >> "$METADATA_FILE"
          fi
          
          # Always exit successfully (let continue-on-error and status checks handle failures)
          echo "🎯 Scene $SCENE_NUM video generation step completed"
          exit 0

      - name: Save Video Generation Status
        if: always()
        run: |
          SCENE_NUM=${{ matrix.scene }}
          # Create directory if it doesn't exist
          mkdir -p "${{ needs.setup.outputs.project_dir }}"
          STATUS_FILE="${{ needs.setup.outputs.project_dir }}/video-status-scene${SCENE_NUM}.txt"
          
          # Check if this scene failed by looking for the video file
          VIDEO_FILE="${{ needs.setup.outputs.project_dir }}/media/videos/scene${SCENE_NUM}.mp4"
          
          if [ -f "$VIDEO_FILE" ]; then
            FILE_SIZE=$(stat -c%s "$VIDEO_FILE" 2>/dev/null || echo 0)
            
            # Enhanced validation matching the main validation
            VALID_VIDEO=false
            if [ "$FILE_SIZE" -gt 100000 ]; then
              if ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" >/dev/null 2>&1; then
                DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" 2>/dev/null || echo "0")
                if python3 -c "import sys; sys.exit(0 if float('$DURATION') >= 3.0 else 1)" 2>/dev/null; then
                  VALID_VIDEO=true
                fi
              fi
            fi
            
            if [ "$VALID_VIDEO" = "true" ]; then
              echo "SUCCESS" > "$STATUS_FILE"
              echo "Scene $SCENE_NUM video generation SUCCESS (size: $FILE_SIZE, duration: ${DURATION}s)"
            else
              echo "FAILED" > "$STATUS_FILE"
              echo "Scene $SCENE_NUM video generation FAILED (validation failed: size=$FILE_SIZE)"
            fi
          else
            echo "FAILED" > "$STATUS_FILE"
            echo "Scene $SCENE_NUM video generation FAILED (no file found)"
          fi

      - name: Upload Video Data
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: video-data-scene-${{ matrix.scene }}
          path: |
            ${{ needs.setup.outputs.project_dir }}/media/videos/
            ${{ needs.setup.outputs.project_dir }}/video-status-scene${{ matrix.scene }}.txt

  # 🎵 PHASE 1: Audio Segmentation (Replace single lipsync processing)
  audio-segment-generation:
    needs: [check-trigger, setup, narration-generation]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      needs.narration-generation.outputs.narration_ready == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      segments_ready: ${{ steps.segment.outputs.segments_ready }}
      segment_count: ${{ steps.segment.outputs.segment_count }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Audio Data
        uses: actions/download-artifact@v4
        with:
          name: audio-data
          path: ${{ needs.setup.outputs.project_dir }}/media/audio/

      - name: Install FFmpeg
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq bc

      - name: Segment Narration Audio
        id: segment
        run: |
          mkdir -p "${{ needs.setup.outputs.project_dir }}/media/audio/segments"
          
          # Find narration audio file
          AUDIO_FILE=$(find "${{ needs.setup.outputs.project_dir }}/media/audio" -name "*.mp3" -o -name "*.wav" | head -1)
          
          if [ -z "$AUDIO_FILE" ]; then
            echo "❌ No audio file found"
            echo "segments_ready=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Get audio duration and calculate segment duration
          TOTAL_DURATION=$(ffprobe -v quiet -show_entries format=duration -of csv=p=0 "$AUDIO_FILE")
          SCENE_COUNT=${{ needs.setup.outputs.scene_count }}
          SEGMENT_DURATION=$(echo "$TOTAL_DURATION / $SCENE_COUNT" | bc -l)
          
          echo "📊 Audio: ${TOTAL_DURATION}s, Scenes: ${SCENE_COUNT}, Segment: ${SEGMENT_DURATION}s each"
          
          # Split audio into scene segments
          for i in $(seq 1 $SCENE_COUNT); do
            START_TIME=$(echo "($i - 1) * $SEGMENT_DURATION" | bc -l)
            SEGMENT_FILE="${{ needs.setup.outputs.project_dir }}/media/audio/segments/scene_${i}_narration.mp3"
            
            ffmpeg -i "$AUDIO_FILE" \
              -ss "$START_TIME" \
              -t "$SEGMENT_DURATION" \
              -c copy \
              "$SEGMENT_FILE" -y
            
            if [ -f "$SEGMENT_FILE" ]; then
              SEGMENT_DUR=$(ffprobe -v quiet -show_entries format=duration -of csv=p=0 "$SEGMENT_FILE")
              echo "✅ Segment ${i}: ${SEGMENT_DUR}s"
            else
              echo "❌ Failed to create segment ${i}"
            fi
          done
          
          # Validate all segments created
          CREATED_SEGMENTS=$(find "${{ needs.setup.outputs.project_dir }}/media/audio/segments" -name "scene_*_narration.mp3" | wc -l)
          
          if [ "$CREATED_SEGMENTS" -eq "$SCENE_COUNT" ]; then
            echo "segments_ready=true" >> $GITHUB_OUTPUT
            echo "segment_count=${SCENE_COUNT}" >> $GITHUB_OUTPUT
            echo "✅ Successfully created ${CREATED_SEGMENTS} audio segments"
          else
            echo "segments_ready=false" >> $GITHUB_OUTPUT
            echo "❌ Expected ${SCENE_COUNT} segments, created ${CREATED_SEGMENTS}"
          fi

      - name: Upload Audio Segments
        uses: actions/upload-artifact@v4
        with:
          name: audio-segments-data
          path: ${{ needs.setup.outputs.project_dir }}/media/audio/segments/

  # 🎬 PHASE 2: Matrix Lipsync Generation (Parallel Processing)
  scene-lipsync-generation:
    needs: [check-trigger, setup, anchor-generation, audio-segment-generation]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      needs.anchor-generation.outputs.anchor_ready == 'true' &&
      needs.audio-segment-generation.outputs.segments_ready == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 8  # Per segment - much shorter than 12 minutes total
    strategy:
      matrix:
        scene: ${{ fromJson(needs.setup.outputs.scene_array) }}
      fail-fast: false
      max-parallel: 4  # Process 4 segments simultaneously
    continue-on-error: true
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Anchor Data
        uses: actions/download-artifact@v4
        with:
          name: anchor-data
          path: ${{ needs.setup.outputs.project_dir }}/media/images/

      - name: Download Audio Segments
        uses: actions/download-artifact@v4
        with:
          name: audio-segments-data
          path: ${{ needs.setup.outputs.project_dir }}/media/audio/segments/

      - name: Generate Lipsync for Scene ${{ matrix.scene }}
        id: lipsync
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          SCENE_NUM=${{ matrix.scene }}
          SCENE_COUNT=${{ needs.setup.outputs.scene_count }}
          
          # Skip if scene exceeds count
          if [ $SCENE_NUM -gt $SCENE_COUNT ]; then
            echo "Skipping scene $SCENE_NUM (exceeds count $SCENE_COUNT)"
            echo "scene_${SCENE_NUM}_lipsync_skipped=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          mkdir -p "${{ needs.setup.outputs.project_dir }}/media/videos/lipsync"
          
          # Find anchor image and scene audio segment
          ANCHOR_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}/media/images" -name "*anchor*.png" | head -1)
          AUDIO_SEGMENT=$(find "${{ needs.setup.outputs.project_dir }}/media/audio/segments" -name "scene_${SCENE_NUM}_narration.*" | head -1)
          
          if [ -z "$ANCHOR_IMAGE" ]; then
            echo "❌ Missing anchor image for scene $SCENE_NUM"
            echo "scene_${SCENE_NUM}_lipsync_status=FAILED" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          if [ -z "$AUDIO_SEGMENT" ]; then
            echo "❌ Missing audio segment for scene $SCENE_NUM"
            echo "scene_${SCENE_NUM}_lipsync_status=FAILED" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          LIPSYNC_PATH="${{ needs.setup.outputs.project_dir }}/media/videos/lipsync/scene_${SCENE_NUM}_lipsync.mp4"
          URL_PATH="${{ needs.setup.outputs.project_dir }}/media/videos/lipsync/scene_${SCENE_NUM}_lipsync-url.txt"
          
          # Get audio duration for this segment
          AUDIO_DURATION=$(ffprobe -v quiet -show_entries format=duration -of csv=p=0 "$AUDIO_SEGMENT" 2>/dev/null || echo "15")
          
          echo "🎬 Scene ${SCENE_NUM}: Lipsync generation (${AUDIO_DURATION}s audio)"
          echo "📁 Anchor: $(basename "$ANCHOR_IMAGE")"
          echo "🎵 Audio: $(basename "$AUDIO_SEGMENT")"
          
          LIPSYNC_PROMPT="Create lipsync video for scene ${SCENE_NUM}:
          Image: ${ANCHOR_IMAGE}
          Audio: ${AUDIO_SEGMENT}
          Duration: ${AUDIO_DURATION} seconds
          Output: ${LIPSYNC_PATH}
          Requirements:
          1. Generate lipsync video using MCP I2V lipsync tool
          2. Ensure audio-visual synchronization
          3. Save video to ${LIPSYNC_PATH} using Write tool
          4. Save Google Cloud URL to ${URL_PATH} using Write tool
          5. Execute ls -la ${{ needs.setup.outputs.project_dir }}/media/videos/lipsync/ using Bash tool"
          
          npx @anthropic-ai/claude-code \
            --mcp-config ".claude/mcp-kamuicode.json" \
            --allowedTools "mcp__v2v-kamui-*lipsync*,mcp__i2v-*,Write,Bash" \
            --max-turns 80 \
            --permission-mode "bypassPermissions" \
            -p "$LIPSYNC_PROMPT" || {
              echo "⚠️ Lipsync generation failed, attempting FFmpeg fallback"
              
              # FFmpeg fallback: Create static video with audio
              ffmpeg -loop 1 -i "$ANCHOR_IMAGE" \
                -i "$AUDIO_SEGMENT" \
                -c:v libx264 -t "$AUDIO_DURATION" \
                -pix_fmt yuv420p \
                -c:a aac \
                -shortest \
                "$LIPSYNC_PATH" -y || {
                echo "❌ FFmpeg fallback also failed"
                echo "scene_${SCENE_NUM}_lipsync_status=FAILED" >> $GITHUB_OUTPUT
                exit 0
              }
              echo "⚠️ Used FFmpeg fallback for scene ${SCENE_NUM}"
            }
          
          # Download from URL if available  
          [ -f "$URL_PATH" ] && curl -L -o "$LIPSYNC_PATH" "$(cat $URL_PATH)" 2>/dev/null
          
          # Validate lipsync generation
          if [ -f "$LIPSYNC_PATH" ] && [ $(stat -c%s "$LIPSYNC_PATH") -gt 100000 ]; then
            echo "scene_${SCENE_NUM}_lipsync_status=SUCCESS" >> $GITHUB_OUTPUT
            echo "✅ Scene ${SCENE_NUM} lipsync generated successfully"
          else
            echo "scene_${SCENE_NUM}_lipsync_status=FAILED" >> $GITHUB_OUTPUT
            echo "❌ Scene ${SCENE_NUM} lipsync generation failed"
          fi

      - name: Upload Lipsync Segment
        uses: actions/upload-artifact@v4
        if: steps.lipsync.outputs.scene_${{ matrix.scene }}_lipsync_status == 'SUCCESS'
        with:
          name: lipsync-segment-scene-${{ matrix.scene }}
          path: ${{ needs.setup.outputs.project_dir }}/media/videos/lipsync/

  # 🔍 PHASE 3: Collect Lipsync Failures
  collect-lipsync-failures:
    needs: [setup, scene-lipsync-generation]
    if: |
      always() &&
      !cancelled()
    runs-on: ubuntu-latest
    timeout-minutes: 3
    outputs:
      has_failures: ${{ steps.analyze.outputs.has_failures }}
      failed_scenes: ${{ steps.analyze.outputs.failed_scenes }}
      success_count: ${{ steps.analyze.outputs.success_count }}
    steps:
      - name: Download All Lipsync Segment Artifacts
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          pattern: lipsync-segment-scene-*
          path: ${{ needs.setup.outputs.project_dir }}/all-lipsync/

      - name: Analyze Lipsync Results
        id: analyze
        run: |
          echo "🔍 Analyzing lipsync generation results..."
          
          FAILED_SCENES=""
          SUCCESS_COUNT=0
          SCENE_COUNT=${{ needs.setup.outputs.scene_count }}
          
          # Check each scene's lipsync result using artifact-based verification
          for scene in $(seq 1 $SCENE_COUNT); do
            echo "🔍 Checking scene $scene lipsync status..."
            
            # Look for lipsync files in artifact directories
            LIPSYNC_FOUND=false
            FILE_SIZE=0
            
            # Multiple potential locations for lipsync files
            POSSIBLE_PATHS=(
              "${{ needs.setup.outputs.project_dir }}/all-lipsync/lipsync-segment-scene-${scene}/scene_${scene}_lipsync.mp4"
              "${{ needs.setup.outputs.project_dir }}/all-lipsync/lipsync-segment-scene-${scene}/lipsync_scene${scene}.mp4"
            )
            
            # Check for lipsync segment files
            for path in "${POSSIBLE_PATHS[@]}"; do
              if [ -f "$path" ]; then
                FILE_SIZE=$(stat -c%s "$path" 2>/dev/null || echo 0)
                if [ $FILE_SIZE -gt 100000 ]; then  # At least 100KB for valid lipsync
                  LIPSYNC_FOUND=true
                  echo "✅ Scene $scene: Valid lipsync found (${FILE_SIZE} bytes)"
                  SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
                  break
                else
                  echo "⚠️ Scene $scene: File too small (${FILE_SIZE} bytes)"
                fi
              fi
            done
            
            # If not found in artifacts, mark as failed
            if [ "$LIPSYNC_FOUND" = "false" ]; then
              echo "❌ Scene $scene: Lipsync segment missing or invalid"
              if [ -z "$FAILED_SCENES" ]; then
                FAILED_SCENES="$scene"
              else
                FAILED_SCENES="$FAILED_SCENES,$scene"
              fi
            fi
          done
          
          # Format failed scenes as JSON array
          if [ -n "$FAILED_SCENES" ]; then
            # Convert comma-separated to JSON array
            FAILED_ARRAY="[$(echo $FAILED_SCENES | sed 's/,/,/g')]"
            echo "has_failures=true" >> $GITHUB_OUTPUT
            echo "failed_scenes=$FAILED_ARRAY" >> $GITHUB_OUTPUT
          else
            echo "has_failures=false" >> $GITHUB_OUTPUT
            echo "failed_scenes=[]" >> $GITHUB_OUTPUT
          fi
          
          echo "success_count=${SUCCESS_COUNT}" >> $GITHUB_OUTPUT
          echo "📊 Lipsync Results: ${SUCCESS_COUNT}/${SCENE_COUNT} successful"
          [ -n "$FAILED_SCENES" ] && echo "❌ Failed scenes: $FAILED_SCENES"

  # 🚑 PHASE 4: Lipsync Recovery (For Failed Segments)
  lipsync-recovery:
    needs: [check-trigger, setup, anchor-generation, audio-segment-generation, collect-lipsync-failures]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      needs.collect-lipsync-failures.outputs.has_failures == 'true' &&
      needs.anchor-generation.outputs.anchor_ready == 'true' &&
      needs.audio-segment-generation.outputs.segments_ready == 'true' &&
      !cancelled()
    runs-on: ubuntu-latest
    timeout-minutes: 10  # Extra time for recovery
    strategy:
      matrix:
        scene: ${{ fromJson(needs.collect-lipsync-failures.outputs.failed_scenes || '[]') }}
      fail-fast: false
      max-parallel: 2  # Reduce parallelism for recovery
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Anchor Data
        uses: actions/download-artifact@v4
        with:
          name: anchor-data
          path: ${{ needs.setup.outputs.project_dir }}/media/images/

      - name: Download Audio Segments
        uses: actions/download-artifact@v4
        with:
          name: audio-segments-data
          path: ${{ needs.setup.outputs.project_dir }}/media/audio/segments/

      - name: Install FFmpeg
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg

      - name: Recovery Lipsync for Scene ${{ matrix.scene }}
        id: recovery
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          SCENE_NUM=${{ matrix.scene }}
          SCENE_COUNT=${{ needs.setup.outputs.scene_count }}
          
          # Skip if scene exceeds count
          if [ $SCENE_NUM -gt $SCENE_COUNT ]; then
            echo "Skipping recovery for scene $SCENE_NUM (exceeds count $SCENE_COUNT)"
            exit 0
          fi
          
          mkdir -p "${{ needs.setup.outputs.project_dir }}/media/videos/lipsync"
          
          # Find anchor image and scene audio segment
          ANCHOR_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}/media/images" -name "*anchor*.png" | head -1)
          AUDIO_SEGMENT=$(find "${{ needs.setup.outputs.project_dir }}/media/audio/segments" -name "scene_${SCENE_NUM}_narration.*" | head -1)
          
          if [ -z "$ANCHOR_IMAGE" ]; then
            echo "❌ Missing anchor image for recovery scene $SCENE_NUM"
            echo "scene_${SCENE_NUM}_recovery_status=FAILED" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          if [ -z "$AUDIO_SEGMENT" ]; then
            echo "❌ Missing audio segment for recovery scene $SCENE_NUM"
            echo "scene_${SCENE_NUM}_recovery_status=FAILED" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          LIPSYNC_PATH="${{ needs.setup.outputs.project_dir }}/media/videos/lipsync/scene_${SCENE_NUM}_lipsync_recovery.mp4"
          URL_PATH="${{ needs.setup.outputs.project_dir }}/media/videos/lipsync/scene_${SCENE_NUM}_lipsync_recovery-url.txt"
          
          # Get audio duration for this segment
          AUDIO_DURATION=$(ffprobe -v quiet -show_entries format=duration -of csv=p=0 "$AUDIO_SEGMENT" 2>/dev/null || echo "15")
          
          echo "🚑 Scene ${SCENE_NUM}: Recovery lipsync generation (${AUDIO_DURATION}s audio)"
          echo "📁 Anchor: $(basename "$ANCHOR_IMAGE")"
          echo "🎵 Audio: $(basename "$AUDIO_SEGMENT")"
          
          # Try multiple recovery attempts with different MCP tools
          SUCCESS=false
          
          # Recovery Attempt 1: Try different lipsync MCP tool
          echo "🔄 Recovery attempt 1: Alternative MCP lipsync tool"
          RECOVERY_PROMPT="RECOVERY: Create lipsync video for failed scene ${SCENE_NUM}:
          Image: ${ANCHOR_IMAGE}
          Audio: ${AUDIO_SEGMENT}
          Duration: ${AUDIO_DURATION} seconds
          Output: ${LIPSYNC_PATH}
          Requirements:
          1. Use alternative lipsync tool for recovery
          2. Ensure high-quality audio-visual sync
          3. Save video to ${LIPSYNC_PATH} using Write tool
          4. Save URL to ${URL_PATH} using Write tool
          5. Verify output with ls command"
          
          npx @anthropic-ai/claude-code \
            --mcp-config ".claude/mcp-kamuicode.json" \
            --allowedTools "mcp__v2v-kamui-creatify-lipsync,mcp__v2v-kamui-pixverse-lipsync,Write,Bash" \
            --max-turns 60 \
            --permission-mode "bypassPermissions" \
            -p "$RECOVERY_PROMPT" && {
            # Download from URL if available  
            [ -f "$URL_PATH" ] && curl -L -o "$LIPSYNC_PATH" "$(cat $URL_PATH)" 2>/dev/null
            
            # Check if recovery was successful
            if [ -f "$LIPSYNC_PATH" ] && [ $(stat -c%s "$LIPSYNC_PATH") -gt 100000 ]; then
              echo "✅ Recovery attempt 1 successful for scene ${SCENE_NUM}"
              SUCCESS=true
            fi
          }
          
          # Recovery Attempt 2: FFmpeg fallback with enhanced static video
          if [ "$SUCCESS" = "false" ]; then
            echo "🔄 Recovery attempt 2: Enhanced FFmpeg fallback"
            
            # Create enhanced static video with subtle animations
            ffmpeg -loop 1 -i "$ANCHOR_IMAGE" \
              -i "$AUDIO_SEGMENT" \
              -filter_complex "[0:v]scale=1920:1080,zoompan=z='if(lte(zoom,1.0),1.02,max(1.001,zoom-0.0002))':d=1:s=1920x1080[v]" \
              -map "[v]" -map 1:a \
              -c:v libx264 -c:a aac \
              -t "$AUDIO_DURATION" \
              -pix_fmt yuv420p \
              -shortest \
              "$LIPSYNC_PATH" -y && {
              echo "✅ Recovery attempt 2 (Enhanced FFmpeg) successful for scene ${SCENE_NUM}"
              SUCCESS=true
            }
          fi
          
          # Recovery Attempt 3: Simple static fallback
          if [ "$SUCCESS" = "false" ]; then
            echo "🔄 Recovery attempt 3: Simple static fallback"
            
            ffmpeg -loop 1 -i "$ANCHOR_IMAGE" \
              -i "$AUDIO_SEGMENT" \
              -c:v libx264 -c:a aac \
              -t "$AUDIO_DURATION" \
              -pix_fmt yuv420p \
              -shortest \
              "$LIPSYNC_PATH" -y && {
              echo "✅ Recovery attempt 3 (Simple static) successful for scene ${SCENE_NUM}"
              SUCCESS=true
            }
          fi
          
          # Final validation
          if [ "$SUCCESS" = "true" ] && [ -f "$LIPSYNC_PATH" ] && [ $(stat -c%s "$LIPSYNC_PATH") -gt 50000 ]; then
            echo "scene_${SCENE_NUM}_recovery_status=SUCCESS" >> $GITHUB_OUTPUT
            echo "✅ Scene ${SCENE_NUM} recovery completed successfully"
          else
            echo "scene_${SCENE_NUM}_recovery_status=FAILED" >> $GITHUB_OUTPUT
            echo "❌ Scene ${SCENE_NUM} recovery failed after all attempts"
          fi

      - name: Upload Recovery Lipsync Data
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: lipsync-recovery-scene-${{ matrix.scene }}
          path: ${{ needs.setup.outputs.project_dir }}/media/videos/lipsync/

  # 🔄 PHASE 5: Lipsync Assembly (Combine Segments)  
  lipsync-assembly:
    needs: [check-trigger, setup, scene-lipsync-generation, collect-lipsync-failures, lipsync-recovery]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      !cancelled() &&
      (needs.scene-lipsync-generation.result == 'success' || needs.scene-lipsync-generation.result == 'skipped') &&
      (needs.lipsync-recovery.result == 'success' || needs.lipsync-recovery.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 8
    outputs:
      lipsync_ready: ${{ steps.assemble.outputs.lipsync_ready }}
      final_lipsync: ${{ steps.assemble.outputs.final_lipsync }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download All Lipsync Segments
        uses: actions/download-artifact@v4
        with:
          pattern: lipsync-segment-scene-*
          path: ${{ needs.setup.outputs.project_dir }}/media/videos/lipsync/
          merge-multiple: true

      - name: Download Lipsync Recovery Segments (if available)
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          pattern: lipsync-recovery-scene-*
          path: ${{ needs.setup.outputs.project_dir }}/media/videos/lipsync/
          merge-multiple: true

      - name: Install FFmpeg and Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg bc

      - name: Assemble Final Lipsync Video
        id: assemble
        run: |
          mkdir -p "${{ needs.setup.outputs.project_dir }}/final"
          
          echo "🎬 Assembling lipsync segments..."
          
          # Find all lipsync segment files
          SEGMENT_FILES=""
          SEGMENT_COUNT=0
          
          for scene in $(seq 1 ${{ needs.setup.outputs.scene_count }}); do
            # Try to find lipsync segment (original or recovery)
            SEGMENT_FILE=""
            
            # Priority 1: Original successful segment
            ORIGINAL_SEGMENT=$(find "${{ needs.setup.outputs.project_dir }}/media/videos/lipsync" -name "*scene_${scene}_lipsync.mp4" | head -1)
            
            # Priority 2: Recovery segment
            RECOVERY_SEGMENT=$(find "${{ needs.setup.outputs.project_dir }}/media/videos/lipsync" -name "*scene_${scene}_lipsync_recovery.mp4" | head -1)
            
            # Select best available segment with enhanced validation
            if [ -f "$ORIGINAL_SEGMENT" ]; then
              # Validate original segment with FFprobe
              if ffprobe -v error -show_entries format=duration -of csv=p=0 "$ORIGINAL_SEGMENT" >/dev/null 2>&1; then
                DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$ORIGINAL_SEGMENT" 2>/dev/null | head -1)
                if [ -n "$DURATION" ] && [ "${DURATION%.*}" -gt 0 ]; then
                  SEGMENT_FILE="$ORIGINAL_SEGMENT"
                  echo "✅ Found valid original segment ${scene}: $(basename "$SEGMENT_FILE") (${DURATION}s)"
                else
                  echo "⚠️ Original segment ${scene} has invalid duration: $DURATION"
                fi
              else
                echo "⚠️ Original segment ${scene} failed FFprobe validation"
              fi
            fi
            
            # If original failed validation, try recovery segment
            if [ -z "$SEGMENT_FILE" ] && [ -f "$RECOVERY_SEGMENT" ]; then
              if ffprobe -v error -show_entries format=duration -of csv=p=0 "$RECOVERY_SEGMENT" >/dev/null 2>&1; then
                DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$RECOVERY_SEGMENT" 2>/dev/null | head -1)
                if [ -n "$DURATION" ] && [ "${DURATION%.*}" -gt 0 ]; then
                  SEGMENT_FILE="$RECOVERY_SEGMENT"
                  echo "✅ Found valid recovery segment ${scene}: $(basename "$SEGMENT_FILE") (${DURATION}s)"
                else
                  echo "⚠️ Recovery segment ${scene} has invalid duration: $DURATION"
                fi
              else
                echo "⚠️ Recovery segment ${scene} failed FFprobe validation"
              fi
            fi
            
            # Add valid segment to concat list or create placeholder
            if [ -n "$SEGMENT_FILE" ] && [ -f "$SEGMENT_FILE" ]; then
              SEGMENT_FILES="${SEGMENT_FILES}file '${SEGMENT_FILE}'\n"
              SEGMENT_COUNT=$((SEGMENT_COUNT + 1))
            else
              echo "❌ No valid segment for scene ${scene} - creating 5s placeholder"
              # Create 5-second placeholder to match target scene duration
              PLACEHOLDER="${{ needs.setup.outputs.project_dir }}/media/videos/lipsync/placeholder_${scene}.mp4"
              
              ffmpeg -f lavfi -i color=black:size=1920x1080:duration=5 \
                -f lavfi -i anullsrc=sample_rate=48000:channel_layout=stereo \
                -c:v libx264 -c:a aac -pix_fmt yuv420p \
                -shortest "$PLACEHOLDER" -y
                
              if [ -f "$PLACEHOLDER" ]; then
                SEGMENT_FILES="${SEGMENT_FILES}file '${PLACEHOLDER}'\n"
                SEGMENT_COUNT=$((SEGMENT_COUNT + 1))
                echo "✅ Created 5s placeholder for scene ${scene}"
              else
                echo "❌ Failed to create placeholder for scene ${scene}"
              fi
            fi
          done
          
          # Create FFmpeg concat file
          CONCAT_FILE="${{ needs.setup.outputs.project_dir }}/media/videos/lipsync/concat_list.txt"
          echo -e "$SEGMENT_FILES" > "$CONCAT_FILE"
          
          echo "📝 Concat file contents:"
          cat "$CONCAT_FILE"
          
          # Concatenate all segments into final lipsync video
          FINAL_LIPSYNC="${{ needs.setup.outputs.project_dir }}/final/anchor_lipsync_complete.mp4"
          
          ffmpeg -f concat -safe 0 -i "$CONCAT_FILE" \
            -c copy \
            "$FINAL_LIPSYNC" -y || {
            echo "⚠️ Direct concat failed, re-encoding..."
            ffmpeg -f concat -safe 0 -i "$CONCAT_FILE" \
              -c:v libx264 -c:a aac \
              "$FINAL_LIPSYNC" -y
          }
          
          # Validate final lipsync video
          if [ -f "$FINAL_LIPSYNC" ] && [ $(stat -c%s "$FINAL_LIPSYNC") -gt 1000000 ]; then
            FINAL_DURATION=$(ffprobe -v quiet -show_entries format=duration -of csv=p=0 "$FINAL_LIPSYNC")
            echo "lipsync_ready=true" >> $GITHUB_OUTPUT
            echo "final_lipsync=${FINAL_LIPSYNC}" >> $GITHUB_OUTPUT
            echo "✅ Final lipsync video assembled: ${FINAL_DURATION}s"
            echo "📁 Location: $FINAL_LIPSYNC"
          else
            echo "lipsync_ready=false" >> $GITHUB_OUTPUT
            echo "❌ Failed to assemble final lipsync video"
          fi

      - name: Upload Final Lipsync
        uses: actions/upload-artifact@v4
        with:
          name: lipsync-final-data
          path: ${{ needs.setup.outputs.project_dir }}/final/

  collect-video-failures:
    needs: [check-trigger, setup, scene-video-generation]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      !cancelled()
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      failed_videos: ${{ steps.collect.outputs.failed_videos }}
      failed_video_items: ${{ steps.collect.outputs.failed_video_items }}
    steps:
      - name: Download All Video Status Files
        uses: actions/download-artifact@v4
        with:
          pattern: video-data-scene-*
          path: ${{ needs.setup.outputs.project_dir }}/all-videos/

      - name: Install FFmpeg and Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq

      - name: Collect Failed Videos
        id: collect
        run: |
          FAILED_VIDEOS=""
          FAILED_VIDEO_ITEMS="[]"
          
          echo "🔍 Analyzing video generation results for ${{ needs.setup.outputs.scene_count }} scenes"
          
          # Check each scene's status using artifact-based verification (most reliable)
          ACTUAL_SCENE_COUNT=${{ needs.setup.outputs.scene_count }}
          for i in $(seq 1 $ACTUAL_SCENE_COUNT); do
              echo "🔍 Checking scene $i video status..."
              
              # Look for video files in artifact directories
              VIDEO_FOUND=false
              FILE_SIZE=0
              ACTUAL_VIDEO_FILE=""
              
              # Multiple potential locations for video files based on actual artifact structure
              POSSIBLE_PATHS=(
                "${{ needs.setup.outputs.project_dir }}/all-videos/video-data-scene-${i}/video_scene${i}.mp4"
                "${{ needs.setup.outputs.project_dir }}/all-videos/video-data-scene-${i}/video_scene${i}.mov"
                "${{ needs.setup.outputs.project_dir }}/all-videos/video-data-scene-${i}/scene${i}_video.mp4"
                "${{ needs.setup.outputs.project_dir }}/all-videos/video-data-scene-${i}/scene${i}.mp4"
                "${{ needs.setup.outputs.project_dir }}/all-videos/video-data-scene-${i}/scene${i}_final.mp4"
              )
              
              # First, try known paths
              for path in "${POSSIBLE_PATHS[@]}"; do
                if [ -f "$path" ]; then
                  ACTUAL_VIDEO_FILE="$path"
                  FILE_SIZE=$(stat -c%s "$path" 2>/dev/null || echo 0)
                  echo "📁 Found video file: $path (${FILE_SIZE} bytes)"
                  
                  # Validate video file (minimum 100KB for proper video)
                  if [ "$FILE_SIZE" -gt 100000 ]; then
                    # Additional validation: check if it's a valid video
                    if file "$path" | grep -E "(MP4|QuickTime|Video)" >/dev/null 2>&1; then
                      VIDEO_FOUND=true
                      echo "✅ Valid video file for scene $i: ${FILE_SIZE} bytes"
                      break
                    else
                      echo "❌ Invalid video format for scene $i"
                    fi
                  else
                    echo "❌ Video file too small for scene $i: ${FILE_SIZE} bytes"
                  fi
                fi
              done
              
              # If not found in known paths, search for any video file in the artifact directory
              if [ "$VIDEO_FOUND" = "false" ]; then
                ARTIFACT_DIR="${{ needs.setup.outputs.project_dir }}/all-videos/video-data-scene-${i}"
                if [ -d "$ARTIFACT_DIR" ]; then
                  echo "🔍 Searching any video files in $ARTIFACT_DIR"
                  for vid_file in "$ARTIFACT_DIR"/*.{mp4,mov,avi,MP4,MOV,AVI}; do
                    if [ -f "$vid_file" ]; then
                      ACTUAL_VIDEO_FILE="$vid_file"
                      FILE_SIZE=$(stat -c%s "$vid_file" 2>/dev/null || echo 0)
                      echo "🎥 Found video file: $vid_file (${FILE_SIZE} bytes)"
                      
                      if [ "$FILE_SIZE" -gt 100000 ]; then
                        if file "$vid_file" | grep -E "(MP4|QuickTime|Video)" >/dev/null 2>&1; then
                          VIDEO_FOUND=true
                          echo "✅ Found valid video for scene $i: ${FILE_SIZE} bytes"
                          break
                        fi
                      fi
                    fi
                  done
                fi
              fi
              
              # 🚨 MANDATORY MP4 structure validation (no fallback to size-only)
              VIDEO_REASON=""
              if [ "$VIDEO_FOUND" = "true" ] && [ "$FILE_SIZE" -gt 100000 ]; then
                # CRITICAL: Always validate MP4 structure - no exceptions
                if ffprobe -v error -show_entries format=duration -of csv=p=0 "$ACTUAL_VIDEO_FILE" >/dev/null 2>&1; then
                  DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$ACTUAL_VIDEO_FILE" 2>/dev/null || echo "0")
                  # Use python for floating point comparison (more reliable than bc)
                  if python3 -c "import sys; sys.exit(0 if float('$DURATION') >= 3.0 else 1)" 2>/dev/null; then
                    echo "✅ Scene $i: Video validated (${FILE_SIZE} bytes, ${DURATION}s)"
                    continue  # Skip to next scene - this one is successful
                  else
                    echo "⚠️ Scene $i: Video too short (${DURATION}s)"
                    VIDEO_REASON="duration_too_short"
                  fi
                else
                  echo "⚠️ Scene $i: Video corrupted (no moov atom)"
                  VIDEO_REASON="corrupted_mp4"
                fi
              elif [ "$VIDEO_FOUND" = "true" ]; then
                echo "⚠️ Scene $i: Video file too small (${FILE_SIZE} bytes)"
                VIDEO_REASON="file_too_small"
              else
                echo "❌ Scene $i: No video file found"
                VIDEO_REASON="file_not_found"
              fi
              
              # Add failed scene to list
              if [ -z "$FAILED_VIDEOS" ]; then
                FAILED_VIDEOS="$i"
              else
                FAILED_VIDEOS="$FAILED_VIDEOS,$i"
              fi
              
              # Add to detailed failed items
              FAILED_VIDEO_ITEMS=$(echo "$FAILED_VIDEO_ITEMS" | jq --arg scene "$i" --arg reason "$VIDEO_REASON" \
                '. + [{"scene": ($scene | tonumber), "type": "VIDEO", "item": "scene_video", "reason": $reason}]')
              
              echo "❌ Scene $i video: FAILED ($VIDEO_REASON)"
          done
          
          if [ -n "$FAILED_VIDEOS" ]; then
            echo "Failed videos: [$FAILED_VIDEOS]"
            echo "failed_videos=[${FAILED_VIDEOS}]" >> $GITHUB_OUTPUT
          else
            echo "No failed videos"
            echo "failed_videos=[]" >> $GITHUB_OUTPUT
          fi
          
          # Store failed video items safely (avoid jq dependency)
          echo "failed_video_items<<EOF" >> $GITHUB_OUTPUT
          echo "$FAILED_VIDEO_ITEMS" >> $GITHUB_OUTPUT  
          echo "EOF" >> $GITHUB_OUTPUT
          echo "📊 Video failure details: $FAILED_VIDEO_ITEMS"



  editing-plan:
    needs: [check-trigger, setup, scene-video-generation, lipsync-assembly]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 8
    outputs:
      plan_ready: ${{ steps.plan.outputs.plan_ready }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download All Media Assets
        uses: actions/download-artifact@v4
        with:
          pattern: "*-data*"
          path: ${{ needs.setup.outputs.project_dir }}/media/
          merge-multiple: true

      - name: Create Editing Plan
        id: plan
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          mkdir -p "${{ needs.setup.outputs.project_dir }}/metadata"
          
          PLAN_PROMPT="Analyze all generated media and create editing plan:
          Directory: ${{ needs.setup.outputs.project_dir }}/media/
          Duration: ${{ needs.setup.outputs.duration }} seconds
          Scenes: ${{ needs.setup.outputs.scene_count }}
          Requirements:
          1. List all available video, image, and audio files
          2. Create optimal editing sequence
          3. Plan picture-in-picture layout for anchor overlay
          4. Specify timing and transitions
          5. Save plan to ${{ needs.setup.outputs.project_dir }}/metadata/editing_plan.json
          6. Include FFmpeg command suggestions"
          
          npx @anthropic-ai/claude-code \
            --allowedTools "Bash,Read,Write" \
            --max-turns 40 \
            --permission-mode "bypassPermissions" \
            -p "$PLAN_PROMPT" || {
              echo "⚠️ Creating fallback editing plan"
              {
                echo '{'
                echo '  "duration": '${{ needs.setup.outputs.duration }}','
                echo '  "scenes": '${{ needs.setup.outputs.scene_count }}','
                echo '  "layout": "picture_in_picture",'
                echo '  "anchor_position": "bottom_right",'
                echo '  "anchor_size": "25%",'
                echo '  "transition": "fade",'
                echo '  "audio_mix": {"narration": -3, "bgm": -18}'
                echo '}'
              } > "${{ needs.setup.outputs.project_dir }}/metadata/editing_plan.json"
            }
          
          if [ -f "${{ needs.setup.outputs.project_dir }}/metadata/editing_plan.json" ]; then
            echo "plan_ready=true" >> $GITHUB_OUTPUT
            echo "✅ Editing plan created"
          else
            echo "plan_ready=false" >> $GITHUB_OUTPUT
            echo "❌ Editing plan creation failed"
          fi

      - name: Upload Plan Data
        uses: actions/upload-artifact@v4
        with:
          name: plan-data
          path: ${{ needs.setup.outputs.project_dir }}/metadata/


  # 🎬 VIDEO RECOVERY: Matrix-based video recovery (same pattern as background recovery)
  video-recovery:
    needs: [check-trigger, setup, scene-video-generation, collect-video-failures, background-recovery]
    if: |
      always() && 
      needs.check-trigger.outputs.should_run == 'true' &&
      needs.collect-video-failures.outputs.failed_videos != '' &&
      needs.collect-video-failures.outputs.failed_videos != '[]'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      matrix:
        scene: ${{ fromJson(needs.collect-video-failures.outputs.failed_videos || '[]') }}
      fail-fast: false
      max-parallel: 4
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Original Background Data
        uses: actions/download-artifact@v4
        with:
          name: background-data-scene-${{ matrix.scene }}
          path: ${{ needs.setup.outputs.project_dir }}/media/images/
        continue-on-error: true

      - name: Download Recovery Background Data
        uses: actions/download-artifact@v4
        if: needs.background-recovery.result == 'success'
        with:
          name: background-recovery-scene-${{ matrix.scene }}
          path: ${{ needs.setup.outputs.project_dir }}/media/images/
        continue-on-error: true

      - name: Install Dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y ffmpeg jq

      - name: Recovery Video Generation for Scene ${{ matrix.scene }}
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          SCENE_NUM=${{ matrix.scene }}
          mkdir -p "${{ needs.setup.outputs.project_dir }}/media/videos"
          
          # Find background image (from original or recovery)
          BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*scene${SCENE_NUM}*.png" -type f 2>/dev/null | head -1)
          [ -z "$BG_IMAGE" ] && BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*background*.png" -mmin -10 2>/dev/null | head -1)
          
          if [ -z "$BG_IMAGE" ] || [ ! -f "$BG_IMAGE" ]; then
            echo "⚠️ No background found for recovery scene $SCENE_NUM, creating fallback"
            BG_IMAGE="${{ needs.setup.outputs.project_dir }}/media/images/fallback_recovery_scene${SCENE_NUM}.png"
            convert -size 1920x1080 gradient:navy-blue -pointsize 60 -fill white -gravity center -annotate +0+0 "Recovery Scene $SCENE_NUM" "$BG_IMAGE"
          fi
          
          VIDEO_PATH="${{ needs.setup.outputs.project_dir }}/media/videos/scene${SCENE_NUM}.mp4"
          URL_PATH="${{ needs.setup.outputs.project_dir }}/media/videos/scene${SCENE_NUM}-recovery-url.txt"
          
          # MCP Connection Time Check
          WORKFLOW_START="${{ github.run_started_at }}"
          ELAPSED_MINUTES=$(( ($(date +%s) - $(date -d "$WORKFLOW_START" +%s)) / 60 ))
          
          if [ $ELAPSED_MINUTES -lt 12 ]; then
            echo "✅ MCP connection viable for recovery - attempting I2V"
            
            I2V_RECOVERY_PROMPT="RECOVERY: Convert background to video for scene ${SCENE_NUM}:
            Input: ${BG_IMAGE}
            Output: ${VIDEO_PATH} 
            Requirements:
            1. Generate 5-second video using fast I2V service (veo3-fast or seedance-v1-lite)
            2. Save video to ${VIDEO_PATH} using Write tool
            3. Save URL to ${URL_PATH} using Write tool
            4. Verify file creation with Bash tool"
            
            timeout 600 npx @anthropic-ai/claude-code \
              --mcp-config ".claude/mcp-kamuicode.json" \
              --allowedTools "mcp__i2v-kamui-veo3-fast,mcp__i2v-kamui-seedance-v1-lite,Write,Bash" \
              --max-turns 40 \
              --permission-mode "bypassPermissions" \
              -p "$I2V_RECOVERY_PROMPT" || {
                echo "⚠️ MCP recovery failed, using FFmpeg fallback"
                ffmpeg -loop 1 -i "$BG_IMAGE" -c:v libx264 -t 5 -pix_fmt yuv420p -r 30 "$VIDEO_PATH" -y
              }
          else
            echo "⚠️ MCP timeout risk (${ELAPSED_MINUTES} min) - using FFmpeg fallback"
            ffmpeg -loop 1 -i "$BG_IMAGE" -c:v libx264 -t 5 -pix_fmt yuv420p -r 30 "$VIDEO_PATH" -y
          fi
          
          # Download from URL if available
          [ -f "$URL_PATH" ] && curl -L -o "$VIDEO_PATH" "$(cat $URL_PATH)" 2>/dev/null
          
          # Verify recovery result
          if [ -f "$VIDEO_PATH" ]; then
            FILE_SIZE=$(stat -c%s "$VIDEO_PATH" 2>/dev/null || echo 0)
            if [ "$FILE_SIZE" -gt 100000 ] && ffprobe -v error "$VIDEO_PATH" >/dev/null 2>&1; then
              echo "✅ Video recovery successful for scene $SCENE_NUM: ${FILE_SIZE} bytes"
            else
              echo "❌ Video recovery failed for scene $SCENE_NUM: ${FILE_SIZE} bytes"
            fi
          else
            echo "❌ Video recovery failed for scene $SCENE_NUM: no file created"
          fi

      - name: Upload Recovery Video Data
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: video-recovery-scene-${{ matrix.scene }}
          path: ${{ needs.setup.outputs.project_dir }}/media/videos/

  final-composition:
    needs: [check-trigger, setup, scene-video-generation, lipsync-assembly, editing-plan, video-recovery]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      !cancelled() &&
      (needs.video-recovery.result == 'success' || needs.video-recovery.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      final_video: ${{ steps.compose.outputs.final_video }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download All Assets
        uses: actions/download-artifact@v4
        with:
          pattern: "*-data*"
          path: ${{ needs.setup.outputs.project_dir }}/
          merge-multiple: true

      - name: Download Video Recovery Artifacts (if available)
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          pattern: video-recovery-scene-*
          path: ${{ needs.setup.outputs.project_dir }}/
          merge-multiple: true

      - name: Install FFmpeg and Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq

      - name: Compose Final Video
        id: compose
        run: |
          mkdir -p "${{ needs.setup.outputs.project_dir }}/final"
          
          # List available assets
          echo "=== Available Assets ==="
          find "${{ needs.setup.outputs.project_dir }}" -type f -name "*.mp4" -o -name "*.png" -o -name "*.mp3" -o -name "*.wav" | sort
          
          # Find and validate background videos (post-recovery validation)
          echo "🔍 Post-recovery video validation..."
          VALID_VIDEOS=""
          TOTAL_DURATION=0
          
          for video in $(find "${{ needs.setup.outputs.project_dir }}" -name "*scene*.mp4" -type f | sort); do
            if [ -f "$video" ]; then
              # Quick validation (files should be valid after recovery)
              FILE_SIZE=$(stat -c%s "$video" 2>/dev/null || echo 0)
              if [ "$FILE_SIZE" -gt 100000 ]; then
                if ffprobe -v error -show_entries format=duration -of csv=p=0 "$video" >/dev/null 2>&1; then
                  DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$video" 2>/dev/null || echo "0")
                  if python3 -c "import sys; sys.exit(0 if float('$DURATION') >= 3.0 else 1)" 2>/dev/null; then
                    echo "✅ Valid video: $video (${FILE_SIZE} bytes, ${DURATION}s)"
                    VALID_VIDEOS="$VALID_VIDEOS $video"
                    TOTAL_DURATION=$(python3 -c "print(float('$TOTAL_DURATION') + float('$DURATION'))" 2>/dev/null || echo "$TOTAL_DURATION")
                  else
                    echo "⚠️ Unexpected short video after recovery: $video (${DURATION}s)"
                    # Note: This should not happen after successful recovery
                  fi
                else
                  echo "⚠️ Unexpected corrupted video after recovery: $video"
                  # Note: This should not happen after successful recovery
                fi
              else
                echo "⚠️ Unexpected small video after recovery: $video (${FILE_SIZE} bytes)"
              fi
            fi
          done
          
          echo "📊 Post-recovery summary:"
          echo "- Valid videos found: $(echo $VALID_VIDEOS | wc -w)"
          echo "- Total duration: ${TOTAL_DURATION}s"
          
          BACKGROUND_VIDEOS="$VALID_VIDEOS"
          
          # Validate lipsync video
          LIPSYNC_CANDIDATES=$(find "${{ needs.setup.outputs.project_dir }}" -name "*lipsync*.mp4" -type f)
          LIPSYNC_VIDEO=""
          for video in $LIPSYNC_CANDIDATES; do
            if [ -f "$video" ]; then
              FILE_SIZE=$(stat -c%s "$video" 2>/dev/null || echo 0)
              if [ "$FILE_SIZE" -gt 100000 ]; then
                if ffprobe -v error -show_entries format=duration -of csv=p=0 "$video" >/dev/null 2>&1; then
                  echo "✅ Valid lipsync video: $video"
                  LIPSYNC_VIDEO="$video"
                  break
                else
                  echo "⚠️ Skipping corrupted lipsync video: $video (missing moov atom)"
                fi
              else
                echo "⚠️ Skipping small lipsync video: $video (${FILE_SIZE} bytes)"
              fi
            fi
          done
          
          AUDIO_FILE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*.mp3" -o -name "*.wav" | head -1)
          
          FINAL_OUTPUT="${{ needs.setup.outputs.project_dir }}/final/news_video_final.mp4"
          
          if [ -n "$BACKGROUND_VIDEOS" ] && [ -n "$LIPSYNC_VIDEO" ] && [ -f "$LIPSYNC_VIDEO" ]; then
            echo "✅ Found assets for composition"
            
            # Create video list for concatenation
            VIDEO_LIST="${{ needs.setup.outputs.project_dir }}/final/video_list.txt"
            echo -n > "$VIDEO_LIST"
            
            # Add background videos to list
            for video in $BACKGROUND_VIDEOS; do
              if [ -f "$video" ]; then
                echo "file '$video'" >> "$VIDEO_LIST"
              fi
            done
            
            # Concatenate background videos
            CONCAT_BG="${{ needs.setup.outputs.project_dir }}/final/background_concat.mp4"
            if [ -s "$VIDEO_LIST" ]; then
              ffmpeg -f concat -safe 0 -i "$VIDEO_LIST" -c copy "$CONCAT_BG" -y
            else
              echo "⚠️ No valid background videos, using fallback"
              ffmpeg -f lavfi -i color=blue:size=1920x1080:duration=${{ needs.setup.outputs.duration }} -r 30 "$CONCAT_BG" -y
            fi
            
            # Overlay anchor video (picture-in-picture)
            if [ -f "$CONCAT_BG" ] && [ -f "$LIPSYNC_VIDEO" ]; then
              ffmpeg -i "$CONCAT_BG" -i "$LIPSYNC_VIDEO" \
                -filter_complex "[1:v]scale=480:270[anchor];[0:v][anchor]overlay=W-w-20:H-h-20[v]" \
                -map "[v]" -map "1:a" -c:v libx264 -c:a aac -t ${{ needs.setup.outputs.duration }} \
                "$FINAL_OUTPUT" -y
            else
              echo "⚠️ Missing video files, creating simple output"
              cp "$LIPSYNC_VIDEO" "$FINAL_OUTPUT" 2>/dev/null || {
                ffmpeg -f lavfi -i testsrc=duration=${{ needs.setup.outputs.duration }}:size=1920x1080:rate=30 \
                  -f lavfi -i sine=frequency=1000:duration=${{ needs.setup.outputs.duration }} \
                  -c:v libx264 -c:a aac "$FINAL_OUTPUT" -y
              }
            fi
          else
            echo "⚠️ Missing essential assets, creating fallback video"
            # Create fallback news video (fixed FFmpeg syntax)
            ffmpeg -f lavfi -i color=darkblue:size=1920x1080:duration=${{ needs.setup.outputs.duration }} \
              -f lavfi -i sine=frequency=440:duration=${{ needs.setup.outputs.duration }} \
              -filter_complex "[0:v]drawtext=text='News Video\: ${{ needs.setup.outputs.news_topic }}':fontsize=48:fontcolor=white:x=(w-text_w)/2:y=(h-text_h)/2[v]" \
              -map "[v]" -map "1:a" -c:v libx264 -c:a aac "$FINAL_OUTPUT" -y
          fi
          
          # Verify final video
          if [ -f "$FINAL_OUTPUT" ]; then
            FILE_SIZE=$(stat -c%s "$FINAL_OUTPUT" 2>/dev/null || echo 0)
            DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$FINAL_OUTPUT" 2>/dev/null || echo "0")
            
            echo "✅ Final video created:"
            echo "- Path: $FINAL_OUTPUT"
            echo "- Size: $FILE_SIZE bytes"
            echo "- Duration: ${DURATION}s"
            
            echo "final_video=$FINAL_OUTPUT" >> $GITHUB_OUTPUT
          else
            echo "❌ Final video creation failed"
            echo "final_video=" >> $GITHUB_OUTPUT
          fi

      - name: Upload Final Video
        uses: actions/upload-artifact@v4
        with:
          name: final-video
          path: ${{ needs.setup.outputs.project_dir }}/final/

  quality-verification:
    needs: [check-trigger, setup, final-composition]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      needs.final-composition.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 8
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Final Video
        uses: actions/download-artifact@v4
        with:
          name: final-video
          path: ${{ needs.setup.outputs.project_dir }}/final/

      - name: Verify Video Quality
        run: |
          FINAL_VIDEO="${{ needs.final-composition.outputs.final_video }}"
          
          if [ -n "$FINAL_VIDEO" ] && [ -f "$FINAL_VIDEO" ]; then
            echo "=== Quality Verification ==="
            
            # Check file size
            FILE_SIZE=$(stat -c%s "$FINAL_VIDEO" 2>/dev/null || echo 0)
            echo "File size: $FILE_SIZE bytes"
            
            # Check video properties
            ffprobe -v error -select_streams v:0 -show_entries stream=width,height,r_frame_rate,duration -of csv=p=0 "$FINAL_VIDEO" 2>/dev/null || echo "Video probe failed"
            
            # Check audio properties
            ffprobe -v error -select_streams a:0 -show_entries stream=codec_name,sample_rate,channels -of csv=p=0 "$FINAL_VIDEO" 2>/dev/null || echo "Audio probe failed"
            
            if [ "$FILE_SIZE" -gt 1000000 ]; then
              echo "✅ Video quality verification passed"
            else
              echo "⚠️ Video file seems small, but process completed"
            fi
          else
            echo "❌ No final video found for verification"
          fi
          
          # Create execution summary
          SUMMARY_FILE="${{ needs.setup.outputs.project_dir }}/final/execution_summary.txt"
          {
            echo "=== News Video Creation Summary ==="
            echo "Topic: ${{ needs.setup.outputs.news_topic }}"
            echo "Category: ${{ needs.setup.outputs.news_category }}"
            echo "Duration: ${{ needs.setup.outputs.duration }}s"
            echo "Scenes: ${{ needs.setup.outputs.scene_count }}"
            echo "Completion: $(date)"
            echo ""
            echo "Generated Assets:"
            find "${{ needs.setup.outputs.project_dir }}" -type f -name "*.mp4" -o -name "*.png" -o -name "*.mp3" -o -name "*.wav" -o -name "*.json" | sort
          } > "$SUMMARY_FILE"
          
          echo "✅ Quality verification completed"

      - name: Final Status Summary
        if: always()
        run: |
          echo "## 🎬 News Video Creation Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Topic:** ${{ needs.setup.outputs.news_topic }}" >> $GITHUB_STEP_SUMMARY
          echo "**Category:** ${{ needs.setup.outputs.news_category }}" >> $GITHUB_STEP_SUMMARY
          echo "**Duration:** ${{ needs.setup.outputs.duration }}s" >> $GITHUB_STEP_SUMMARY
          echo "**Scenes:** ${{ needs.setup.outputs.scene_count }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Job Status:" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Setup: Complete" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.news-collection.result == 'success' && '✅' || '❌' }} News Collection" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.script-creation.result == 'success' && '✅' || '❌' }} Script Creation" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.narration-generation.result == 'success' && '✅' || '❌' }} Narration Generation" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.anchor-generation.result == 'success' && '✅' || '❌' }} Anchor Generation" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.background-generation.result == 'success' && '✅' || '⚠️' }} Background Generation" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.scene-video-generation.result == 'success' && '✅' || '⚠️' }} Scene Video Generation" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.lipsync-assembly.result == 'success' && '✅' || '❌' }} Lipsync Processing (Matrix)" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.final-composition.result == 'success' && '✅' || '❌' }} Final Composition" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Final Video:** ${{ needs.final-composition.outputs.final_video || 'Not available' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "📁 **Artifacts:** All generated files are available in workflow artifacts" >> $GITHUB_STEP_SUMMARY
