name: News Video Creation Workflow

on:
  workflow_dispatch:
    inputs:
      news_topic:
        description: 'ニュースのトピック'
        required: true
        default: '最新AI技術の進歩'
        type: string
      duration:
        description: '動画の長さ'
        required: true
        default: '60s'
        type: choice
        options:
          - '15s'
          - '30s'
          - '60s'
          - '90s'
          - '3min'
          - '5min'
      news_category:
        description: 'ニュースカテゴリー'
        required: true
        default: 'technology'
        type: choice
        options:
          - 'technology'
          - 'business'
          - 'science'
          - 'politics'
          - 'health'
          - 'sports'
          - 'entertainment'
      target_platform:
        description: '配信プラットフォーム'
        required: true
        default: 'youtube'
        type: choice
        options:
          - 'youtube'
          - 'instagram'
          - 'tiktok'
          - 'twitter'
      visual_style:
        description: 'ビジュアルスタイル'
        required: true
        default: 'cinematic'
        type: choice
        options:
          - 'cinematic'
          - 'documentary'
          - 'corporate'
      enable_fallback:
        description: 'フォールバック処理を有効にする'
        required: true
        default: true
        type: boolean
  push:
    paths-ignore:
      - '.github/workflows/**'

env:
  PROJECT_DIR: /home/runner/work/kamuicode_meta/kamuicode_meta/projects/issue-66-20250818-025742

jobs:
  check-trigger:
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
    steps:
      - name: Check Event Type
        id: check
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            echo "should_run=false" >> $GITHUB_OUTPUT
            echo "Skipping workflow for push event"
          else
            echo "should_run=true" >> $GITHUB_OUTPUT
          fi

  setup:
    needs: check-trigger
    if: needs.check-trigger.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      project_dir: ${{ steps.setup.outputs.project_dir }}
      news_topic: ${{ steps.setup.outputs.news_topic }}
      news_category: ${{ steps.setup.outputs.news_category }}
      duration: ${{ steps.setup.outputs.duration }}
      scene_count: ${{ steps.setup.outputs.scene_count }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install Dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y jq

      - name: Setup Project Environment
        id: setup
        run: |
          # Create project directory structure
          mkdir -p "${PROJECT_DIR}"
          mkdir -p "${PROJECT_DIR}/metadata"
          mkdir -p "${PROJECT_DIR}/media/images"
          mkdir -p "${PROJECT_DIR}/media/videos"
          mkdir -p "${PROJECT_DIR}/media/audio"
          mkdir -p "${PROJECT_DIR}/logs"
          mkdir -p "${PROJECT_DIR}/final"
          
          # Extract duration seconds
          DURATION_INPUT="${{ github.event.inputs.duration || '60s' }}"
          case "$DURATION_INPUT" in
            "15s") DURATION_SECONDS=15 ;;
            "30s") DURATION_SECONDS=30 ;;
            "60s") DURATION_SECONDS=60 ;;
            "90s") DURATION_SECONDS=90 ;;
            "3min") DURATION_SECONDS=180 ;;
            "5min") DURATION_SECONDS=300 ;;
            *) DURATION_SECONDS=60 ;;
          esac
          
          # Calculate scene count (5 seconds per scene)
          SCENE_COUNT=$(( (DURATION_SECONDS + 4) / 5 ))
          
          echo "project_dir=${PROJECT_DIR}" >> $GITHUB_OUTPUT
          echo "news_topic=${{ github.event.inputs.news_topic || '最新AI技術の進歩' }}" >> $GITHUB_OUTPUT
          echo "news_category=${{ github.event.inputs.news_category || 'technology' }}" >> $GITHUB_OUTPUT
          echo "duration=${DURATION_SECONDS}" >> $GITHUB_OUTPUT
          echo "scene_count=${SCENE_COUNT}" >> $GITHUB_OUTPUT
          
          echo "✅ Project setup complete:"
          echo "- Project Dir: ${PROJECT_DIR}"
          echo "- Topic: ${{ github.event.inputs.news_topic || '最新AI技術の進歩' }}"
          echo "- Category: ${{ github.event.inputs.news_category || 'technology' }}"
          echo "- Duration: ${DURATION_SECONDS}s"
          echo "- Scene Count: ${SCENE_COUNT}"

  news-collection:
    needs: [check-trigger, setup]
    if: needs.check-trigger.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 8
    outputs:
      news_summary: ${{ steps.collect.outputs.news_summary }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Collect News Information
        id: collect
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          TOPIC="${{ needs.setup.outputs.news_topic }}"
          CATEGORY="${{ needs.setup.outputs.news_category }}"
          
          SEARCH_PROMPT="Collect news information:
          Topic: ${TOPIC}
          Category: ${CATEGORY}
          Requirements:
          1. Search for latest news using WebSearch tool
          2. Get recent articles using NewsAPI if available
          3. Compile 5-7 key points about the topic
          4. Save summary to ${{ needs.setup.outputs.project_dir }}/metadata/news_summary.json
          5. Include source URLs and credibility scores
          6. Verify save with ls -la ${{ needs.setup.outputs.project_dir }}/metadata/"
          
          npx @anthropic-ai/claude-code \
            --mcp-config ".claude/mcp-kamuicode.json" \
            --allowedTools "WebSearch,mcp__newsapi-*,Write,Bash" \
            --max-turns 40 \
            --permission-mode "bypassPermissions" \
            -p "$SEARCH_PROMPT" || {
              echo "⚠️ News collection failed, creating fallback summary"
              {
                echo '{'
                echo '  "topic": "'$TOPIC'",'
                echo '  "category": "'$CATEGORY'",'
                echo '  "key_points": ['
                echo '    "最新の'$TOPIC'に関する重要な発展",'
                echo '    "業界への影響と今後の展望",'
                echo '    "専門家による分析と見解",'
                echo '    "技術的な詳細と応用可能性",'
                echo '    "社会的意義と課題"'
                echo '  ],'
                echo '  "sources": ["fallback"],'
                echo '  "credibility_score": 0.7'
                echo '}'
              } > "${{ needs.setup.outputs.project_dir }}/metadata/news_summary.json"
            }
          
          # Verify and read summary
          ls -la "${{ needs.setup.outputs.project_dir }}/metadata/"
          if [ -f "${{ needs.setup.outputs.project_dir }}/metadata/news_summary.json" ]; then
            # Try to extract key_points, but handle different JSON structures
            SUMMARY=$(cat "${{ needs.setup.outputs.project_dir }}/metadata/news_summary.json" | jq -r '
              if .key_points then
                .key_points | if type == "array" then join("; ") else . end
              elif .summary then
                .summary
              elif .content then
                .content
              else
                "AI technology latest developments and analysis"
              end' 2>/dev/null || echo "Latest ${TOPIC} developments")
            # Clean up the summary - remove newlines and ensure single line
            SUMMARY=$(echo "$SUMMARY" | tr '\n' ' ' | tr -s ' ')
            echo "news_summary<<EOF" >> $GITHUB_OUTPUT
            echo "$SUMMARY" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "✅ News collection completed"
          else
            echo "news_summary<<EOF" >> $GITHUB_OUTPUT
            echo "Latest ${TOPIC} developments and industry impact" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "⚠️ Using fallback summary"
          fi

      - name: Upload News Data
        uses: actions/upload-artifact@v4
        with:
          name: news-data
          path: ${{ needs.setup.outputs.project_dir }}/metadata/

  script-creation:
    needs: [check-trigger, setup, news-collection]
    if: needs.check-trigger.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 8
    outputs:
      script_ready: ${{ steps.script.outputs.script_ready }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download News Data
        uses: actions/download-artifact@v4
        with:
          name: news-data
          path: ${{ needs.setup.outputs.project_dir }}/metadata/

      - name: Create News Script
        id: script
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          TOPIC="${{ needs.setup.outputs.news_topic }}"
          DURATION="${{ needs.setup.outputs.duration }}"
          SCENE_COUNT="${{ needs.setup.outputs.scene_count }}"
          
          SCRIPT_PROMPT="Create professional news script:
          Topic: ${TOPIC}
          Duration: ${DURATION} seconds
          Scene count: ${SCENE_COUNT}
          Structure: Introduction (0-3s hook) + Main content (3-${DURATION}s)
          Requirements:
          1. Read news summary from ${{ needs.setup.outputs.project_dir }}/metadata/news_summary.json
          2. Create engaging ${DURATION}-second news script
          3. Divide into ${SCENE_COUNT} scenes (5 seconds each)
          4. Include professional news anchor narration
          5. Save script to ${{ needs.setup.outputs.project_dir }}/metadata/news_script.json
          6. Include scene descriptions for visual generation
          7. Save narration text to ${{ needs.setup.outputs.project_dir }}/metadata/narration_text.txt
          8. Verify with ls -la"
          
          npx @anthropic-ai/claude-code \
            --allowedTools "Read,Write,Bash" \
            --max-turns 40 \
            --permission-mode "bypassPermissions" \
            -p "$SCRIPT_PROMPT" || {
              echo "⚠️ Script creation failed, creating fallback"
              
              # Create fallback script
              {
                echo '{'
                echo '  "title": "'$TOPIC'",'
                echo '  "total_duration": '$DURATION','
                echo '  "scene_count": '$SCENE_COUNT','
                echo '  "scenes": ['
                for i in $(seq 1 $SCENE_COUNT); do
                  if [ $i -eq 1 ]; then
                    echo '    {"scene": '$i', "duration": 5, "narration": "今日のニュースです。'$TOPIC'について最新の情報をお伝えします。", "visual": "News studio with professional anchor"}'
                  elif [ $i -eq $SCENE_COUNT ]; then
                    echo '    {"scene": '$i', "duration": 5, "narration": "以上、'$TOPIC'に関するニュースでした。", "visual": "Professional news studio conclusion"}'
                  else
                    echo '    {"scene": '$i', "duration": 5, "narration": "'$TOPIC'の詳細な分析と影響について。", "visual": "News background with graphics"}'
                  fi
                  [ $i -lt $SCENE_COUNT ] && echo ','
                done
                echo '  ]'
                echo '}'
              } > "${{ needs.setup.outputs.project_dir }}/metadata/news_script.json"
              
              # Create narration text
              echo "今日のニュースです。${TOPIC}について最新の情報をお伝えします。${TOPIC}の詳細な分析と影響について専門家の見解をご紹介します。以上、${TOPIC}に関するニュースでした。" > "${{ needs.setup.outputs.project_dir }}/metadata/narration_text.txt"
            }
          
          # Verify files
          ls -la "${{ needs.setup.outputs.project_dir }}/metadata/"
          
          if [ -f "${{ needs.setup.outputs.project_dir }}/metadata/news_script.json" ] && [ -f "${{ needs.setup.outputs.project_dir }}/metadata/narration_text.txt" ]; then
            echo "script_ready=true" >> $GITHUB_OUTPUT
            echo "✅ Script creation completed"
          else
            echo "script_ready=false" >> $GITHUB_OUTPUT
            echo "❌ Script creation failed"
          fi

      - name: Upload Script Data
        uses: actions/upload-artifact@v4
        with:
          name: script-data
          path: ${{ needs.setup.outputs.project_dir }}/metadata/

  narration-generation:
    needs: [check-trigger, setup, script-creation]
    if: needs.check-trigger.outputs.should_run == 'true' && needs.script-creation.outputs.script_ready == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 8
    outputs:
      narration_ready: ${{ steps.narration.outputs.narration_ready }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Script Data
        uses: actions/download-artifact@v4
        with:
          name: script-data
          path: ${{ needs.setup.outputs.project_dir }}/metadata/

      - name: Generate Narration Audio
        id: narration
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          mkdir -p "${{ needs.setup.outputs.project_dir }}/media/audio"
          
          # Read narration text
          if [ -f "${{ needs.setup.outputs.project_dir }}/metadata/narration_text.txt" ]; then
            NARRATION_TEXT=$(cat "${{ needs.setup.outputs.project_dir }}/metadata/narration_text.txt")
          else
            NARRATION_TEXT="今日のニュースです。${{ needs.setup.outputs.news_topic }}について最新の情報をお伝えします。"
          fi
          
          AUDIO_PATH="${{ needs.setup.outputs.project_dir }}/media/audio/narration.mp3"
          
          TTS_PROMPT="Generate professional Japanese news narration:
          Text: '${NARRATION_TEXT}'
          Voice: Professional Japanese female news anchor
          Output: ${AUDIO_PATH}
          Requirements:
          1. Use MCP TTS tool for high quality audio
          2. Professional news anchor voice style
          3. Clear pronunciation and appropriate pace
          4. Save to ${AUDIO_PATH} using Write tool
          5. Verify with ls -la ${{ needs.setup.outputs.project_dir }}/media/audio/"
          
          npx @anthropic-ai/claude-code \
            --mcp-config ".claude/mcp-kamuicode.json" \
            --allowedTools "mcp__t2s-*,Write,Bash" \
            --max-turns 40 \
            --permission-mode "bypassPermissions" \
            -p "$TTS_PROMPT" || {
              echo "⚠️ MCP TTS failed, using local fallback"
              
              # Install espeak-ng for fallback
              sudo apt-get update && sudo apt-get install -y espeak-ng
              
              # Generate fallback narration
              espeak-ng "$NARRATION_TEXT" -w "${AUDIO_PATH}" -s 150 -v ja || {
                echo "⚠️ Fallback TTS failed, using placeholder"
                # Create a short silence as placeholder
                ffmpeg -f lavfi -i anullsrc=duration=5 -ar 44100 -ac 2 "${AUDIO_PATH}" -y
              }
            }
          
          # Verify audio file
          ls -la "${{ needs.setup.outputs.project_dir }}/media/audio/"
          
          AUDIO_FILE=$(find "${{ needs.setup.outputs.project_dir }}/media/audio/" -name "*.mp3" -o -name "*.wav" 2>/dev/null | head -1)
          if [ -n "$AUDIO_FILE" ] && [ -f "$AUDIO_FILE" ]; then
            FILE_SIZE=$(stat -c%s "$AUDIO_FILE" 2>/dev/null || echo 0)
            if [ "$FILE_SIZE" -gt 1000 ]; then
              echo "narration_ready=true" >> $GITHUB_OUTPUT
              echo "✅ Narration generated: $AUDIO_FILE ($FILE_SIZE bytes)"
            else
              echo "narration_ready=false" >> $GITHUB_OUTPUT
              echo "⚠️ Narration file too small: $FILE_SIZE bytes"
            fi
          else
            echo "narration_ready=false" >> $GITHUB_OUTPUT
            echo "❌ Narration generation failed"
          fi

      - name: Upload Audio Data
        uses: actions/upload-artifact@v4
        with:
          name: audio-data
          path: ${{ needs.setup.outputs.project_dir }}/media/audio/

  anchor-generation:
    needs: [check-trigger, setup]
    if: needs.check-trigger.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 8
    outputs:
      anchor_ready: ${{ steps.anchor.outputs.anchor_ready }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install ImageMagick
        run: |
          sudo apt-get update
          sudo apt-get install -y imagemagick

      - name: Generate News Anchor
        id: anchor
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          mkdir -p "${{ needs.setup.outputs.project_dir }}/media/images"
          
          ANCHOR_PATH="${{ needs.setup.outputs.project_dir }}/media/images/news_anchor.png"
          URL_PATH="${{ needs.setup.outputs.project_dir }}/media/images/news_anchor-url.txt"
          
          ANCHOR_PROMPT="Generate professional Japanese news anchor:
          Description: Professional Japanese female news anchor, 30s, business suit, front-facing, green screen background, studio lighting, professional appearance
          Seed: 42 (for consistency)
          Output: ${ANCHOR_PATH}
          Requirements:
          1. Generate with MCP T2I tool (mcp__t2i-kamui-imagen3__imagen_t2i)
          2. Save image to ${ANCHOR_PATH} using Write tool
          3. Save Google Cloud URL to ${URL_PATH} using Write tool
          4. Execute ls -la ${{ needs.setup.outputs.project_dir }}/media/images/ using Bash tool"
          
          npx @anthropic-ai/claude-code \
            --mcp-config ".claude/mcp-kamuicode.json" \
            --allowedTools "mcp__t2i-*,Write,Bash" \
            --max-turns 40 \
            --permission-mode "bypassPermissions" \
            -p "$ANCHOR_PROMPT" || {
              echo "⚠️ Anchor generation failed, creating placeholder"
              # Create placeholder image
              convert -size 1920x1080 xc:green -pointsize 72 -fill white -gravity center -annotate +0+0 "News Anchor" "${ANCHOR_PATH}"
            }
          
          # Download from URL if available
          [ -f "$URL_PATH" ] && curl -L -o "$ANCHOR_PATH" "$(cat $URL_PATH)" 2>/dev/null
          
          # Validate anchor generation by checking URL file
          if [ -f "$URL_PATH" ]; then
            ANCHOR_URL=$(cat "$URL_PATH")
            if [ -n "$ANCHOR_URL" ]; then
              echo "anchor_ready=true" >> $GITHUB_OUTPUT
              echo "anchor_url=$ANCHOR_URL" >> $GITHUB_OUTPUT
              echo "✅ Anchor generated successfully: $ANCHOR_URL"
            else
              echo "anchor_ready=false" >> $GITHUB_OUTPUT
              echo "⚠️ Anchor URL file is empty"
            fi
          else
            echo "anchor_ready=false" >> $GITHUB_OUTPUT
            echo "❌ Anchor URL file not found"
          fi

      - name: Upload Anchor Data
        uses: actions/upload-artifact@v4
        with:
          name: anchor-data
          path: ${{ needs.setup.outputs.project_dir }}/media/images/

  background-generation:
    needs: [check-trigger, setup, script-creation]
    if: needs.check-trigger.outputs.should_run == 'true' && needs.script-creation.outputs.script_ready == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 12
    strategy:
      matrix:
        scene: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
      fail-fast: false
    continue-on-error: true
    outputs:
      failed_scenes: ${{ steps.collect-failures.outputs.failed_scenes }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Script Data
        uses: actions/download-artifact@v4
        with:
          name: script-data
          path: ${{ needs.setup.outputs.project_dir }}/metadata/

      - name: Install ImageMagick
        run: |
          sudo apt-get update
          sudo apt-get install -y imagemagick

      - name: Generate Background for Scene ${{ matrix.scene }}
        id: background
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          SCENE_NUM=${{ matrix.scene }}
          SCENE_COUNT=${{ needs.setup.outputs.scene_count }}
          
          # Skip if scene number exceeds calculated count  
          if [ $SCENE_NUM -gt $SCENE_COUNT ]; then
            echo "Skipping scene $SCENE_NUM (exceeds count $SCENE_COUNT)"
            # Mark as skipped, not failed
            echo "scene_${SCENE_NUM}_skipped=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          mkdir -p "${{ needs.setup.outputs.project_dir }}/media/images"
          
          # Extract scene description from script
          SCENE_DESC="Professional news studio background, no people, clean modern design"
          if [ -f "${{ needs.setup.outputs.project_dir }}/metadata/news_script.json" ]; then
            SCENE_DESC=$(jq -r ".scenes[$((SCENE_NUM-1))].visual // \"Professional news studio background\"" "${{ needs.setup.outputs.project_dir }}/metadata/news_script.json" 2>/dev/null || echo "Professional news studio background")
          fi
          
          BG_PATH="${{ needs.setup.outputs.project_dir }}/media/images/background_scene${SCENE_NUM}.png"
          URL_PATH="${{ needs.setup.outputs.project_dir }}/media/images/background_scene${SCENE_NUM}-url.txt"
          
          BACKGROUND_PROMPT="Generate news background for scene ${SCENE_NUM}:
          Description: ${SCENE_DESC}, no people, professional lighting, news studio style
          Style: ${{ github.event.inputs.visual_style || 'cinematic' }}
          Output: ${BG_PATH}
          Requirements:
          1. Generate with MCP T2I tool
          2. No human figures (background only)
          3. Professional news studio aesthetic
          4. Save to ${BG_PATH} using Write tool
          5. Save URL to ${URL_PATH} using Write tool
          6. Verify with ls -la"
          
          # Retry mechanism for MCP background generation
          RETRY_COUNT=0
          MAX_RETRIES=2
          SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$SUCCESS" = "false" ]; do
            echo "🔄 Background generation attempt $((RETRY_COUNT + 1))/$MAX_RETRIES for scene $SCENE_NUM"
            
            if npx @anthropic-ai/claude-code \
              --mcp-config ".claude/mcp-kamuicode.json" \
              --allowedTools "mcp__t2i-*,Write,Bash" \
              --max-turns 40 \
              --permission-mode "bypassPermissions" \
              -p "$BACKGROUND_PROMPT"; then
              
              echo "✅ Background generation command completed for scene $SCENE_NUM"
              SUCCESS=true
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "⚠️ Background generation attempt $RETRY_COUNT failed for scene $SCENE_NUM"
              
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "🔄 Retrying with modified prompt..."
                BACKGROUND_PROMPT="Generate news background for scene ${SCENE_NUM} (retry):
                Description: ${SCENE_DESC}, no people, professional lighting, news studio style
                Style: professional newsroom
                Output: ${BG_PATH}
                Requirements:
                1. Generate with MCP T2I tool (different seed)
                2. No human figures (background only)
                3. Professional news studio aesthetic
                4. Save to ${BG_PATH} using Write tool
                5. Save URL to ${URL_PATH} using Write tool
                6. Verify with ls -la
                Note: This is retry attempt $((RETRY_COUNT + 1))"
                sleep 5  # Wait before retry
              fi
            fi
          done
          
          if [ "$SUCCESS" = "false" ]; then
            echo "❌ All background generation attempts failed for scene $SCENE_NUM"
            echo "scene_${SCENE_NUM}_failed=true" >> $GITHUB_OUTPUT
            # Don't exit 1 here - let continue-on-error handle it
          fi
          
          # Download from URL if available (with error handling)
          if [ -f "$URL_PATH" ]; then
            echo "📥 Downloading background image from URL for scene $SCENE_NUM"
            if curl -L -o "$BG_PATH" "$(cat "$URL_PATH")" 2>/dev/null; then
              echo "✅ URL download successful"
            else
              echo "⚠️ URL download failed, using locally generated file"
            fi
          fi
          
          # Enhanced image verification with multiple patterns
          echo "🔍 Verifying background image for scene $SCENE_NUM"
          BG_IMAGE=""
          
          # Try multiple search patterns
          BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*scene${SCENE_NUM}*.png" -type f 2>/dev/null | head -1)
          if [ -z "$BG_IMAGE" ]; then
            BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*background*.png" -mmin -2 2>/dev/null | head -1)
          fi
          if [ -z "$BG_IMAGE" ]; then
            BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*.png" -mmin -1 2>/dev/null | head -1)
          fi
          
          # Save original generation metadata for recovery
          echo "📝 Saving recovery metadata for scene $SCENE_NUM"
          echo "{" > "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "  \"scene\": ${SCENE_NUM}," >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "  \"item_type\": \"IMAGE\"," >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "  \"item_name\": \"background\"," >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "  \"original_prompt\": \"${SCENE_DESC}\"," >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "  \"mcp_tools\": [\"mcp__t2i-*\"]," >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "  \"fallback_method\": \"imagemagick\"," >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "  \"execution_time\": \"$(date -Iseconds)\"" >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          echo "}" >> "${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"

          # Validate found image
          VALIDATION_SUCCESS=false
          if [ -n "$BG_IMAGE" ] && [ -f "$BG_IMAGE" ]; then
            FILE_SIZE=$(stat -c%s "$BG_IMAGE" 2>/dev/null || echo 0)
            if [ "$FILE_SIZE" -gt 10000 ]; then
              echo "✅ Background generated for scene $SCENE_NUM: $BG_IMAGE (${FILE_SIZE} bytes)"
              echo "scene_${SCENE_NUM}_background_status=SUCCESS" >> $GITHUB_OUTPUT
              echo "scene_${SCENE_NUM}_background_file=$BG_IMAGE" >> $GITHUB_OUTPUT
              VALIDATION_SUCCESS=true
            else
              echo "⚠️ Background file too small for scene $SCENE_NUM (${FILE_SIZE} bytes)"
              echo "scene_${SCENE_NUM}_background_status=FAILED" >> $GITHUB_OUTPUT
              echo "scene_${SCENE_NUM}_background_failed=file_too_small" >> $GITHUB_OUTPUT
              echo "scene_${SCENE_NUM}_background_file_size=${FILE_SIZE}" >> $GITHUB_OUTPUT
            fi
          else
            echo "❌ Background image not found for scene $SCENE_NUM"
            echo "scene_${SCENE_NUM}_background_status=FAILED" >> $GITHUB_OUTPUT
            echo "scene_${SCENE_NUM}_background_failed=file_not_found" >> $GITHUB_OUTPUT
          fi
          
          # Final status report
          if [ "$VALIDATION_SUCCESS" = "true" ]; then
            echo "🎯 Scene $SCENE_NUM background generation completed successfully"
          else
            echo "⚠️ Scene $SCENE_NUM background generation completed with issues (will be handled by recovery system)"
          fi
          
          # Always exit successfully (let continue-on-error and recovery handle failures)
          exit 0

      - name: Collect Failed Items
        id: collect-failures
        if: always()
        run: |
          FAILED_ITEMS="[]"
          FAILED_BACKGROUNDS=""
          
          # Check for status files instead of step outputs
          echo "🔍 Checking background generation artifacts..."
          ls -la ${{ needs.setup.outputs.project_dir }}/all-backgrounds/ 2>/dev/null || echo "No background artifacts found"
          
          # Look for background status files
          for i in {1..12}; do
            if [ $i -le ${{ needs.setup.outputs.scene_count }} ]; then
              # Check if background image exists in artifacts
              BG_FOUND=false
              BG_REASON="unknown"
              
              # Check multiple potential locations
              POSSIBLE_PATHS=(
                "${{ needs.setup.outputs.project_dir }}/all-backgrounds/background-data-scene-${i}/background_scene${i}.png"
                "${{ needs.setup.outputs.project_dir }}/all-backgrounds/background-data-scene-${i}/scene${i}_background.png"
              )
              
              for path in "${POSSIBLE_PATHS[@]}"; do
                if [ -f "$path" ]; then
                  FILE_SIZE=$(stat -c%s "$path" 2>/dev/null || echo 0)
                  if [ "$FILE_SIZE" -gt 10000 ]; then  # Minimum 10KB for valid image
                    BG_FOUND=true
                    echo "✅ Found valid background: scene $i ($FILE_SIZE bytes)"
                    break
                  else
                    BG_REASON="file_too_small"
                  fi
                fi
              done
              
              if [ "$BG_FOUND" = "false" ]; then
                echo "❌ Missing background: scene $i"
                
                # Add to failed backgrounds list
                if [ -z "$FAILED_BACKGROUNDS" ]; then
                  FAILED_BACKGROUNDS="$i"
                else
                  FAILED_BACKGROUNDS="$FAILED_BACKGROUNDS,$i"
                fi
                
                # Add to detailed failed items using simple string construction
                FAILED_ITEMS=$(echo "$FAILED_ITEMS" | jq --arg scene "$i" --arg reason "$BG_REASON" \
                  '. + [{"scene": ($scene | tonumber), "type": "IMAGE", "item": "background", "reason": $reason}]')
              fi
            fi
          done
          
          echo "failed_backgrounds=[${FAILED_BACKGROUNDS}]" >> $GITHUB_OUTPUT
          echo "failed_items=$FAILED_ITEMS" >> $GITHUB_OUTPUT
          
          # Legacy compatibility
          if [ -n "$FAILED_BACKGROUNDS" ]; then
            echo "failed_scenes=[${FAILED_BACKGROUNDS}]" >> $GITHUB_OUTPUT
          else
            echo "failed_scenes=[]" >> $GITHUB_OUTPUT
          fi

      - name: Upload Background Data
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: background-data-scene-${{ matrix.scene }}
          path: ${{ needs.setup.outputs.project_dir }}/media/images/

  collect-background-failures:
    needs: [check-trigger, setup, background-generation]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      failed_backgrounds: ${{ steps.collect.outputs.failed_backgrounds }}
      failed_background_items: ${{ steps.collect.outputs.failed_background_items }}
    steps:
      - name: Download All Background Status Files
        uses: actions/download-artifact@v4
        with:
          pattern: background-data-scene-*
          path: ${{ needs.setup.outputs.project_dir }}/all-backgrounds/

      - name: Collect Failed Backgrounds
        id: collect
        run: |
          FAILED_BACKGROUNDS=""
          FAILED_BACKGROUND_ITEMS="[]"
          
          echo "🔍 Analyzing background generation results for ${{ needs.setup.outputs.scene_count }} scenes"
          
          # Check each scene's background using artifact-based verification (most reliable)
          for i in {1..12}; do
            if [ $i -le ${{ needs.setup.outputs.scene_count }} ]; then
              echo "🔍 Checking scene $i background status..."
              
              # Look for background image files in artifact directories
              BACKGROUND_FOUND=false
              FILE_SIZE=0
              ACTUAL_BG_FILE=""
              
              # Multiple potential locations for background files
              POSSIBLE_PATHS=(
                "${{ needs.setup.outputs.project_dir }}/all-backgrounds/background-data-scene-${i}/media/images/scene${i}.png"
                "${{ needs.setup.outputs.project_dir }}/all-backgrounds/background-data-scene-${i}/scene${i}.png"
                "${{ needs.setup.outputs.project_dir }}/all-backgrounds/background-data-scene-${i}/scene${i}_background.png"
              )
              
              for path in "${POSSIBLE_PATHS[@]}"; do
                if [ -f "$path" ]; then
                  ACTUAL_BG_FILE="$path"
                  FILE_SIZE=$(stat -c%s "$path" 2>/dev/null || echo 0)
                  echo "📁 Found background file: $path (${FILE_SIZE} bytes)"
                  
                  # Validate image file (minimum 50KB for proper image)
                  if [ "$FILE_SIZE" -gt 50000 ]; then
                    # Additional validation: check if it's a valid image
                    if file "$path" | grep -E "(PNG|JPEG|JPG)" >/dev/null 2>&1; then
                      BACKGROUND_FOUND=true
                      echo "✅ Valid background image for scene $i: ${FILE_SIZE} bytes"
                      break
                    else
                      echo "❌ Invalid image format for scene $i"
                    fi
                  else
                    echo "❌ Background file too small for scene $i: ${FILE_SIZE} bytes"
                  fi
                fi
              done
              
              # Mark as failed if no valid background found
              if [ "$BACKGROUND_FOUND" = "false" ]; then
                echo "❌ Scene $i background: FAILED (no valid image found)"
                
                # Add failed scene
                if [ -z "$FAILED_BACKGROUNDS" ]; then
                  FAILED_BACKGROUNDS="$i"
                else
                  FAILED_BACKGROUNDS="$FAILED_BACKGROUNDS,$i"
                fi
                
                # Add to detailed failed items
                FAILED_BACKGROUND_ITEMS=$(echo "$FAILED_BACKGROUND_ITEMS" | jq \
                  --arg scene "$i" \
                  --arg size "$FILE_SIZE" \
                  --arg file "$ACTUAL_BG_FILE" \
                  '. + [{"scene": ($scene | tonumber), "type": "IMAGE", "item": "background", "reason": "validation_failed", "file_size": ($size | tonumber), "file_path": $file}]')
              else
                echo "✅ Scene $i background: SUCCESS"
              fi
            fi
          done
          
          if [ -n "$FAILED_BACKGROUNDS" ]; then
            echo "Failed backgrounds: [$FAILED_BACKGROUNDS]"
            echo "failed_backgrounds=[${FAILED_BACKGROUNDS}]" >> $GITHUB_OUTPUT
          else
            echo "No failed backgrounds"
            echo "failed_backgrounds=[]" >> $GITHUB_OUTPUT
          fi
          
          echo "failed_background_items=$FAILED_BACKGROUND_ITEMS" >> $GITHUB_OUTPUT
          echo "📊 Background failure details: $FAILED_BACKGROUND_ITEMS"

  background-recovery:
    needs: [check-trigger, setup, collect-background-failures]
    if: |
      always() && 
      needs.check-trigger.outputs.should_run == 'true' &&
      needs.collect-background-failures.outputs.failed_backgrounds != '' &&
      needs.collect-background-failures.outputs.failed_backgrounds != '[]'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    strategy:
      matrix:
        scene: ${{ fromJson(needs.collect-background-failures.outputs.failed_backgrounds || '[]') }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Original Metadata
        uses: actions/download-artifact@v4
        with:
          name: background-data-scene-${{ matrix.scene }}
          path: ${{ needs.setup.outputs.project_dir }}/

      - name: Dynamic Background Recovery for Scene ${{ matrix.scene }}
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          SCENE_NUM=${{ matrix.scene }}
          mkdir -p "${{ needs.setup.outputs.project_dir }}/media/images"
          
          # Load original metadata
          METADATA_FILE="${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_background.json"
          if [ -f "$METADATA_FILE" ]; then
            ORIGINAL_PROMPT=$(jq -r '.original_prompt' "$METADATA_FILE")
            echo "📋 Loaded original prompt: $ORIGINAL_PROMPT"
          else
            ORIGINAL_PROMPT="Professional news studio background, no people, clean modern design"
            echo "⚠️ No metadata found, using default prompt"
          fi
          
          BG_PATH="${{ needs.setup.outputs.project_dir }}/media/images/background_scene${SCENE_NUM}_recovery.png"
          
          # Check MCP availability
          WORKFLOW_START="${{ github.run_started_at }}"
          ELAPSED_MINUTES=$(( ($(date +%s) - $(date -d "$WORKFLOW_START" +%s)) / 60 ))
          
          if [ $ELAPSED_MINUTES -lt 12 ]; then
            echo "🔄 MCP available, attempting AI recovery (${ELAPSED_MINUTES}min elapsed)"
            
            RECOVERY_PROMPT="RECOVERY: Background generation for scene ${SCENE_NUM}
            Original prompt: ${ORIGINAL_PROMPT}
            Modified approach: Enhanced with different seed and parameters
            Seed: $((100 + SCENE_NUM + RANDOM % 1000))
            Requirements:
            1. Generate high-quality professional news background
            2. Save to ${BG_PATH} using Write tool
            3. Ensure file size > 10KB
            4. Verify with ls -la command"
            
            npx @anthropic-ai/claude-code \
              --mcp-config ".claude/mcp-kamuicode.json" \
              --allowedTools "mcp__t2i-*,Write,Bash" \
              --max-turns 40 \
              -p "$RECOVERY_PROMPT" || {
                echo "⚠️ MCP recovery failed, using fallback"
                convert -size 1920x1080 gradient:blue-darkblue -pointsize 48 -fill white -gravity center \
                  -annotate +0+0 "News Scene $SCENE_NUM\n(Recovery)" "$BG_PATH"
              }
          else
            echo "⏰ MCP timeout, using ImageMagick fallback (${ELAPSED_MINUTES}min elapsed)"
            convert -size 1920x1080 gradient:navy-lightblue -pointsize 64 -fill white -gravity center \
              -annotate +0+0 "Professional News\nScene $SCENE_NUM" "$BG_PATH"
          fi
          
          # Verify recovery result
          if [ -f "$BG_PATH" ]; then
            FILE_SIZE=$(stat -c%s "$BG_PATH" 2>/dev/null || echo 0)
            if [ "$FILE_SIZE" -gt 10000 ]; then
              echo "✅ Recovery successful: $BG_PATH ($FILE_SIZE bytes)"
              echo "recovery_scene_${SCENE_NUM}_status=SUCCESS" >> $GITHUB_OUTPUT
            else
              echo "❌ Recovery file too small: $FILE_SIZE bytes"
              echo "recovery_scene_${SCENE_NUM}_status=FAILED" >> $GITHUB_OUTPUT
            fi
          else
            echo "❌ Recovery file not created"
            echo "recovery_scene_${SCENE_NUM}_status=FAILED" >> $GITHUB_OUTPUT
          fi

      - name: Upload Recovery Data
        uses: actions/upload-artifact@v4
        with:
          name: background-recovery-scene-${{ matrix.scene }}
          path: ${{ needs.setup.outputs.project_dir }}/media/images/

  scene-video-generation:
    needs: [check-trigger, setup, background-generation, collect-background-failures, background-recovery]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      (needs.background-recovery.result == 'success' || needs.background-recovery.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 25
    strategy:
      matrix:
        scene: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
      fail-fast: false
      max-parallel: 8  # GitHub runner制限対策：同時実行数制限
    continue-on-error: false  # 厳格化：失敗を隠蔽しない
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install FFmpeg and Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq

      - name: Download Background Data
        uses: actions/download-artifact@v4
        with:
          name: background-data-scene-${{ matrix.scene }}
          path: ${{ needs.setup.outputs.project_dir }}/media/images/
        continue-on-error: true

      - name: Generate Video for Scene ${{ matrix.scene }}
        id: video
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          CLAUDE_CODE_MAX_OUTPUT_TOKENS: 16000
        run: |
          SCENE_NUM=${{ matrix.scene }}
          SCENE_COUNT=${{ needs.setup.outputs.scene_count }}
          
          # Skip if scene number exceeds calculated count
          if [ $SCENE_NUM -gt $SCENE_COUNT ]; then
            echo "Skipping video for scene $SCENE_NUM (exceeds count $SCENE_COUNT)"
            exit 0
          fi
          
          mkdir -p "${{ needs.setup.outputs.project_dir }}/media/videos"
          
          # Extract scene description from script for recovery metadata
          SCENE_DESC="Professional news studio background, no people, clean modern design"
          if [ -f "${{ needs.setup.outputs.project_dir }}/metadata/news_script.json" ]; then
            SCENE_DESC=$(jq -r ".scenes[$((SCENE_NUM-1))].visual // \"Professional news studio background\"" "${{ needs.setup.outputs.project_dir }}/metadata/news_script.json" 2>/dev/null || echo "Professional news studio background")
          fi
          
          # Find background image (multiple patterns)
          BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*scene${SCENE_NUM}*.png" -type f 2>/dev/null | head -1)
          [ -z "$BG_IMAGE" ] && BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*background*.png" -mmin -5 2>/dev/null | head -1)
          [ -z "$BG_IMAGE" ] && BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*.png" 2>/dev/null | head -1)
          
          if [ -z "$BG_IMAGE" ] || [ ! -f "$BG_IMAGE" ]; then
            echo "⚠️ No background image found for scene $SCENE_NUM, creating fallback"
            BG_IMAGE="${{ needs.setup.outputs.project_dir }}/media/images/fallback_scene${SCENE_NUM}.png"
            convert -size 1920x1080 gradient:darkblue-blue -pointsize 60 -fill white -gravity center -annotate +0+0 "News Scene $SCENE_NUM" "$BG_IMAGE"
          fi
          
          VIDEO_PATH="${{ needs.setup.outputs.project_dir }}/media/videos/scene${SCENE_NUM}.mp4"
          URL_PATH="${{ needs.setup.outputs.project_dir }}/media/videos/scene${SCENE_NUM}-url.txt"
          
          # 🚨 MCP Connection Time Check (Critical for I2V success)
          WORKFLOW_START="${{ github.run_started_at }}"
          ELAPSED_MINUTES=$(( ($(date +%s) - $(date -d "$WORKFLOW_START" +%s)) / 60 ))
          
          echo "⏱️ Workflow elapsed time: ${ELAPSED_MINUTES} minutes"
          
          if [ $ELAPSED_MINUTES -lt 12 ]; then
            echo "✅ MCP connection viable - attempting I2V generation"
            
            I2V_PROMPT="Convert background image to video for scene ${SCENE_NUM}:
            Input image: ${BG_IMAGE}
            Output video: ${VIDEO_PATH}
            Requirements:
            1. Convert image to 5-second video using MCP I2V tool (preferred: i2v-fal-hailuo-02-fast)
            2. Gentle camera movement suitable for news
            3. 1920x1080 resolution, 30fps
            4. Save video to ${VIDEO_PATH} using Write tool
            5. Save URL to ${URL_PATH} using Write tool
            6. Execute ls -la ${VIDEO_PATH} using Bash tool to verify file creation
            7. Execute ffprobe -v error -show_entries format=duration -of csv=p=0 ${VIDEO_PATH} using Bash tool to verify MP4 structure"
            
            timeout 300 npx @anthropic-ai/claude-code \
              --mcp-config ".claude/mcp-kamuicode.json" \
              --allowedTools "mcp__i2v-*,Write,Bash" \
              --max-turns 60 \
              --permission-mode "bypassPermissions" \
              -p "$I2V_PROMPT" && echo "✅ MCP I2V completed" || {
                echo "⚠️ MCP I2V failed or timed out, using FFmpeg fallback"
                ffmpeg -loop 1 -i "$BG_IMAGE" -c:v libx264 -t 5 -pix_fmt yuv420p -r 30 "$VIDEO_PATH" -y
              }
          else
            echo "⚠️ MCP connection expired (${ELAPSED_MINUTES} min) - using FFmpeg fallback"
            ffmpeg -loop 1 -i "$BG_IMAGE" -c:v libx264 -t 5 -pix_fmt yuv420p -r 30 "$VIDEO_PATH" -y
          fi
          
          # Download from URL if available
          [ -f "$URL_PATH" ] && curl -L -o "$VIDEO_PATH" "$(cat $URL_PATH)" 2>/dev/null
          
          # Verify video
          VIDEO_FILE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*scene${SCENE_NUM}*.mp4" -type f 2>/dev/null | head -1)
          [ -z "$VIDEO_FILE" ] && VIDEO_FILE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*.mp4" -mmin -3 2>/dev/null | head -1)
          
          if [ -n "$VIDEO_FILE" ] && [ -f "$VIDEO_FILE" ]; then
            FILE_SIZE=$(stat -c%s "$VIDEO_FILE" 2>/dev/null || echo 0)
            
            # 🚨 ENHANCED VALIDATION: Comprehensive MP4 structure validation
            VALID_VIDEO=false
            VALIDATION_ERRORS=""
            
            # Check 1: File size validation (stricter threshold)
            if [ "$FILE_SIZE" -le 150000 ]; then
              VALIDATION_ERRORS="file_too_small:${FILE_SIZE}bytes"
              echo "❌ Video file too small for scene $SCENE_NUM: ${FILE_SIZE} bytes (minimum: 150KB)"
            else
              echo "✅ Size check passed: ${FILE_SIZE} bytes"
              
              # Check 2: MP4 structure validation with ffprobe
              if ! ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" >/dev/null 2>&1; then
                VALIDATION_ERRORS="corrupted_mp4:no_moov_atom"
                echo "❌ Video file corrupted (missing moov atom) for scene $SCENE_NUM"
              else
                echo "✅ MP4 structure check passed"
                
                # Check 3: Duration validation
                DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" 2>/dev/null || echo "0")
                if ! python3 -c "import sys; sys.exit(0 if float('$DURATION') >= 3.0 else 1)" 2>/dev/null; then
                  VALIDATION_ERRORS="duration_too_short:${DURATION}s"
                  echo "❌ Video too short for scene $SCENE_NUM: ${DURATION}s (minimum: 3.0s)"
                else
                  echo "✅ Duration check passed: ${DURATION}s"
                  
                  # Check 4: Video stream validation
                  if ! ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0 "$VIDEO_FILE" >/dev/null 2>&1; then
                    VALIDATION_ERRORS="no_video_stream"
                    echo "❌ No valid video stream found in scene $SCENE_NUM"
                  else
                    echo "✅ Video stream check passed"
                    VALID_VIDEO=true
                    echo "🎉 ALL VALIDATIONS PASSED for scene $SCENE_NUM: $VIDEO_FILE (${FILE_SIZE} bytes, ${DURATION}s)"
                  fi
                fi
              fi
            fi
            
            # 🚨 CRITICAL: Strict Recovery System - No tolerance for failure
            if [ "$VALID_VIDEO" = "false" ]; then
              echo "🚨 CRITICAL: Video validation failed for scene $SCENE_NUM: $VALIDATION_ERRORS"
              echo "🔧 Initiating strict multi-level recovery process..."
              
              RECOVERY_SUCCESS=false
              
              # Recovery Level 1: Different MCP service retry (if time permits)
              if [ $ELAPSED_MINUTES -lt 10 ]; then
                echo "🔄 Recovery Level 1: MCP retry with different service"
                RECOVERY_SEED=$((RANDOM + SCENE_NUM * 1000))
                
                # Try alternative I2V service
                RECOVERY_PROMPT="EMERGENCY RECOVERY Scene ${SCENE_NUM}:
                1. Generate 5-second video from $BG_IMAGE using different algorithm
                2. MANDATORY: Save to exact path: ${VIDEO_PATH}
                3. MANDATORY: Ensure file size >200KB and duration >4s
                4. MANDATORY: Use seed ${RECOVERY_SEED} for different result
                5. Execute ffprobe validation immediately after generation"
                
                timeout 180 npx @anthropic-ai/claude-code \
                  --mcp-config ".claude/mcp-kamuicode.json" \
                  --allowedTools "mcp__i2v-*,Write,Bash" \
                  --max-turns 30 \
                  --permission-mode "bypassPermissions" \
                  -p "$RECOVERY_PROMPT" 2>/dev/null && {
                    # Immediate re-validation
                    if [ -f "$VIDEO_FILE" ]; then
                      NEW_SIZE=$(stat -c%s "$VIDEO_FILE" 2>/dev/null || echo 0)
                      if [ "$NEW_SIZE" -gt 200000 ] && ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" >/dev/null 2>&1; then
                        NEW_DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" 2>/dev/null || echo "0")
                        if python3 -c "import sys; sys.exit(0 if float('$NEW_DURATION') >= 4.0 else 1)" 2>/dev/null; then
                          echo "✅ Recovery Level 1 SUCCESS: Scene $SCENE_NUM recovered via MCP retry"
                          RECOVERY_SUCCESS=true
                        fi
                      fi
                    fi
                  }
              fi
              
              # Recovery Level 2: Enhanced FFmpeg fallback (if Level 1 failed)
              if [ "$RECOVERY_SUCCESS" = "false" ]; then
                echo "🔄 Recovery Level 2: Enhanced FFmpeg fallback with narration"
                
                # Create high-quality fallback with scene information
                ffmpeg -loop 1 -i "$BG_IMAGE" \
                  -f lavfi -i sine=frequency=440:duration=5 \
                  -filter_complex "[0:v]scale=1920:1080,drawtext=text='Scene ${SCENE_NUM}':fontsize=72:fontcolor=white:x=(w-text_w)/2:y=(h-text_h)/2:box=1:boxcolor=black@0.5[v]" \
                  -map "[v]" -map "1:a" \
                  -c:v libx264 -c:a aac -t 5 -pix_fmt yuv420p -r 30 \
                  -shortest "$VIDEO_FILE" -y
                
                # Immediate validation of Level 2 fallback
                if [ -f "$VIDEO_FILE" ]; then
                  FALLBACK_SIZE=$(stat -c%s "$VIDEO_FILE" 2>/dev/null || echo 0)
                  if [ "$FALLBACK_SIZE" -gt 150000 ] && ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" >/dev/null 2>&1; then
                    FALLBACK_DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" 2>/dev/null || echo "0")
                    if python3 -c "import sys; sys.exit(0 if float('$FALLBACK_DURATION') >= 4.5 else 1)" 2>/dev/null; then
                      echo "✅ Recovery Level 2 SUCCESS: Scene $SCENE_NUM recovered via FFmpeg fallback"
                      RECOVERY_SUCCESS=true
                    fi
                  fi
                fi
              fi
              
              # 🚨 CRITICAL: Final recovery validation and termination check
              if [ "$RECOVERY_SUCCESS" = "true" ]; then
                echo "🎉 Recovery SUCCESS for scene $SCENE_NUM - continuing workflow"
                VALID_VIDEO=true
              else
                echo "🚨 CRITICAL FAILURE: All recovery attempts failed for scene $SCENE_NUM"
                echo "❌ Recovery Level 1 (MCP retry): FAILED"
                echo "❌ Recovery Level 2 (FFmpeg fallback): FAILED"
                echo "🛑 TERMINATING WORKFLOW - Scene generation failure is not acceptable"
                echo ""
                echo "Error Details:"
                echo "- Original validation error: $VALIDATION_ERRORS"
                echo "- Recovery attempts: 2 levels attempted"
                echo "- Scene: $SCENE_NUM"
                echo "- Time elapsed: ${ELAPSED_MINUTES} minutes"
                echo ""
                echo "🚨 WORKFLOW MUST BE TERMINATED - Cannot proceed with incomplete content"
                exit 1  # Force workflow termination
              fi
            fi
            
            # Final success validation
            if [ "$VALID_VIDEO" = "true" ]; then
              echo "scene_${SCENE_NUM}_video_status=SUCCESS" >> $GITHUB_OUTPUT
              echo "scene_${SCENE_NUM}_video_success=true" >> $GITHUB_OUTPUT
              echo "✅ Scene $SCENE_NUM video generation CONFIRMED SUCCESSFUL"
            else
              echo "scene_${SCENE_NUM}_video_status=FAILED" >> $GITHUB_OUTPUT
              
              # Use validation errors from enhanced validation
              FAILURE_REASON="validation_failed"
              if [ -n "$VALIDATION_ERRORS" ]; then
                FAILURE_REASON="$VALIDATION_ERRORS"
              fi
              
              echo "scene_${SCENE_NUM}_video_failed=$FAILURE_REASON" >> $GITHUB_OUTPUT
              
              # Save enhanced recovery metadata
              METADATA_FILE="${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_video.json"
              echo "{" > "$METADATA_FILE"
              echo "  \"scene\": $SCENE_NUM," >> "$METADATA_FILE"
              echo "  \"item_type\": \"VIDEO\"," >> "$METADATA_FILE"
              echo "  \"item_name\": \"scene_video\"," >> "$METADATA_FILE"
              echo "  \"original_prompt\": \"$(echo "$SCENE_DESC" | sed 's/"/\\"/g')\"," >> "$METADATA_FILE"
              echo "  \"background_image\": \"$(echo "$BG_IMAGE" | sed 's/"/\\"/g')\"," >> "$METADATA_FILE"
              echo "  \"mcp_tools\": [\"mcp__i2v-fal-hailuo-02-fast\", \"mcp__i2v-fal-bytedance-seedance-v1-lite\"]," >> "$METADATA_FILE"
              echo "  \"fallback_method\": \"ffmpeg_enhanced\"," >> "$METADATA_FILE"
              echo "  \"generation_time\": \"$(date -Iseconds)\"," >> "$METADATA_FILE"
              echo "  \"workflow_elapsed_minutes\": $ELAPSED_MINUTES," >> "$METADATA_FILE"
              echo "  \"failure_reason\": \"$FAILURE_REASON\"," >> "$METADATA_FILE"
              echo "  \"file_size\": $FILE_SIZE," >> "$METADATA_FILE"
              echo "  \"validation_errors\": \"$VALIDATION_ERRORS\"," >> "$METADATA_FILE"
              echo "  \"validation_details\": \"Comprehensive MP4 validation: size+structure+duration+stream\"" >> "$METADATA_FILE"
              echo "}" >> "$METADATA_FILE"
            fi
          else
            echo "❌ Video generation failed for scene $SCENE_NUM"
            echo "scene_${SCENE_NUM}_video_status=FAILED" >> $GITHUB_OUTPUT
            echo "scene_${SCENE_NUM}_video_failed=file_not_found" >> $GITHUB_OUTPUT
            
            # Save recovery metadata for video regeneration
            METADATA_FILE="${{ needs.setup.outputs.project_dir }}/recovery_metadata_scene${SCENE_NUM}_video.json"
            echo "{" > "$METADATA_FILE"
            echo "  \"scene\": $SCENE_NUM," >> "$METADATA_FILE"
            echo "  \"item_type\": \"VIDEO\"," >> "$METADATA_FILE"
            echo "  \"item_name\": \"scene_video\"," >> "$METADATA_FILE"
            echo "  \"original_prompt\": \"$(echo "$SCENE_DESC" | sed 's/"/\\"/g')\"," >> "$METADATA_FILE"
            echo "  \"background_image\": \"$(echo "$BG_IMAGE" | sed 's/"/\\"/g')\"," >> "$METADATA_FILE"
            echo "  \"mcp_tools\": [\"mcp__i2v-*\"]," >> "$METADATA_FILE"
            echo "  \"fallback_method\": \"ffmpeg\"," >> "$METADATA_FILE"
            echo "  \"generation_time\": \"$(date -Iseconds)\"," >> "$METADATA_FILE"
            echo "  \"failure_reason\": \"file_not_found\"" >> "$METADATA_FILE"
            echo "}" >> "$METADATA_FILE"
          fi
          
          # Always exit successfully (let continue-on-error and status checks handle failures)
          echo "🎯 Scene $SCENE_NUM video generation step completed"
          exit 0

      - name: Save Video Generation Status
        if: always()
        run: |
          SCENE_NUM=${{ matrix.scene }}
          # Create directory if it doesn't exist
          mkdir -p "${{ needs.setup.outputs.project_dir }}"
          STATUS_FILE="${{ needs.setup.outputs.project_dir }}/video-status-scene${SCENE_NUM}.txt"
          
          # Check if this scene failed by looking for the video file
          VIDEO_FILE="${{ needs.setup.outputs.project_dir }}/media/videos/scene${SCENE_NUM}.mp4"
          
          if [ -f "$VIDEO_FILE" ]; then
            FILE_SIZE=$(stat -c%s "$VIDEO_FILE" 2>/dev/null || echo 0)
            
            # Enhanced validation matching the main validation
            VALID_VIDEO=false
            if [ "$FILE_SIZE" -gt 100000 ]; then
              if ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" >/dev/null 2>&1; then
                DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_FILE" 2>/dev/null || echo "0")
                if python3 -c "import sys; sys.exit(0 if float('$DURATION') >= 3.0 else 1)" 2>/dev/null; then
                  VALID_VIDEO=true
                fi
              fi
            fi
            
            if [ "$VALID_VIDEO" = "true" ]; then
              echo "SUCCESS" > "$STATUS_FILE"
              echo "Scene $SCENE_NUM video generation SUCCESS (size: $FILE_SIZE, duration: ${DURATION}s)"
            else
              echo "FAILED" > "$STATUS_FILE"
              echo "Scene $SCENE_NUM video generation FAILED (validation failed: size=$FILE_SIZE)"
            fi
          else
            echo "FAILED" > "$STATUS_FILE"
            echo "Scene $SCENE_NUM video generation FAILED (no file found)"
          fi

      - name: Upload Video Data
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: video-data-scene-${{ matrix.scene }}
          path: |
            ${{ needs.setup.outputs.project_dir }}/media/videos/
            ${{ needs.setup.outputs.project_dir }}/video-status-scene${{ matrix.scene }}.txt

  lipsync-processing:
    needs: [check-trigger, setup, anchor-generation, narration-generation]
    if: |
      needs.check-trigger.outputs.should_run == 'true' &&
      needs.anchor-generation.outputs.anchor_ready == 'true' &&
      needs.narration-generation.outputs.narration_ready == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 12
    outputs:
      lipsync_ready: ${{ steps.lipsync.outputs.lipsync_ready }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Anchor and Audio Data
        uses: actions/download-artifact@v4
        with:
          name: anchor-data
          path: ${{ needs.setup.outputs.project_dir }}/media/images/

      - name: Download Audio Data
        uses: actions/download-artifact@v4
        with:
          name: audio-data
          path: ${{ needs.setup.outputs.project_dir }}/media/audio/

      - name: Generate Lipsync Video
        id: lipsync
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          mkdir -p "${{ needs.setup.outputs.project_dir }}/media/videos"
          
          # Find anchor image and audio file
          ANCHOR_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*anchor*.png" -type f 2>/dev/null | head -1)
          AUDIO_FILE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*.mp3" -o -name "*.wav" 2>/dev/null | head -1)
          
          if [ -z "$ANCHOR_IMAGE" ] || [ -z "$AUDIO_FILE" ]; then
            echo "❌ Missing anchor image or audio file"
            echo "lipsync_ready=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          LIPSYNC_PATH="${{ needs.setup.outputs.project_dir }}/media/videos/anchor_lipsync.mp4"
          
          LIPSYNC_PROMPT="Create lipsync video:
          Image: ${ANCHOR_IMAGE}
          Audio: ${AUDIO_FILE}
          Output: ${LIPSYNC_PATH}
          Requirements:
          1. Generate lipsync video using MCP lipsync tool
          2. High quality lip synchronization
          3. Professional news anchor appearance
          4. Save to ${LIPSYNC_PATH} using Write tool
          5. Verify with ls -la"
          
          npx @anthropic-ai/claude-code \
            --mcp-config ".claude/mcp-kamuicode.json" \
            --allowedTools "mcp__v2v-*lipsync*,Write,Bash" \
            --max-turns 80 \
            --permission-mode "bypassPermissions" \
            -p "$LIPSYNC_PROMPT" || {
              echo "⚠️ Lipsync failed, creating fallback video"
              # Create fallback: static anchor image with audio
              ffmpeg -loop 1 -i "$ANCHOR_IMAGE" -i "$AUDIO_FILE" -c:v libx264 -c:a aac -shortest -pix_fmt yuv420p "$LIPSYNC_PATH" -y
            }
          
          # Verify lipsync video
          LIPSYNC_VIDEO=$(find "${{ needs.setup.outputs.project_dir }}" -name "*lipsync*.mp4" -type f 2>/dev/null | head -1)
          [ -z "$LIPSYNC_VIDEO" ] && LIPSYNC_VIDEO=$(find "${{ needs.setup.outputs.project_dir }}" -name "*anchor*.mp4" -mmin -5 2>/dev/null | head -1)
          
          if [ -n "$LIPSYNC_VIDEO" ] && [ -f "$LIPSYNC_VIDEO" ]; then
            FILE_SIZE=$(stat -c%s "$LIPSYNC_VIDEO" 2>/dev/null || echo 0)
            if [ "$FILE_SIZE" -gt 500000 ]; then
              echo "lipsync_ready=true" >> $GITHUB_OUTPUT
              echo "✅ Lipsync video generated: $LIPSYNC_VIDEO"
            else
              echo "lipsync_ready=false" >> $GITHUB_OUTPUT
              echo "⚠️ Lipsync video too small: $FILE_SIZE bytes"
            fi
          else
            echo "lipsync_ready=false" >> $GITHUB_OUTPUT
            echo "❌ Lipsync generation failed"
          fi

      - name: Upload Lipsync Data
        uses: actions/upload-artifact@v4
        with:
          name: lipsync-data
          path: ${{ needs.setup.outputs.project_dir }}/media/videos/

  collect-video-failures:
    needs: [check-trigger, setup, scene-video-generation]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      !cancelled()
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      failed_videos: ${{ steps.collect.outputs.failed_videos }}
      failed_video_items: ${{ steps.collect.outputs.failed_video_items }}
    steps:
      - name: Download All Video Status Files
        uses: actions/download-artifact@v4
        with:
          pattern: video-data-scene-*
          path: ${{ needs.setup.outputs.project_dir }}/all-videos/

      - name: Install FFmpeg and Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq

      - name: Collect Failed Videos
        id: collect
        run: |
          FAILED_VIDEOS=""
          FAILED_VIDEO_ITEMS="[]"
          
          echo "🔍 Analyzing video generation results for ${{ needs.setup.outputs.scene_count }} scenes"
          
          # Check each scene's status using artifact-based verification (most reliable)
          for i in {1..12}; do
            if [ $i -le ${{ needs.setup.outputs.scene_count }} ]; then
              echo "🔍 Checking scene $i video status..."
              
              # Look for video files in artifact directories
              VIDEO_FOUND=false
              FILE_SIZE=0
              ACTUAL_VIDEO_FILE=""
              
              # Multiple potential locations for video files
              POSSIBLE_PATHS=(
                "${{ needs.setup.outputs.project_dir }}/all-videos/video-data-scene-${i}/media/videos/scene${i}.mp4"
                "${{ needs.setup.outputs.project_dir }}/all-videos/video-data-scene-${i}/scene${i}.mp4"
                "${{ needs.setup.outputs.project_dir }}/all-videos/video-data-scene-${i}/scene${i}_video.mp4"
              )
              
              for path in "${POSSIBLE_PATHS[@]}"; do
                if [ -f "$path" ]; then
                  ACTUAL_VIDEO_FILE="$path"
                  FILE_SIZE=$(stat -c%s "$path" 2>/dev/null || echo 0)
                  VIDEO_FOUND=true
                  echo "📁 Found video: $path (${FILE_SIZE} bytes)"
                  break
                fi
              done
              
              # 🚨 MANDATORY MP4 structure validation (no fallback to size-only)
              VIDEO_REASON=""
              if [ "$VIDEO_FOUND" = "true" ] && [ "$FILE_SIZE" -gt 100000 ]; then
                # CRITICAL: Always validate MP4 structure - no exceptions
                if ffprobe -v error -show_entries format=duration -of csv=p=0 "$ACTUAL_VIDEO_FILE" >/dev/null 2>&1; then
                  DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$ACTUAL_VIDEO_FILE" 2>/dev/null || echo "0")
                  # Use python for floating point comparison (more reliable than bc)
                  if python3 -c "import sys; sys.exit(0 if float('$DURATION') >= 3.0 else 1)" 2>/dev/null; then
                    echo "✅ Scene $i: Video validated (${FILE_SIZE} bytes, ${DURATION}s)"
                    continue  # Skip to next scene - this one is successful
                  else
                    echo "⚠️ Scene $i: Video too short (${DURATION}s)"
                    VIDEO_REASON="duration_too_short"
                  fi
                else
                  echo "⚠️ Scene $i: Video corrupted (no moov atom)"
                  VIDEO_REASON="corrupted_mp4"
                fi
              elif [ "$VIDEO_FOUND" = "true" ]; then
                echo "⚠️ Scene $i: Video file too small (${FILE_SIZE} bytes)"
                VIDEO_REASON="file_too_small"
              else
                echo "❌ Scene $i: No video file found"
                VIDEO_REASON="file_not_found"
              fi
              
              # Add failed scene to list
              if [ -z "$FAILED_VIDEOS" ]; then
                FAILED_VIDEOS="$i"
              else
                FAILED_VIDEOS="$FAILED_VIDEOS,$i"
              fi
              
              # Add to detailed failed items
              FAILED_VIDEO_ITEMS=$(echo "$FAILED_VIDEO_ITEMS" | jq --arg scene "$i" --arg reason "$VIDEO_REASON" \
                '. + [{"scene": ($scene | tonumber), "type": "VIDEO", "item": "scene_video", "reason": $reason}]')
              
              echo "❌ Scene $i video: FAILED ($VIDEO_REASON)"
            fi
          done
          
          if [ -n "$FAILED_VIDEOS" ]; then
            echo "Failed videos: [$FAILED_VIDEOS]"
            echo "failed_videos=[${FAILED_VIDEOS}]" >> $GITHUB_OUTPUT
          else
            echo "No failed videos"
            echo "failed_videos=[]" >> $GITHUB_OUTPUT
          fi
          
          # Store failed video items safely (avoid jq dependency)
          echo "failed_video_items<<EOF" >> $GITHUB_OUTPUT
          echo "$FAILED_VIDEO_ITEMS" >> $GITHUB_OUTPUT  
          echo "EOF" >> $GITHUB_OUTPUT
          echo "📊 Video failure details: $FAILED_VIDEO_ITEMS"


  unified-failure-analysis:
    needs: [check-trigger, setup, collect-background-failures, scene-video-generation, collect-video-failures, background-recovery]
    if: always() && needs.check-trigger.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      all_failed_items: ${{ steps.analyze.outputs.all_failed_items }}
      recovery_summary: ${{ steps.analyze.outputs.recovery_summary }}
      items_complete: ${{ steps.analyze.outputs.items_complete }}
    steps:
      - name: Unified Failure Analysis
        id: analyze
        run: |
          echo "🔍 Performing unified failure analysis across all item types"
          
          # Collect failed backgrounds (ensure proper JSON format)
          BACKGROUND_FAILURES='${{ needs.collect-background-failures.outputs.failed_background_items }}'
          if [ "$BACKGROUND_FAILURES" = "" ] || [ "$BACKGROUND_FAILURES" = "null" ]; then
            BACKGROUND_FAILURES="[]"
          fi
          echo "📊 Background failures: $BACKGROUND_FAILURES"
          
          # Collect failed videos (ensure proper JSON format)
          VIDEO_FAILURES='${{ needs.collect-video-failures.outputs.failed_video_items }}'
          if [ "$VIDEO_FAILURES" = "" ] || [ "$VIDEO_FAILURES" = "null" ]; then
            VIDEO_FAILURES="[]"
          fi
          echo "📊 Video failures: $VIDEO_FAILURES"
          
          # Merge all failure types
          ALL_FAILED_ITEMS=$(echo '[]' | jq \
            --argjson bg_failures "$BACKGROUND_FAILURES" \
            --argjson video_failures "$VIDEO_FAILURES" \
            '. + $bg_failures + $video_failures')
          
          echo "📈 Combined failure analysis:"
          echo "$ALL_FAILED_ITEMS" | jq '.'
          
          # Create recovery summary
          TOTAL_FAILED=$(echo "$ALL_FAILED_ITEMS" | jq 'length')
          IMAGE_FAILED=$(echo "$ALL_FAILED_ITEMS" | jq '[.[] | select(.type == "IMAGE")] | length')
          VIDEO_FAILED=$(echo "$ALL_FAILED_ITEMS" | jq '[.[] | select(.type == "VIDEO")] | length')
          
          RECOVERY_SUMMARY=$(jq -n \
            --arg total "$TOTAL_FAILED" \
            --arg images "$IMAGE_FAILED" \
            --arg videos "$VIDEO_FAILED" \
            '{total_failed_items: ($total | tonumber), failed_by_type: {IMAGE: ($images | tonumber), VIDEO: ($videos | tonumber)}, recovery_attempted: true, analysis_timestamp: (now | todate)}' | jq -c)
          
          echo "📋 Recovery summary: $RECOVERY_SUMMARY"
          
          # Determine if all items are complete (no failures remaining)
          if [ "$TOTAL_FAILED" = "0" ]; then
            ITEMS_COMPLETE="true"
            echo "✅ All items generated successfully - ready for next phase"
          else
            ITEMS_COMPLETE="false"
            echo "⚠️ $TOTAL_FAILED items still have issues after recovery"
          fi
          
          # Set outputs with proper JSON handling
          echo "all_failed_items<<EOF" >> $GITHUB_OUTPUT
          echo "$ALL_FAILED_ITEMS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "recovery_summary<<EOF" >> $GITHUB_OUTPUT
          echo "$RECOVERY_SUMMARY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "items_complete=$ITEMS_COMPLETE" >> $GITHUB_OUTPUT
          
          # GitHub Step Summary
          echo "## 🔄 Recovery System Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item Type | Failed | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|---------|" >> $GITHUB_STEP_SUMMARY
          echo "| Images | $IMAGE_FAILED | Recovery attempted |" >> $GITHUB_STEP_SUMMARY
          echo "| Videos | $VIDEO_FAILED | Recovery attempted |" >> $GITHUB_STEP_SUMMARY
          echo "| **Total** | **$TOTAL_FAILED** | All recoveries complete |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "$ITEMS_COMPLETE" = "true" ]; then
            echo "✅ **Status:** All items ready for final composition" >> $GITHUB_STEP_SUMMARY
          else
            echo "⚠️ **Status:** Some items may need manual review" >> $GITHUB_STEP_SUMMARY
          fi

  editing-plan:
    needs: [check-trigger, setup, scene-video-generation, lipsync-processing, unified-failure-analysis]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      needs.unified-failure-analysis.outputs.items_complete == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 8
    outputs:
      plan_ready: ${{ steps.plan.outputs.plan_ready }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download All Media Assets
        uses: actions/download-artifact@v4
        with:
          pattern: "*-data*"
          path: ${{ needs.setup.outputs.project_dir }}/media/
          merge-multiple: true

      - name: Create Editing Plan
        id: plan
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          mkdir -p "${{ needs.setup.outputs.project_dir }}/metadata"
          
          PLAN_PROMPT="Analyze all generated media and create editing plan:
          Directory: ${{ needs.setup.outputs.project_dir }}/media/
          Duration: ${{ needs.setup.outputs.duration }} seconds
          Scenes: ${{ needs.setup.outputs.scene_count }}
          Requirements:
          1. List all available video, image, and audio files
          2. Create optimal editing sequence
          3. Plan picture-in-picture layout for anchor overlay
          4. Specify timing and transitions
          5. Save plan to ${{ needs.setup.outputs.project_dir }}/metadata/editing_plan.json
          6. Include FFmpeg command suggestions"
          
          npx @anthropic-ai/claude-code \
            --allowedTools "Bash,Read,Write" \
            --max-turns 40 \
            --permission-mode "bypassPermissions" \
            -p "$PLAN_PROMPT" || {
              echo "⚠️ Creating fallback editing plan"
              {
                echo '{'
                echo '  "duration": '${{ needs.setup.outputs.duration }}','
                echo '  "scenes": '${{ needs.setup.outputs.scene_count }}','
                echo '  "layout": "picture_in_picture",'
                echo '  "anchor_position": "bottom_right",'
                echo '  "anchor_size": "25%",'
                echo '  "transition": "fade",'
                echo '  "audio_mix": {"narration": -3, "bgm": -18}'
                echo '}'
              } > "${{ needs.setup.outputs.project_dir }}/metadata/editing_plan.json"
            }
          
          if [ -f "${{ needs.setup.outputs.project_dir }}/metadata/editing_plan.json" ]; then
            echo "plan_ready=true" >> $GITHUB_OUTPUT
            echo "✅ Editing plan created"
          else
            echo "plan_ready=false" >> $GITHUB_OUTPUT
            echo "❌ Editing plan creation failed"
          fi

      - name: Upload Plan Data
        uses: actions/upload-artifact@v4
        with:
          name: plan-data
          path: ${{ needs.setup.outputs.project_dir }}/metadata/

  dynamic-recovery-check:
    needs: [check-trigger, setup, scene-video-generation, lipsync-processing, collect-video-failures, unified-failure-analysis]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      needs.unified-failure-analysis.outputs.items_complete == 'false'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      recovery_needed: ${{ steps.validate.outputs.recovery_needed }}
      corrupted_scenes: ${{ steps.validate.outputs.corrupted_scenes }}
      corrupted_lipsync: ${{ steps.validate.outputs.corrupted_lipsync }}
      valid_scene_count: ${{ steps.validate.outputs.valid_scene_count }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download All Assets
        uses: actions/download-artifact@v4
        with:
          pattern: "*-data*"
          path: ${{ needs.setup.outputs.project_dir }}/
          merge-multiple: true

      - name: Install FFmpeg and Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq

      - name: Validate All Generated Content
        id: validate
        run: |
          echo "🔍 動的コンテンツ検証を開始..."
          
          CORRUPTED_SCENES=""
          CORRUPTED_LIPSYNC=""
          VALID_SCENE_COUNT=0
          RECOVERY_NEEDED=false
          
          # シーン動画の検証
          echo "📹 シーン動画の検証中..."
          for scene_num in {1..12}; do
            video_file=$(find "${{ needs.setup.outputs.project_dir }}" -name "*scene${scene_num}*.mp4" -type f | head -1)
            
            if [ -f "$video_file" ]; then
              FILE_SIZE=$(stat -c%s "$video_file" 2>/dev/null || echo 0)
              
              # MP4構造検証（scene-video-generationと同じロジック）
              VALID_VIDEO=false
              if [ "$FILE_SIZE" -gt 100000 ]; then
                if ffprobe -v error -show_entries format=duration -of csv=p=0 "$video_file" >/dev/null 2>&1; then
                  DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$video_file" 2>/dev/null || echo "0")
                  if python3 -c "import sys; sys.exit(0 if float('$DURATION') >= 3.0 else 1)" 2>/dev/null; then
                    echo "✅ Scene $scene_num: Valid (${FILE_SIZE} bytes, ${DURATION}s)"
                    VALID_SCENE_COUNT=$((VALID_SCENE_COUNT + 1))
                    VALID_VIDEO=true
                  else
                    echo "⚠️ Scene $scene_num: Too short (${DURATION}s)"
                  fi
                else
                  echo "⚠️ Scene $scene_num: Corrupted (missing moov atom)"
                fi
              else
                echo "⚠️ Scene $scene_num: Too small (${FILE_SIZE} bytes)"
              fi
              
              if [ "$VALID_VIDEO" = "false" ]; then
                CORRUPTED_SCENES="$CORRUPTED_SCENES $scene_num"
                RECOVERY_NEEDED=true
              fi
            else
              echo "❌ Scene $scene_num: File not found"
              CORRUPTED_SCENES="$CORRUPTED_SCENES $scene_num"
              RECOVERY_NEEDED=true
            fi
          done
          
          # リップシンク動画の検証
          echo "🎤 リップシンク動画の検証中..."
          lipsync_file=$(find "${{ needs.setup.outputs.project_dir }}" -name "*lipsync*.mp4" -type f | head -1)
          
          if [ -f "$lipsync_file" ]; then
            FILE_SIZE=$(stat -c%s "$lipsync_file" 2>/dev/null || echo 0)
            
            VALID_LIPSYNC=false
            if [ "$FILE_SIZE" -gt 100000 ]; then
              if ffprobe -v error -show_entries format=duration -of csv=p=0 "$lipsync_file" >/dev/null 2>&1; then
                DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$lipsync_file" 2>/dev/null || echo "0")
                if python3 -c "import sys; sys.exit(0 if float('$DURATION') >= 3.0 else 1)" 2>/dev/null; then
                  echo "✅ Lipsync: Valid (${FILE_SIZE} bytes, ${DURATION}s)"
                  VALID_LIPSYNC=true
                else
                  echo "⚠️ Lipsync: Too short (${DURATION}s)"
                fi
              else
                echo "⚠️ Lipsync: Corrupted (missing moov atom)"
              fi
            else
              echo "⚠️ Lipsync: Too small (${FILE_SIZE} bytes)"
            fi
            
            if [ "$VALID_LIPSYNC" = "false" ]; then
              CORRUPTED_LIPSYNC="anchor_lipsync"
              RECOVERY_NEEDED=true
            fi
          else
            echo "❌ Lipsync: File not found"
            CORRUPTED_LIPSYNC="anchor_lipsync"
            RECOVERY_NEEDED=true
          fi
          
          # 結果の出力
          echo "📊 検証結果サマリー:"
          echo "- 有効なシーン動画: $VALID_SCENE_COUNT/12"
          echo "- 破損シーン: $CORRUPTED_SCENES"
          echo "- 破損リップシンク: $CORRUPTED_LIPSYNC"
          echo "- リカバリー必要: $RECOVERY_NEEDED"
          
          # GitHub Outputsに設定
          echo "recovery_needed=$RECOVERY_NEEDED" >> $GITHUB_OUTPUT
          echo "corrupted_scenes=${CORRUPTED_SCENES# }" >> $GITHUB_OUTPUT  # 先頭スペース除去
          echo "corrupted_lipsync=$CORRUPTED_LIPSYNC" >> $GITHUB_OUTPUT
          echo "valid_scene_count=$VALID_SCENE_COUNT" >> $GITHUB_OUTPUT

  immediate-recovery:
    needs: [check-trigger, setup, dynamic-recovery-check]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      needs.dynamic-recovery-check.outputs.recovery_needed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 35
    outputs:
      recovery_completed: ${{ steps.recover.outputs.recovery_completed }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download All Assets
        uses: actions/download-artifact@v4
        with:
          pattern: "*-data*"
          path: ${{ needs.setup.outputs.project_dir }}/
          merge-multiple: true

      - name: Install FFmpeg and ImageMagick
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg imagemagick

      - name: Execute Dynamic Recovery
        id: recover
        env:
          CLAUDE_CODE_CI_MODE: true
          CLAUDE_CODE_AUTO_APPROVE_MCP: true
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          echo "🔧 動的リカバリーを開始..."
          
          CORRUPTED_SCENES="${{ needs.dynamic-recovery-check.outputs.corrupted_scenes }}"
          CORRUPTED_LIPSYNC="${{ needs.dynamic-recovery-check.outputs.corrupted_lipsync }}"
          RECOVERY_SUCCESS=true
          
          # シーン動画のリカバリー
          if [ -n "$CORRUPTED_SCENES" ]; then
            echo "📹 破損シーン動画のリカバリー: $CORRUPTED_SCENES"
            
            for scene_num in $CORRUPTED_SCENES; do
              echo "🔧 Scene $scene_num をリカバリー中..."
              
              # 背景画像を取得
              BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*scene${scene_num}*.png" -type f | head -1)
              if [ -z "$BG_IMAGE" ] || [ ! -f "$BG_IMAGE" ]; then
                BG_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*background*.png" | head -1)
              fi
              
              if [ -f "$BG_IMAGE" ]; then
                VIDEO_PATH="${{ needs.setup.outputs.project_dir }}/media/videos/scene${scene_num}.mp4"
                URL_PATH="${{ needs.setup.outputs.project_dir }}/media/videos/scene${scene_num}-url.txt"
                
                I2V_PROMPT="Scene ${scene_num} 緊急リカバリー:
                背景画像: ${BG_IMAGE}
                出力動画: ${VIDEO_PATH}
                要件:
                1. MCP I2V ツールで5秒動画を生成 (高速サービス優先: veo3-fast または seedance-v1-lite)
                2. ${VIDEO_PATH}に保存
                3. URLを${URL_PATH}に保存
                4. 検証: ファイルサイズ>100KB、再生時間>=3秒、moov atom存在
                5. 10分以内で完了しない場合はフォールバックへ"
                
                # MCP処理に時間制限を設定
                timeout 600 npx @anthropic-ai/claude-code \
                  --mcp-config ".claude/mcp-kamuicode.json" \
                  --allowedTools "mcp__i2v-kamui-veo3-fast,mcp__i2v-kamui-seedance-v1-lite,Write,Bash" \
                  --max-turns 60 \
                  --permission-mode "bypassPermissions" \
                  -p "$I2V_PROMPT" || {
                    echo "⚠️ MCP リカバリー失敗/タイムアウト、FFmpeg フォールバック"
                    ffmpeg -loop 1 -i "$BG_IMAGE" -c:v libx264 -t 5 -pix_fmt yuv420p -r 30 "$VIDEO_PATH" -y
                  }
                
                # URLからダウンロード試行
                [ -f "$URL_PATH" ] && curl -L -o "$VIDEO_PATH" "$(cat $URL_PATH)" 2>/dev/null
                
                # リカバリー結果の検証
                if [ -f "$VIDEO_PATH" ]; then
                  FILE_SIZE=$(stat -c%s "$VIDEO_PATH" 2>/dev/null || echo 0)
                  if [ "$FILE_SIZE" -gt 100000 ]; then
                    if ffprobe -v error -show_entries format=duration -of csv=p=0 "$VIDEO_PATH" >/dev/null 2>&1; then
                      echo "✅ Scene $scene_num リカバリー成功"
                    else
                      echo "❌ Scene $scene_num リカバリー失敗（破損）"
                      RECOVERY_SUCCESS=false
                    fi
                  else
                    echo "❌ Scene $scene_num リカバリー失敗（サイズ不足）"
                    RECOVERY_SUCCESS=false
                  fi
                else
                  echo "❌ Scene $scene_num リカバリー失敗（ファイル未生成）"
                  RECOVERY_SUCCESS=false
                fi
              else
                echo "❌ Scene $scene_num: 背景画像が見つかりません"
                RECOVERY_SUCCESS=false
              fi
            done
          fi
          
          # リップシンク動画のリカバリー
          if [ -n "$CORRUPTED_LIPSYNC" ]; then
            echo "🎤 リップシンク動画のリカバリー"
            
            ANCHOR_IMAGE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*anchor*.png" -o -name "*news_anchor*.png" | head -1)
            AUDIO_FILE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*.mp3" -o -name "*.wav" | head -1)
            
            if [ -f "$ANCHOR_IMAGE" ] && [ -f "$AUDIO_FILE" ]; then
              LIPSYNC_PATH="${{ needs.setup.outputs.project_dir }}/anchor_lipsync.mp4"
              
              LIPSYNC_PROMPT="リップシンク緊急リカバリー:
              アンカー画像: ${ANCHOR_IMAGE}
              音声ファイル: ${AUDIO_FILE}
              出力動画: ${LIPSYNC_PATH}
              要件:
              1. MCP リップシンクツールで音声同期動画生成 (高速サービス: pixverse-lipsync 優先)
              2. ${LIPSYNC_PATH}に保存
              3. 検証: 音声と口の動きが同期
              4. 8分以内で完了しない場合はフォールバックへ"
              
              # リップシンク処理に時間制限を設定
              timeout 480 npx @anthropic-ai/claude-code \
                --mcp-config ".claude/mcp-kamuicode.json" \
                --allowedTools "mcp__v2v-kamui-pixverse-lipsync,mcp__v2v-kamui-creatify-lipsync,Write,Bash" \
                --max-turns 40 \
                --permission-mode "bypassPermissions" \
                -p "$LIPSYNC_PROMPT" || {
                  echo "⚠️ リップシンク失敗/タイムアウト、静止画フォールバック"
                  ffmpeg -loop 1 -i "$ANCHOR_IMAGE" -i "$AUDIO_FILE" -c:v libx264 -c:a aac -shortest "$LIPSYNC_PATH" -y
                }
              
              # リカバリー結果の検証
              if [ -f "$LIPSYNC_PATH" ]; then
                FILE_SIZE=$(stat -c%s "$LIPSYNC_PATH" 2>/dev/null || echo 0)
                if [ "$FILE_SIZE" -gt 100000 ]; then
                  if ffprobe -v error -show_entries format=duration -of csv=p=0 "$LIPSYNC_PATH" >/dev/null 2>&1; then
                    echo "✅ リップシンク リカバリー成功"
                  else
                    echo "❌ リップシンク リカバリー失敗（破損）"
                    RECOVERY_SUCCESS=false
                  fi
                else
                  echo "❌ リップシンク リカバリー失敗（サイズ不足）"
                  RECOVERY_SUCCESS=false
                fi
              else
                echo "❌ リップシンク リカバリー失敗（ファイル未生成）"
                RECOVERY_SUCCESS=false
              fi
            else
              echo "❌ リップシンク: 必要なファイルが見つかりません"
              RECOVERY_SUCCESS=false
            fi
          fi
          
          # 🚨 CRITICAL: Final Recovery System validation and termination
          if [ "$RECOVERY_SUCCESS" = "true" ]; then
            echo "recovery_completed=true" >> $GITHUB_OUTPUT
            echo "🎉 ALL RECOVERY ATTEMPTS SUCCESSFUL - Workflow can continue"
            echo ""
            echo "Recovery Summary:"
            echo "✅ Scene recoveries: Success"
            echo "✅ Lipsync recovery: Success"
            echo "✅ All validation checks: Passed"
          else
            echo "recovery_completed=false" >> $GITHUB_OUTPUT
            echo ""
            echo "🚨 CRITICAL FAILURE: RECOVERY SYSTEM FAILED"
            echo "❌ Recovery attempts could not resolve all issues"
            echo ""
            echo "Failed recovery items:"
            if [ -n "$CORRUPTED_SCENES" ]; then
              echo "❌ Scene videos: $CORRUPTED_SCENES"
            fi
            if [ "$CORRUPTED_LIPSYNC" = "true" ]; then
              echo "❌ Lipsync video: Failed to recover"
            fi
            echo ""
            echo "🛑 TERMINATING WORKFLOW - Recovery failure is not acceptable"
            echo "📋 Recovery Policy: All content must be successfully generated or recovered"
            echo "🚨 Manual intervention required before workflow can proceed"
            echo ""
            echo "This workflow termination prevents:"
            echo "- Proceeding with incomplete video content"
            echo "- Creating defective final compositions"
            echo "- Delivering substandard results"
            echo ""
            exit 1  # Force immediate workflow termination
          fi

      - name: Upload Recovered Assets
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: recovered-assets
          path: |
            ${{ needs.setup.outputs.project_dir }}/media/videos/
            ${{ needs.setup.outputs.project_dir }}/anchor_lipsync.mp4

  final-composition:
    needs: [check-trigger, setup, scene-video-generation, lipsync-processing, editing-plan, dynamic-recovery-check, immediate-recovery, unified-failure-analysis]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      !cancelled() &&
      (
        (needs.unified-failure-analysis.outputs.items_complete == 'true' && needs.editing-plan.result == 'success') ||
        (needs.unified-failure-analysis.outputs.items_complete == 'false' && needs.immediate-recovery.outputs.recovery_completed == 'true' && needs.immediate-recovery.result == 'success')
      )
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      final_video: ${{ steps.compose.outputs.final_video }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download All Assets
        uses: actions/download-artifact@v4
        with:
          pattern: "*-data*"
          path: ${{ needs.setup.outputs.project_dir }}/
          merge-multiple: true

      - name: Download Recovered Assets (if available)
        uses: actions/download-artifact@v4
        if: needs.dynamic-recovery-check.outputs.recovery_needed == 'true'
        continue-on-error: true
        with:
          name: recovered-assets
          path: ${{ needs.setup.outputs.project_dir }}/

      - name: Install FFmpeg and Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq

      - name: Compose Final Video
        id: compose
        run: |
          mkdir -p "${{ needs.setup.outputs.project_dir }}/final"
          
          # List available assets
          echo "=== Available Assets ==="
          find "${{ needs.setup.outputs.project_dir }}" -type f -name "*.mp4" -o -name "*.png" -o -name "*.mp3" -o -name "*.wav" | sort
          
          # Find and validate background videos (post-recovery validation)
          echo "🔍 Post-recovery video validation..."
          VALID_VIDEOS=""
          TOTAL_DURATION=0
          
          for video in $(find "${{ needs.setup.outputs.project_dir }}" -name "*scene*.mp4" -type f | sort); do
            if [ -f "$video" ]; then
              # Quick validation (files should be valid after recovery)
              FILE_SIZE=$(stat -c%s "$video" 2>/dev/null || echo 0)
              if [ "$FILE_SIZE" -gt 100000 ]; then
                if ffprobe -v error -show_entries format=duration -of csv=p=0 "$video" >/dev/null 2>&1; then
                  DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$video" 2>/dev/null || echo "0")
                  if python3 -c "import sys; sys.exit(0 if float('$DURATION') >= 3.0 else 1)" 2>/dev/null; then
                    echo "✅ Valid video: $video (${FILE_SIZE} bytes, ${DURATION}s)"
                    VALID_VIDEOS="$VALID_VIDEOS $video"
                    TOTAL_DURATION=$(python3 -c "print(float('$TOTAL_DURATION') + float('$DURATION'))" 2>/dev/null || echo "$TOTAL_DURATION")
                  else
                    echo "⚠️ Unexpected short video after recovery: $video (${DURATION}s)"
                    # Note: This should not happen after successful recovery
                  fi
                else
                  echo "⚠️ Unexpected corrupted video after recovery: $video"
                  # Note: This should not happen after successful recovery
                fi
              else
                echo "⚠️ Unexpected small video after recovery: $video (${FILE_SIZE} bytes)"
              fi
            fi
          done
          
          echo "📊 Post-recovery summary:"
          echo "- Valid videos found: $(echo $VALID_VIDEOS | wc -w)"
          echo "- Total duration: ${TOTAL_DURATION}s"
          
          BACKGROUND_VIDEOS="$VALID_VIDEOS"
          
          # Validate lipsync video
          LIPSYNC_CANDIDATES=$(find "${{ needs.setup.outputs.project_dir }}" -name "*lipsync*.mp4" -type f)
          LIPSYNC_VIDEO=""
          for video in $LIPSYNC_CANDIDATES; do
            if [ -f "$video" ]; then
              FILE_SIZE=$(stat -c%s "$video" 2>/dev/null || echo 0)
              if [ "$FILE_SIZE" -gt 100000 ]; then
                if ffprobe -v error -show_entries format=duration -of csv=p=0 "$video" >/dev/null 2>&1; then
                  echo "✅ Valid lipsync video: $video"
                  LIPSYNC_VIDEO="$video"
                  break
                else
                  echo "⚠️ Skipping corrupted lipsync video: $video (missing moov atom)"
                fi
              else
                echo "⚠️ Skipping small lipsync video: $video (${FILE_SIZE} bytes)"
              fi
            fi
          done
          
          AUDIO_FILE=$(find "${{ needs.setup.outputs.project_dir }}" -name "*.mp3" -o -name "*.wav" | head -1)
          
          FINAL_OUTPUT="${{ needs.setup.outputs.project_dir }}/final/news_video_final.mp4"
          
          if [ -n "$BACKGROUND_VIDEOS" ] && [ -n "$LIPSYNC_VIDEO" ] && [ -f "$LIPSYNC_VIDEO" ]; then
            echo "✅ Found assets for composition"
            
            # Create video list for concatenation
            VIDEO_LIST="${{ needs.setup.outputs.project_dir }}/final/video_list.txt"
            echo -n > "$VIDEO_LIST"
            
            # Add background videos to list
            for video in $BACKGROUND_VIDEOS; do
              if [ -f "$video" ]; then
                echo "file '$video'" >> "$VIDEO_LIST"
              fi
            done
            
            # Concatenate background videos
            CONCAT_BG="${{ needs.setup.outputs.project_dir }}/final/background_concat.mp4"
            if [ -s "$VIDEO_LIST" ]; then
              ffmpeg -f concat -safe 0 -i "$VIDEO_LIST" -c copy "$CONCAT_BG" -y
            else
              echo "⚠️ No valid background videos, using fallback"
              ffmpeg -f lavfi -i color=blue:size=1920x1080:duration=${{ needs.setup.outputs.duration }} -r 30 "$CONCAT_BG" -y
            fi
            
            # Overlay anchor video (picture-in-picture)
            if [ -f "$CONCAT_BG" ] && [ -f "$LIPSYNC_VIDEO" ]; then
              ffmpeg -i "$CONCAT_BG" -i "$LIPSYNC_VIDEO" \
                -filter_complex "[1:v]scale=480:270[anchor];[0:v][anchor]overlay=W-w-20:H-h-20[v]" \
                -map "[v]" -map "1:a" -c:v libx264 -c:a aac -t ${{ needs.setup.outputs.duration }} \
                "$FINAL_OUTPUT" -y
            else
              echo "⚠️ Missing video files, creating simple output"
              cp "$LIPSYNC_VIDEO" "$FINAL_OUTPUT" 2>/dev/null || {
                ffmpeg -f lavfi -i testsrc=duration=${{ needs.setup.outputs.duration }}:size=1920x1080:rate=30 \
                  -f lavfi -i sine=frequency=1000:duration=${{ needs.setup.outputs.duration }} \
                  -c:v libx264 -c:a aac "$FINAL_OUTPUT" -y
              }
            fi
          else
            echo "⚠️ Missing essential assets, creating fallback video"
            # Create fallback news video (fixed FFmpeg syntax)
            ffmpeg -f lavfi -i color=darkblue:size=1920x1080:duration=${{ needs.setup.outputs.duration }} \
              -f lavfi -i sine=frequency=440:duration=${{ needs.setup.outputs.duration }} \
              -filter_complex "[0:v]drawtext=text='News Video\: ${{ needs.setup.outputs.news_topic }}':fontsize=48:fontcolor=white:x=(w-text_w)/2:y=(h-text_h)/2[v]" \
              -map "[v]" -map "1:a" -c:v libx264 -c:a aac "$FINAL_OUTPUT" -y
          fi
          
          # Verify final video
          if [ -f "$FINAL_OUTPUT" ]; then
            FILE_SIZE=$(stat -c%s "$FINAL_OUTPUT" 2>/dev/null || echo 0)
            DURATION=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$FINAL_OUTPUT" 2>/dev/null || echo "0")
            
            echo "✅ Final video created:"
            echo "- Path: $FINAL_OUTPUT"
            echo "- Size: $FILE_SIZE bytes"
            echo "- Duration: ${DURATION}s"
            
            echo "final_video=$FINAL_OUTPUT" >> $GITHUB_OUTPUT
          else
            echo "❌ Final video creation failed"
            echo "final_video=" >> $GITHUB_OUTPUT
          fi

      - name: Upload Final Video
        uses: actions/upload-artifact@v4
        with:
          name: final-video
          path: ${{ needs.setup.outputs.project_dir }}/final/

  quality-verification:
    needs: [check-trigger, setup, final-composition]
    if: |
      always() &&
      needs.check-trigger.outputs.should_run == 'true' &&
      needs.final-composition.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 8
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Final Video
        uses: actions/download-artifact@v4
        with:
          name: final-video
          path: ${{ needs.setup.outputs.project_dir }}/final/

      - name: Verify Video Quality
        run: |
          FINAL_VIDEO="${{ needs.final-composition.outputs.final_video }}"
          
          if [ -n "$FINAL_VIDEO" ] && [ -f "$FINAL_VIDEO" ]; then
            echo "=== Quality Verification ==="
            
            # Check file size
            FILE_SIZE=$(stat -c%s "$FINAL_VIDEO" 2>/dev/null || echo 0)
            echo "File size: $FILE_SIZE bytes"
            
            # Check video properties
            ffprobe -v error -select_streams v:0 -show_entries stream=width,height,r_frame_rate,duration -of csv=p=0 "$FINAL_VIDEO" 2>/dev/null || echo "Video probe failed"
            
            # Check audio properties
            ffprobe -v error -select_streams a:0 -show_entries stream=codec_name,sample_rate,channels -of csv=p=0 "$FINAL_VIDEO" 2>/dev/null || echo "Audio probe failed"
            
            if [ "$FILE_SIZE" -gt 1000000 ]; then
              echo "✅ Video quality verification passed"
            else
              echo "⚠️ Video file seems small, but process completed"
            fi
          else
            echo "❌ No final video found for verification"
          fi
          
          # Create execution summary
          SUMMARY_FILE="${{ needs.setup.outputs.project_dir }}/final/execution_summary.txt"
          {
            echo "=== News Video Creation Summary ==="
            echo "Topic: ${{ needs.setup.outputs.news_topic }}"
            echo "Category: ${{ needs.setup.outputs.news_category }}"
            echo "Duration: ${{ needs.setup.outputs.duration }}s"
            echo "Scenes: ${{ needs.setup.outputs.scene_count }}"
            echo "Completion: $(date)"
            echo ""
            echo "Generated Assets:"
            find "${{ needs.setup.outputs.project_dir }}" -type f -name "*.mp4" -o -name "*.png" -o -name "*.mp3" -o -name "*.wav" -o -name "*.json" | sort
          } > "$SUMMARY_FILE"
          
          echo "✅ Quality verification completed"

      - name: Final Status Summary
        if: always()
        run: |
          echo "## 🎬 News Video Creation Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Topic:** ${{ needs.setup.outputs.news_topic }}" >> $GITHUB_STEP_SUMMARY
          echo "**Category:** ${{ needs.setup.outputs.news_category }}" >> $GITHUB_STEP_SUMMARY
          echo "**Duration:** ${{ needs.setup.outputs.duration }}s" >> $GITHUB_STEP_SUMMARY
          echo "**Scenes:** ${{ needs.setup.outputs.scene_count }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Job Status:" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Setup: Complete" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.news-collection.result == 'success' && '✅' || '❌' }} News Collection" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.script-creation.result == 'success' && '✅' || '❌' }} Script Creation" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.narration-generation.result == 'success' && '✅' || '❌' }} Narration Generation" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.anchor-generation.result == 'success' && '✅' || '❌' }} Anchor Generation" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.background-generation.result == 'success' && '✅' || '⚠️' }} Background Generation" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.scene-video-generation.result == 'success' && '✅' || '⚠️' }} Scene Video Generation" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.lipsync-processing.result == 'success' && '✅' || '❌' }} Lipsync Processing" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.final-composition.result == 'success' && '✅' || '❌' }} Final Composition" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Final Video:** ${{ needs.final-composition.outputs.final_video || 'Not available' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "📁 **Artifacts:** All generated files are available in workflow artifacts" >> $GITHUB_STEP_SUMMARY
