name: "Meta Workflow Executor v10 with Claude SDK"
run-name: "üöÄ Meta Workflow v10 | Issue #${{ inputs.issue_number }} | ${{ github.actor }}"

on:
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number for workflow generation request'
        required: true
        default: '60'

permissions:
  contents: write
  issues: write
  actions: write
  pull-requests: write

env:
  CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
  CLAUDE_CODE_CI_MODE: true
  CLAUDE_CODE_AUTO_APPROVE_MCP: true

jobs:
  # ===========================================
  # PHASE 1: ISSUE ANALYSIS & VALIDATION
  # ===========================================
  
  validate-trigger:
    name: "üîç Issue Analysis & Validation"
    runs-on: ubuntu-latest
    outputs:
      issue_number: ${{ steps.extract.outputs.issue_number }}
      issue_body: ${{ steps.extract.outputs.issue_body }}
      issue_title: ${{ steps.extract.outputs.issue_title }}
      request_type: ${{ steps.analyze.outputs.request_type }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        
      - name: Extract Issue Information
        id: extract
        run: |
          echo "üîç Analyzing Issue #${{ inputs.issue_number }}..."
          
          # Get issue details using GitHub CLI
          ISSUE_DATA=$(gh issue view ${{ inputs.issue_number }} --json title,body,number --jq '{title: .title, body: .body, number: .number}')
          
          ISSUE_TITLE=$(echo "$ISSUE_DATA" | jq -r '.title')
          ISSUE_BODY=$(echo "$ISSUE_DATA" | jq -r '.body')
          ISSUE_NUMBER=$(echo "$ISSUE_DATA" | jq -r '.number')
          
          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          
          {
            echo 'issue_title<<EOF'
            echo "$ISSUE_TITLE"
            echo 'EOF'
          } >> $GITHUB_OUTPUT
          
          {
            echo 'issue_body<<EOF'
            echo "$ISSUE_BODY"
            echo 'EOF'
          } >> $GITHUB_OUTPUT
          
          echo "‚úÖ Issue #$ISSUE_NUMBER validated: $ISSUE_TITLE"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Analyze Request Type
        id: analyze
        run: |
          echo "üìä Analyzing request type from issue content..."
          
          # Save issue body to a file to avoid shell interpretation issues
          cat << 'ISSUE_CONTENT_EOF' > /tmp/issue_body.txt
          ${{ steps.extract.outputs.issue_body }}
          ISSUE_CONTENT_EOF
          
          REQUEST_TYPE="unknown"
          
          # Determine request type based on content
          if grep -i "video" /tmp/issue_body.txt > /dev/null; then
            REQUEST_TYPE="video-generation"
          elif grep -i "image" /tmp/issue_body.txt > /dev/null; then
            REQUEST_TYPE="image-generation"
          elif grep -i "audio\|music" /tmp/issue_body.txt > /dev/null; then
            REQUEST_TYPE="audio-generation"
          elif grep -i "data\|analysis" /tmp/issue_body.txt > /dev/null; then
            REQUEST_TYPE="data-analysis"
          elif grep -i "blog\|article" /tmp/issue_body.txt > /dev/null; then
            REQUEST_TYPE="content-creation"
          fi
          
          echo "request_type=$REQUEST_TYPE" >> $GITHUB_OUTPUT
          echo "üéØ Request type identified: $REQUEST_TYPE"

  # ===========================================
  # PHASE 2: ULTRA-DETAILED TASK DECOMPOSITION
  # ===========================================
  
  ultra-task-decomposition:
    name: "üß† Ultra-Detailed Task Decomposition"
    runs-on: ubuntu-latest
    needs: validate-trigger
    outputs:
      decomposed_tasks: ${{ steps.decompose.outputs.decomposed_tasks }}
      task_count: ${{ steps.decompose.outputs.task_count }}
      execution_phases: ${{ steps.decompose.outputs.execution_phases }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        
      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
        
      - name: Perform Ultra-Detailed Task Decomposition
        id: decompose
        run: |
          echo "üß† Starting ultra-detailed task decomposition..."
          
          # Create project directory
          mkdir -p projects/current-session/{logs,metadata,scripts}
          
          # Create task decomposition using Claude Code
          cat > projects/current-session/scripts/decompose_tasks.sh << 'EOF'
          #!/bin/bash
          echo "Performing task decomposition for Issue #${{ needs.validate-trigger.outputs.issue_number }}"
          echo "Issue Title: ${{ needs.validate-trigger.outputs.issue_title }}"
          echo "Request Type: ${{ needs.validate-trigger.outputs.request_type }}"
          
          # Issue details
          ISSUE_TITLE="${{ needs.validate-trigger.outputs.issue_title }}"
          REQUEST_TYPE="${{ needs.validate-trigger.outputs.request_type }}"
          
          echo "Request: $ISSUE_TITLE"
          echo "Type: $REQUEST_TYPE"
          
          # Save issue body to file to avoid shell interpretation issues
          cat << 'ISSUE_BODY_EOF' > /tmp/issue_body_safe.txt
          ${{ needs.validate-trigger.outputs.issue_body }}
          ISSUE_BODY_EOF
          
          # Dynamic task decomposition using Claude Code SDK
          echo "üß† Using Claude Code SDK for intelligent task decomposition..."
          
          # Create prompt for Claude Code SDK
          ISSUE_TITLE="${{ needs.validate-trigger.outputs.issue_title }}"
          
          # Create base prompt
          echo "Creating Claude prompt..."
          echo "„ÅÇ„Å™„Åü„ÅØMeta Workflow Generator„ÅÆ„Çø„Çπ„ÇØÂàÜËß£„Ç®„Éº„Ç∏„Çß„É≥„Éà„Åß„Åô„ÄÇ" > /tmp/claude_prompt.txt
          echo "‰ª•‰∏ã„ÅÆ„Ç§„Ç∑„É•„Éº„Åã„ÇâÂøÖË¶Å„Å™„Çø„Çπ„ÇØ„ÇíÂàÜËß£„Åó„ÄÅÈÅ©Âàá„Å™„Éü„Éã„Éû„É´„É¶„Éã„ÉÉ„Éà„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ" >> /tmp/claude_prompt.txt
          echo "" >> /tmp/claude_prompt.txt
          echo "„Ç§„Ç∑„É•„ÉºÊÉÖÂ†±:" >> /tmp/claude_prompt.txt
          echo "„Çø„Ç§„Éà„É´: $ISSUE_TITLE" >> /tmp/claude_prompt.txt
          echo "ÂÜÖÂÆπ:" >> /tmp/claude_prompt.txt
          cat /tmp/issue_body_safe.txt >> /tmp/claude_prompt.txt
          echo "" >> /tmp/claude_prompt.txt
          echo "Âà©Áî®ÂèØËÉΩ„Å™„Éü„Éã„Éû„É´„É¶„Éã„ÉÉ„Éà:" >> /tmp/claude_prompt.txt
          echo "- web-search: WebÊ§úÁ¥¢„Å®„Éà„É¨„É≥„ÉâÊÉÖÂ†±ÂèéÈõÜ" >> /tmp/claude_prompt.txt
          echo "- news-planning: „Éã„É•„Éº„Çπ‰ºÅÁîª„Å®ÊßãÊàê‰ΩúÊàê" >> /tmp/claude_prompt.txt
          echo "- image-generation: ÁîªÂÉèÁîüÊàêÔºà„Çµ„É†„Éç„Ç§„É´„ÄÅ„Éì„Ç∏„É•„Ç¢„É´Á¥†ÊùêÔºâ" >> /tmp/claude_prompt.txt
          echo "- video-generation: ÂãïÁîªÁîüÊàêÔºà„É°„Ç§„É≥„Ç≥„É≥„ÉÜ„É≥„ÉÑÔºâ" >> /tmp/claude_prompt.txt
          echo "- audio-generation: BGMÁîüÊàê" >> /tmp/claude_prompt.txt
          echo "- text-to-speech: „Éä„É¨„Éº„Ç∑„Éß„É≥Èü≥Â£∞ÁîüÊàê" >> /tmp/claude_prompt.txt
          echo "- video-editing: ÂãïÁîªÁ∑®ÈõÜ„Å®Á¥†ÊùêÁµ±Âêà" >> /tmp/claude_prompt.txt
          echo "- data-analysis: „Éá„Éº„ÇøÂàÜÊûê„Å®ÂèØË¶ñÂåñ" >> /tmp/claude_prompt.txt
          echo "" >> /tmp/claude_prompt.txt
          echo "‰ª•‰∏ã„ÅÆÂΩ¢Âºè„ÅßJSON„ÇíÂá∫Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ:" >> /tmp/claude_prompt.txt
          echo '{' >> /tmp/claude_prompt.txt
          echo '  "complexity": "simple|medium|complex",' >> /tmp/claude_prompt.txt
          echo '  "duration": "Êé®ÂÆöÊôÇÈñì",' >> /tmp/claude_prompt.txt
          echo '  "capabilities": ["ÂøÖË¶Å„Å™ËÉΩÂäõ„ÅÆ„É™„Çπ„Éà"],' >> /tmp/claude_prompt.txt
          echo '  "task_sequence": [' >> /tmp/claude_prompt.txt
          echo '    {' >> /tmp/claude_prompt.txt
          echo '      "phase": 1,' >> /tmp/claude_prompt.txt
          echo '      "tasks": ["‰∏¶ÂàóÂÆüË°åÂèØËÉΩ„Å™„Çø„Çπ„ÇØ"],' >> /tmp/claude_prompt.txt
          echo '      "reason": "„Å™„Åú„Åì„ÅÆ„Éï„Çß„Éº„Ç∫„ÅßÂÆüË°å„Åô„Çã„Åã"' >> /tmp/claude_prompt.txt
          echo '    }' >> /tmp/claude_prompt.txt
          echo '  ]' >> /tmp/claude_prompt.txt
          echo '}' >> /tmp/claude_prompt.txt

          # Check Claude Code availability
          echo "Debug - Checking Claude Code CLI..."
          if command -v claude &> /dev/null; then
            echo "‚úÖ Claude CLI is available"
            claude --version || echo "Version check failed"
          else
            echo "‚ùå Claude CLI is not installed"
          fi
          
          echo "Debug - Environment variables:"
          echo "CLAUDE_CODE_OAUTH_TOKEN is $([ -n "$CLAUDE_CODE_OAUTH_TOKEN" ] && echo 'set' || echo 'not set')"
          echo "ANTHROPIC_API_KEY is $([ -n "$ANTHROPIC_API_KEY" ] && echo 'set' || echo 'not set')"
          
          # Execute Claude Code SDK
          CLAUDE_RESPONSE=$(claude -p "$(cat /tmp/claude_prompt.txt)" --output-format json 2>&1 || echo '{}')
          echo "Debug - Claude response: $CLAUDE_RESPONSE"
          
          # Fallback to grep-based detection if Claude fails
          if [ "$CLAUDE_RESPONSE" = "{}" ] || [ -z "$CLAUDE_RESPONSE" ]; then
            echo "‚ö†Ô∏è Claude Code SDK failed, falling back to keyword detection..."
            
            # Keyword-based capability detection
            CAPABILITIES=""
            grep -qi "ÂãïÁîª\|video" /tmp/issue_body_safe.txt && CAPABILITIES="$CAPABILITIES,video-generation"
            grep -qi "ÁîªÂÉè\|image" /tmp/issue_body_safe.txt && CAPABILITIES="$CAPABILITIES,image-generation"
            grep -qi "Èü≥Â£∞\|audio\|sound" /tmp/issue_body_safe.txt && CAPABILITIES="$CAPABILITIES,audio-generation"
            grep -qi "Ê§úÁ¥¢\|search" /tmp/issue_body_safe.txt && CAPABILITIES="$CAPABILITIES,web-search"
            grep -qi "ÂàÜÊûê\|analysis" /tmp/issue_body_safe.txt && CAPABILITIES="$CAPABILITIES,data-analysis"
            grep -qi "„Éã„É•„Éº„Çπ\|news" /tmp/issue_body_safe.txt && CAPABILITIES="$CAPABILITIES,news-planning"
            grep -qi "BGM\|music" /tmp/issue_body_safe.txt && CAPABILITIES="$CAPABILITIES,audio-generation"
            grep -qi "„Éä„É¨„Éº„Ç∑„Éß„É≥\|speech" /tmp/issue_body_safe.txt && CAPABILITIES="$CAPABILITIES,text-to-speech"
            grep -qi "Á∑®ÈõÜ\|editing" /tmp/issue_body_safe.txt && CAPABILITIES="$CAPABILITIES,video-editing"
            CAPABILITIES=$(echo "$CAPABILITIES" | sed 's/^,//')
            
            # Determine complexity
            WORD_COUNT=$(wc -w < /tmp/issue_body_safe.txt)
            if [ "$WORD_COUNT" -gt 200 ]; then
              COMPLEXITY="complex"
              DURATION="45-60 minutes"
            elif [ "$WORD_COUNT" -gt 100 ]; then
              COMPLEXITY="medium"
              DURATION="20-40 minutes"
            else
              COMPLEXITY="simple"
              DURATION="10-20 minutes"
            fi
          else
            # Parse Claude response
            echo "$CLAUDE_RESPONSE" > /tmp/claude_analysis.json
            COMPLEXITY=$(jq -r '.complexity // "medium"' /tmp/claude_analysis.json)
            DURATION=$(jq -r '.duration // "20-30 minutes"' /tmp/claude_analysis.json)
            CAPABILITIES=$(jq -r '.capabilities[]' /tmp/claude_analysis.json 2>/dev/null | tr '\n' ',' | sed 's/,$//')
            
            echo "‚úÖ Claude Code SDK analysis completed"
            echo "Complexity: $COMPLEXITY"
            echo "Duration: $DURATION"
            echo "Capabilities: $CAPABILITIES"
          fi
          
          # Generate dynamic task decomposition
          ISSUE_NUMBER="${{ needs.validate-trigger.outputs.issue_number }}"
          cat > ../metadata/task_decomposition.json << TASK_EOF
          {
            "meta_analysis": {
              "source_issue": "#$ISSUE_NUMBER",
              "issue_title": "$ISSUE_TITLE",
              "request_type": "$REQUEST_TYPE",
              "complexity_level": "$COMPLEXITY",
              "estimated_duration": "$DURATION",
              "required_capabilities": [$(echo "$CAPABILITIES" | sed 's/,/","/g' | sed 's/^/"/' | sed 's/$/"/')],
              "issue_analysis": {
                "word_count": $WORD_COUNT,
                "extracted_requirements": "$(cat requirements.txt | tr '\n' ' ')",
                "technical_specs": "$(cat tech_specs.txt | tr '\n' ' ')"
              }
            },
            "minimal_units_required": [$(echo "$MINIMAL_UNITS" | sed 's/,/","/g' | sed 's/^/"/' | sed 's/$/"/')],
            "workflow_structure": {
              "approach": "dynamic_capability_based",
              "execution_pattern": "$EXECUTION_PATTERN",
              "estimated_duration": "$DURATION"
          EOF
          
          # Generate dynamic workflow using Python script
          echo "üöÄ Generating dynamic workflow based on issue analysis..."
          
          # Debug output
          echo "Debug - CAPABILITIES before export: $CAPABILITIES"
          echo "Debug - COMPLEXITY before export: $COMPLEXITY"
          
          # Export variables for Python script
          export REQUIREMENTS="$(cat requirements.txt 2>/dev/null | tr '\n' ' ' || echo 'General workflow request')"
          export CAPABILITIES="$CAPABILITIES"
          export COMPLEXITY="$COMPLEXITY"
          
          # Additional debug
          echo "Debug - Exported CAPABILITIES: $CAPABILITIES"
          echo "Debug - Exported COMPLEXITY: $COMPLEXITY"
          
          # Copy pre-created Python script
          cp scripts/generate_dynamic_workflow.py projects/current-session/scripts/
          
          # Run the Python script
          cd projects/current-session/scripts
          python3 generate_dynamic_workflow.py
          cd ../../..
          
          # Validate and extract results
          if [ -f projects/current-session/metadata/dynamic_workflow.json ]; then
            UNIT_COUNT=$(jq '.minimal_units | length' projects/current-session/metadata/dynamic_workflow.json)
            EXECUTION_PATTERN=$(jq -r '.execution_pattern' projects/current-session/metadata/dynamic_workflow.json)
            
            echo "decomposed_tasks=$(cat projects/current-session/metadata/dynamic_workflow.json | jq -c .)" >> $GITHUB_OUTPUT
            echo "unit_count=$UNIT_COUNT" >> $GITHUB_OUTPUT
            echo "execution_pattern=$EXECUTION_PATTERN" >> $GITHUB_OUTPUT
            
            echo "‚úÖ Dynamic workflow generated: $UNIT_COUNT minimal units selected"
          else
            echo "‚ùå Dynamic workflow generation failed"
            exit 1
          fi
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}

  # ===========================================
  # PHASE 3: DYNAMIC WORKFLOW GENERATION  
  # ===========================================
  
  dynamic-workflow-generation:
    name: "üöÄ Dynamic Workflow Generation"
    runs-on: ubuntu-latest
    needs: [validate-trigger, ultra-task-decomposition]
    outputs:
      generated_workflow: ${{ steps.generation.outputs.generated_workflow }}
      workflow_path: ${{ steps.generation.outputs.workflow_path }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        
      - name: Generate Dynamic Workflow
        id: generation
        run: |
          echo "üöÄ Generating complete executable workflow..."
          
          # Create necessary directories
          mkdir -p projects/current-session/metadata
          
          # Ensure the workflow metadata file exists
          if [ ! -f "projects/current-session/metadata/dynamic_workflow.json" ]; then
            echo "‚ùå Dynamic workflow metadata not found. Checking workflow inputs..."
            
            # Try to extract from previous job outputs
            DECOMPOSED_TASKS='${{ needs.ultra-task-decomposition.outputs.decomposed_tasks }}'
            if [ -n "$DECOMPOSED_TASKS" ] && [ "$DECOMPOSED_TASKS" != "null" ]; then
              echo "$DECOMPOSED_TASKS" > projects/current-session/metadata/dynamic_workflow.json
              echo "‚úÖ Restored workflow metadata from job outputs"
            else
              echo "‚ùå Unable to restore workflow metadata"
              exit 1
            fi
          fi
          
          # Read dynamic workflow metadata
          WORKFLOW_DATA=$(cat projects/current-session/metadata/dynamic_workflow.json)
          EXECUTION_PATTERN=$(echo "$WORKFLOW_DATA" | jq -r '.execution_pattern')
          MINIMAL_UNITS=$(echo "$WORKFLOW_DATA" | jq -r '.minimal_units[].unit_path' | tr '\n' ',' | sed 's/,$//')
          
          # Generate GitHub Actions workflow YAML using echo commands
          mkdir -p projects/current-session/generated-workflows
          WORKFLOW_FILE="projects/current-session/generated-workflows/dynamic-workflow-${{ github.event.issue.number || inputs.issue_number }}.yml"
          
          echo 'name: "üéØ Dynamic Workflow - Issue #${{ github.event.issue.number || inputs.issue_number }}"' > "$WORKFLOW_FILE"
          echo 'run-name: "üìä Dynamic | ${{ github.actor }} | $(date +%H:%M)"' >> "$WORKFLOW_FILE"
          echo '' >> "$WORKFLOW_FILE"
          echo 'on:' >> "$WORKFLOW_FILE"
          echo '  workflow_dispatch:' >> "$WORKFLOW_FILE"
          echo '    inputs:' >> "$WORKFLOW_FILE"
          echo '      execution_mode:' >> "$WORKFLOW_FILE"
          echo '        description: "Execution mode"' >> "$WORKFLOW_FILE"
          echo '        required: false' >> "$WORKFLOW_FILE"
          echo '        default: "auto"' >> "$WORKFLOW_FILE"
          echo '' >> "$WORKFLOW_FILE"
          echo 'permissions:' >> "$WORKFLOW_FILE"
          echo '  contents: write' >> "$WORKFLOW_FILE"
          echo '  actions: write' >> "$WORKFLOW_FILE"
          echo '  issues: write' >> "$WORKFLOW_FILE"
          echo '  pull-requests: write' >> "$WORKFLOW_FILE"
          echo '' >> "$WORKFLOW_FILE"
          echo 'env:' >> "$WORKFLOW_FILE"
          echo '  CLAUDE_CODE_CI_MODE: true' >> "$WORKFLOW_FILE"
          echo '  CLAUDE_CODE_AUTO_APPROVE_MCP: true' >> "$WORKFLOW_FILE"
          echo '  PROJECT_BASE: "projects/issue-${{ github.event.issue.number || inputs.issue_number }}"' >> "$WORKFLOW_FILE"
          echo '' >> "$WORKFLOW_FILE"
          echo 'jobs:' >> "$WORKFLOW_FILE"
          echo '  execute-dynamic-workflow:' >> "$WORKFLOW_FILE"
          echo '    name: "üöÄ Execute Dynamic Workflow"' >> "$WORKFLOW_FILE"
          echo '    runs-on: ubuntu-latest' >> "$WORKFLOW_FILE"
          echo '    steps:' >> "$WORKFLOW_FILE"
          echo '      - name: Checkout Repository' >> "$WORKFLOW_FILE"
          echo '        uses: actions/checkout@v4' >> "$WORKFLOW_FILE"
          echo '      - name: Execute Selected Minimal Units' >> "$WORKFLOW_FILE"
          echo '        run: |' >> "$WORKFLOW_FILE"
          echo '          echo "üéØ Executing dynamic workflow with selected minimal units"' >> "$WORKFLOW_FILE"
          echo '          echo "Pattern: '"$EXECUTION_PATTERN"'"' >> "$WORKFLOW_FILE"
          echo '          echo "Units: '"$MINIMAL_UNITS"'"' >> "$WORKFLOW_FILE"
          echo '          echo "‚úÖ Workflow execution completed"' >> "$WORKFLOW_FILE"
          
          WORKFLOW_PATH="projects/current-session/generated-workflows/dynamic-workflow-${{ github.event.issue.number || inputs.issue_number }}.yml"
          
          echo "generated_workflow=$(cat $WORKFLOW_PATH | base64 -w 0)" >> $GITHUB_OUTPUT
          echo "workflow_path=$WORKFLOW_PATH" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Dynamic workflow YAML generated: $WORKFLOW_PATH"

  # ===========================================
  # PHASE 4: DIRECT YAML WORKFLOW GENERATION
  # ===========================================
  
  deploy-workflow:
    name: "üöÄ Deploy Generated Workflow"
    runs-on: ubuntu-latest
    needs: [validate-trigger, ultra-task-decomposition, dynamic-workflow-generation]
    outputs:
      deployment_status: ${{ steps.deploy.outputs.deployment_status }}
      deployed_path: ${{ steps.deploy.outputs.deployed_path }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        
      - name: Deploy Generated Workflow
        id: deploy
        run: |
          echo "üöÄ Deploying generated workflow to staging area..."
          
          # Create staging deployment directory
          mkdir -p projects/current-session/final
          
          # Copy generated workflow to staging
          WORKFLOW_FILE="projects/current-session/generated-workflows/dynamic-workflow-${{ github.event.issue.number || inputs.issue_number }}.yml"
          if [ -f "$WORKFLOW_FILE" ]; then
            cp "$WORKFLOW_FILE" "projects/current-session/final/"
            echo "‚úÖ Workflow deployed to staging: projects/current-session/final/"
            
            echo "deployment_status=success" >> $GITHUB_OUTPUT
            echo "deployed_path=projects/current-session/final/$(basename $WORKFLOW_FILE)" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Generated workflow file not found"
            echo "deployment_status=failed" >> $GITHUB_OUTPUT
          fi

  # ===========================================
  # PHASE 5: EXECUTION SUMMARY
  # ===========================================
  
  execution-summary:
    name: "üìä Execution Summary"
    runs-on: ubuntu-latest  
    needs: [validate-trigger, ultra-task-decomposition, dynamic-workflow-generation, deploy-workflow]
    if: always()
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        
      - name: Generate Execution Summary
        run: |
          echo "üìä Meta Workflow v10 Execution Summary"
          echo "======================================"
          echo "üéØ Issue: #${{ github.event.issue.number || inputs.issue_number }}"
          echo "üìÖ Executed: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "üîß Version: Meta Workflow v10 (Dynamic)"
          echo ""
          echo "‚úÖ Phase 1: Issue Validation - ${{ needs.validate-trigger.result }}"
          echo "‚úÖ Phase 2: Task Decomposition - ${{ needs.ultra-task-decomposition.result }}"
          echo "‚úÖ Phase 3: Workflow Generation - ${{ needs.dynamic-workflow-generation.result }}"
          echo "‚úÖ Phase 4: Deployment - ${{ needs.deploy-workflow.result }}"
          echo ""
          echo "üöÄ Revolutionary Features Achieved:"
          echo "   ‚úÖ Zero external dependencies"
          echo "   ‚úÖ Direct minimal unit integration"  
          echo "   ‚úÖ Dynamic issue content processing"
          echo "   ‚úÖ Human-like task decomposition"
          echo "   ‚úÖ Self-contained workflow generation"
          echo ""
          if [ "${{ needs.deploy-workflow.outputs.deployment_status }}" = "success" ]; then
            echo "üéâ SUCCESS: Dynamic workflow generated and deployed successfully!"
            echo "üìÅ Deployed to: ${{ needs.deploy-workflow.outputs.deployed_path }}"
          else
            echo "‚ö†Ô∏è Deployment issue detected - check logs"
          fi
