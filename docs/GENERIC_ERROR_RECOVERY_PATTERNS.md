# Generic Error Recovery Patterns for Workflow Generation

## Overview
This document defines universal error recovery patterns that can be applied to any domain workflow generated by the meta-workflow system.

## Core Principles

### 1. Failure Detection
Every generation task must output its status for tracking:
- `success`: Task completed successfully
- `failed`: Task failed and needs recovery
- `partial`: Task partially completed (some outputs available)

### 2. Recovery Job Pattern
A dedicated recovery job that runs after the main parallel jobs to handle failures.

## Universal Recovery Pattern

### Base Structure
```yaml
# Main generation job (parallel execution)
main-generation:
  name: "Main Generation Tasks"
  strategy:
    matrix:
      item: ${{ fromJson(needs.setup.outputs.items) }}
    fail-fast: false  # Continue other items even if one fails
  continue-on-error: true  # Allow job to "succeed" even with failures
  outputs:
    failed_items: ${{ steps.collect.outputs.failed_items }}
    item_${{ matrix.item }}_status: ${{ steps.verify.outputs.status }}
  steps:
    - name: Execute Generation
      id: generate
      run: |
        # Main generation logic here
        
    - name: Verify Output
      id: verify
      run: |
        # Check if output was generated successfully
        if [ -f "$OUTPUT_FILE" ] && [ $(stat -c%s "$OUTPUT_FILE") -gt $MIN_SIZE ]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "✅ Item ${{ matrix.item }}: SUCCESS"
        else
          echo "status=failed" >> $GITHUB_OUTPUT
          echo "❌ Item ${{ matrix.item }}: FAILED"
          echo "${{ matrix.item }}" >> "${PROJECT_DIR}/metadata/failed_items.txt"
        fi
    
    - name: Collect Failed Items
      id: collect
      if: always()
      run: |
        # Collect all failed items for recovery job
        if [ -f "${PROJECT_DIR}/metadata/failed_items.txt" ]; then
          FAILED_JSON=$(cat "${PROJECT_DIR}/metadata/failed_items.txt" | jq -R . | jq -s .)
          echo "failed_items=${FAILED_JSON}" >> $GITHUB_OUTPUT
        else
          echo "failed_items=[]" >> $GITHUB_OUTPUT
        fi

# Recovery job for failed items
recovery-generation:
  name: "Failed Items Recovery"
  needs: [main-generation]
  if: |
    always() && 
    needs.main-generation.outputs.failed_items != '[]'
  runs-on: ubuntu-latest
  strategy:
    matrix:
      item: ${{ fromJson(needs.main-generation.outputs.failed_items) }}
    max-parallel: 3  # Limit concurrent recovery attempts
  steps:
    - name: Setup Recovery Environment
      run: |
        echo "🔄 Recovering failed item: ${{ matrix.item }}"
        
    - name: Recovery Attempt 1 - Alternative Method
      id: recovery1
      run: |
        # Try with alternative tool/model/approach
        
    - name: Recovery Attempt 2 - Simplified Approach
      if: steps.recovery1.outcome == 'failure'
      id: recovery2
      run: |
        # Try with simplified parameters
        
    - name: Recovery Attempt 3 - Fallback Method
      if: steps.recovery2.outcome == 'failure'
      id: recovery3
      run: |
        # Final attempt with most basic approach

# Final assembly with all recovered items
final-assembly:
  name: "Final Assembly"
  needs: [main-generation, recovery-generation]
  if: |
    always() && 
    (needs.main-generation.result != 'cancelled')
  runs-on: ubuntu-latest
  steps:
    - name: Verify All Items Available
      run: |
        # Check that all required items are present
        # Either from main generation or recovery
```

## Domain-Specific Applications

### Video Production Domain
```yaml
scene-generation:  # Main generation
  outputs:
    failed_scenes: ${{ steps.collect.outputs.failed_scenes }}

scene-recovery:  # Recovery for failed scenes
  strategy:
    matrix:
      scene: ${{ fromJson(needs.scene-generation.outputs.failed_scenes) }}
  steps:
    - name: Recovery with Alternative I2V Model
    - name: Recovery with Reduced Resolution
    - name: Recovery with Static Fallback
```

### Image Generation Domain
```yaml
image-generation:  # Main generation
  outputs:
    failed_images: ${{ steps.collect.outputs.failed_images }}

image-recovery:  # Recovery for failed images
  strategy:
    matrix:
      image: ${{ fromJson(needs.image-generation.outputs.failed_images) }}
  steps:
    - name: Recovery with Different Model
    - name: Recovery with Modified Prompt
    - name: Recovery with Lower Quality
```

### Data Processing Domain
```yaml
data-processing:  # Main processing
  outputs:
    failed_datasets: ${{ steps.collect.outputs.failed_datasets }}

data-recovery:  # Recovery for failed datasets
  strategy:
    matrix:
      dataset: ${{ fromJson(needs.data-processing.outputs.failed_datasets) }}
  steps:
    - name: Recovery with Smaller Batch Size
    - name: Recovery with Alternative Source
    - name: Recovery with Cached Data
```

## Recovery Strategies by Failure Type

### 1. API/Service Failures
- **Strategy 1**: Retry with exponential backoff
- **Strategy 2**: Use alternative service/model
- **Strategy 3**: Use cached/default content

### 2. Resource Limitations
- **Strategy 1**: Reduce quality/resolution
- **Strategy 2**: Split into smaller tasks
- **Strategy 3**: Use simpler approach

### 3. Timeout Issues
- **Strategy 1**: Increase timeout limits
- **Strategy 2**: Simplify processing
- **Strategy 3**: Use pre-computed results

### 4. Validation Failures
- **Strategy 1**: Adjust parameters
- **Strategy 2**: Modify prompts/inputs
- **Strategy 3**: Accept partial results

## Implementation Guidelines

### For Meta-Workflow
1. **Always generate recovery job** for any parallel generation tasks
2. **Include failure detection** in every generation step
3. **Pass failure information** between jobs via outputs
4. **Make recovery optional** with `if: always()` conditions

### For Domain Templates
1. **Define recovery strategies** specific to domain
2. **Specify fallback options** in order of preference
3. **Set recovery attempt limits** (typically 3)
4. **Include partial success handling**

## Benefits
- **Resilience**: Workflows continue despite individual failures
- **Quality**: Maintains intended output quality through retries
- **Efficiency**: Only failed items are reprocessed
- **Debugging**: Clear tracking of what failed and why
- **Flexibility**: Different recovery strategies for different failures